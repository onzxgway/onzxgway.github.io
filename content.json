{"meta":{"title":"朱献国的博客","subtitle":"","description":"","author":"朱献国","url":"http://onzxgway.github.io","root":"/"},"pages":[],"posts":[{"title":"内存管理（下）","slug":"memory-management-2","date":"2020-09-28T10:32:14.000Z","updated":"2020-10-06T03:11:48.994Z","comments":true,"path":"2020/09/28/memory-management-2/","link":"","permalink":"http://onzxgway.github.io/2020/09/28/memory-management-2/","excerpt":"","text":"在开始之前先思考一个问题，就是为什么需要内存管理？iOS系统会在程序退出以后，回收其所有内存，那么开发者还有必要在程序运行过程中耗费时间精力去管理内存吗？答案是肯定的，1：程序运行的过程中，如果不去管理内存，可能会发生内存泄露，而内存泄露会导致程序运行出错甚至直接崩溃闪退。虽然有些情况下的内存泄露，并不会导致上述状况，2：严格的内存管理可以让应用更加合理、高效的使用有限的硬件条件，提高应用程序的性能。 一：内存泄露什么是内存泄露内存泄露指一个对象或者变量在使用完成后没有及时释放掉，一直占用着内存，直到应用停止。 哪些情况下会发生内存泄露iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。所以如果发生了内存泄露，肯定与引用计数有关。1，引用计数的天生缺陷是循环引用，以下是项目中常见的循环引用： delegate：xxxx block：xxxx controller+view：xxxx NSTimer：xxxx 2，错误使用手动引用计数 底层Core Foundation对象，需要手动去管理，如果创建使用之后，没有调用CFRelease方法去释放的话，也会造成内存泄露。3，大次数循环内存暴涨 123 while (true) &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init];&#125; 该循环内产生大量的临时对象，直到循环结束才释放，可能导致内存泄露，解决方法是把循环体放到自动释放池中，及时释放占用内存大的临时变量。 123456 while (true) &#123; @autoreleasepool &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init]; &#125;&#125;4，项目中的第三方导致的内存泄露。 到github上查看三方的Issues，看是否有相关的问答。或者通过网络、书籍、前辈查询相关解决方案。 如何检测内存泄露Xcode自带Instruments工具集可以很方便的检测内存泄露，为了测试效果，在一个测试使用的ViewController中填写如下代码，该代码中first和second互相强引用了对方，构成了循环引用造成内存泄露。 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *first = [NSMutableArray array]; NSMutableArray *second = [NSMutableArray array]; [first addObject:second]; [second addObject:first];&#125; 在Xcode的菜单栏选择Product -&gt; Profile进入Instruments工具集，然后选择leaks，再单击右下角的Choose按钮开始检测。进入检测页面，如下图所示选择好了检测设备和检测项目，点击开始检测按钮，这时候iOS应用会运行起来，由于Leaks是动态监测，所以需要一边操作APP，一边观察Leaks的变化，稍等几秒钟，就可以看到Instruments检测到了我们这次内存泄露，点击暂停检测(也可继续检测)，Instruments会用一个红色的叉叉来表示一次内存泄露的产生，如下图所示。暂停检测之后，点击红色叉（内存泄漏点），Leaks-&gt;选择Call Tree，如下图所示。点击页面底部栏的Call Tree(此处指的是Xcode8以上, Xcode7在右下角)，选择Invert Call Tree和Hide System Libraries，如下图所示。此时界面显示是就是内存泄漏的代码部分，双击代码行，或者右键选择reveal in Xcode即可定位到内存泄漏的代码行。我们也可以切换到Leaks这栏，单击Cycles&amp;Roots，就可以以图的形式显示出来循环引用。这样就可以很方便的找到循环引用对象了。定位到具体错误代码处，剩下的工作就需要开发者自己去完成了。 二：内存分区程序如果想要执行，第一步就需要从磁盘加载到内存中。","categories":[],"tags":[]},{"title":"内存管理（上）","slug":"memory-management-1","date":"2020-09-27T07:34:47.000Z","updated":"2020-10-06T02:32:05.739Z","comments":true,"path":"2020/09/27/memory-management-1/","link":"","permalink":"http://onzxgway.github.io/2020/09/27/memory-management-1/","excerpt":"","text":"iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。本篇博客就是讲解引用计数的原理及特点。 Java语言的内存管理方式是GC垃圾回收机制(Garbage Collection) 一：什么是引用计数，原理是什么引用计数（Reference Count）是一种简单有效的管理对象生命周期的方式。它的原理是：当我们创建一个新对象的时候，它的引用计数为1，当有一个新的指针指向该对象时，我们把其引用计数加1，当某个指针不再指向该对象时，我们将其引用计数减1，当对象的引用计数为0的时候，说明不再被任何指针引用了，我们可以将对象销毁，回收内存。 二：引用计数的分类1，手动引用计数手动引用计数（Manual Reference Count，简称MRC），在此模式下，对象的生命周期需要开发者手动调用retain,release等方法去管理。运行以下代码，可以通过log看到引用计数的变化。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; &#x2F;&#x2F; Override point for customization after application launch. NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); NSObject *antherObj &#x3D; [obj retain]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [antherObj release]; antherObj &#x3D; nil; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [obj release]; &#x2F;&#x2F; 到这里时，obj的内存被释放 return YES;&#125; 运行结果如下： Reference Count = 1 Reference Count = 2 Reference Count = 1 上述代码中NSObject实例的retainCount属性、retain和release方法只在MRC的模式下才能够调用。现在新建的工程默认都是ARC模式，允许以文件为单位关闭ARC模式，开启MRC模式。具体方法就是通过编译列表找到目标文件，在文件后面加上-fno-objc-arc的编译参数即可。 2，自动引用计数自动引用计数（Automatic Reference Count，简称ARC），是苹果在WWDC 2011大会上提出的用于管理内存的技术。在此模式下，编译器会自动添加内存管理的方法，让开发者从繁琐的内存管理中解放出来。 过度依赖ARC问题1.ARC技术能够解决iOS开发中90%的内存管理问题，但是另外10%是需要开发者自己处理的。这主要与底层Core Foundation对象交互的那部分，因为Core Foundation对象不在ARC的管理范畴，所以需要开发者去维护这些对象的引用计数。2.没有正确使用Block导致的循环引用的问题。如果过度依赖ARC，不了解引用计数原理，那面对以上两种情况，会显得一筹莫展。 3，Core Foundation对象内存管理底层Core Foundation对象，大多数以XxxCreateWithXxx形式创建。例如 1234&#x2F;&#x2F; 创建一个CFStringRef对象CFStringRef cfStr &#x3D; CFStringCreateWithCString(kCFAllocatorDefault, &quot;Hello World&quot;, kCFStringEncodingUTF8);&#x2F;&#x2F; 创建一个CFStringRef对象CTFontRef font &#x3D; CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, 16.0, NULL); 对于这些对象引用计数的修改，要相应的使用CFRetain和CFRelease方法。 12345&#x2F;&#x2F; 引用计数加1CFStringRef newStr &#x3D; CFRetain(cfStr); &#x2F;&#x2F; 引用计数减1CFRelease(newStr); CFRetain和CFRelease方法，我们直观的认为，它们与Objective-C中的retain和release方法等价。除此之外，还有另外一个问题需要解决。在ARC下，有时候需要将一个Core Foundation对象转换成一个Objective-C对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整。这就引入了与bridge相关的关键字，以下是这些关键字的说明： __bridge 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_retained 类型转换后，将相关对象的引用计数加1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_transfer 类型转换后，将该对象的引用计数交给ARC管理，原来的Core Foundation对象在不用时，不需要调用CFRelease方法。 根据具体业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objective-C对象相对转换的问题了。 三：引用计数的优点简单有效。 为什么需要引用计数？在没有引用计数的情况下，一般内存管理的原则是“谁申请谁释放”，假如对象A生成了一个对象M，需要调用对象B，将对象M作为参数传递过去。那么对象A就需要在对象B不再需要对象M的时候，将对象M销毁。但是对象B可能只是临时用一下对象M，也可能觉得对象M很重要，将它设置成自己的一个成员变量，在这种情况下，什么时候销毁对象M就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象A在调用完对象B之后，马上就销毁参数对象M，然后对象B需要将参数另外复制一份，生成另一个对象M2，然后自己管理对象M2的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。 还有另外一种方法，就是对象A在构造完对象M之后，始终不销毁对象M，由对象B来完成对象M的销毁工作。如果对象B需要长时间使用对象M，就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好的解决了对象复制的问题，但是它强烈依赖于A、B两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象M的申请是在对象A中，释放在对象B中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象B需要向对象C传递对象M，那么这个对象在对象C中又不能让对象C管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好地解决了这个问题，在参数M的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完了之后再把引用计数减1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便的享受到共享对象带来的好处。 四：引用计数的缺点引用计数这种管理内存的方式虽然简单有效，但是有一个比较大的瑕疵，就是它不能很好的解决循环引用的问题。例如对象A和对象B，相互引用对方作为自己的成员变量，只有自己销毁时，才会将成员变量的引用计数减1。因为对象A的销毁依赖于对象B的销毁，而对象B的销毁又依赖于对象A的销毁，这样就造成了循环应用（reference cycle）的问题。实际项目中不止两个对象存在循环引用问题，多个对象间依次持有，形成一个环状，也会造成循环引用，而且环状越大越难发现。解决方式：1.明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用。2.弱应用的办法。弱引用虽然持有对象，但是并不增加引用计数。","categories":[],"tags":[]},{"title":"iOS并发编程(上)","slug":"Multi-threading-1","date":"2017-02-22T10:21:56.000Z","updated":"2020-10-02T00:58:30.774Z","comments":true,"path":"2017/02/22/Multi-threading-1/","link":"","permalink":"http://onzxgway.github.io/2017/02/22/Multi-threading-1/","excerpt":"并发 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种**API(pthread,NSThread,GCD,NSOperation)**用于并发编程。本文以讲解四种API的使用方法为切入点，带你了解多线程的全貌。","text":"并发 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种**API(pthread,NSThread,GCD,NSOperation)**用于并发编程。本文以讲解四种API的使用方法为切入点，带你了解多线程的全貌。 在学习并发编程之前，首先我们要知道线程的概念，以及线程的一些相关基础知识，这是学习并发编程的基础。 一：什么是线程？线程（thread）是进程的基本单位，一个进程包含一个或多个线程（至少包含一个），操作系统的调度器可以直接调度线程。所有的并发编程API都是构建在线程上的。 二：线程的状态： 新建：线程对象在内存中被创建出来。 就绪：除了CPU以外的所有资源都已分配好了，等待CPU调度。（已经加入可调度线程池中） 运行：CPU正在运行该线程。（当CPU切换执行其它线程的时候，当前线程退回到就绪状态） 阻塞：除了CPU以外，还有其它资源没有分配，（阻塞状态的线程，被移出了可调度线程池） 死亡：线程被销毁，占用的内存空间被释放。 三：并发编程的四种API介绍1，pthread pthread(posix线程) 是一套纯C的API，平时几乎不会使用，如果没有兴趣可以不用了解，当然如果想多掌握一些的话，可以继续往下阅读。 1234567891011121314如何使用：1，导入头文件 #import &lt;pthread.h&gt;2，调用函数 int pthread_create(pthread_t * __restrict,pthread_attr_t * __restrict,void * (*) (void *),void * __restrict);&#x2F;*参数解释 返回值是0 表示创建线程成功 非0表示创建线程失败 1,pthread_t * 线程的标示 2,pthread_attr_t 线程的属性 3,void* (*) (void *) 返回值 函数名 参数 函数签名 void * 约等于OC中的id任意类型 4,void * 给函数的参数 *&#x2F; 2，NSThread NSThread是Objcetive-c基于pthread的封装,封装之后在面向对象的编程环境中，看起来更加的亲切,使用也更加的顺手。一个NSThread对象代表一个线程。 一 如何使用： 【类方法】优点：使用简单，线程创建好之后就是就绪(runnable)状态，CPU可直接调度。缺点：无法拿到线程对象本身，不能对线程对象做更详细的设置。 12+ (void)detachNewThreadWithBlock:(void (^)(void))block;+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 【对象方法】优点：可以拿到线程对象本身，对线程对象做更详细的设置。比如设置线程优先级，或者设置名称。缺点：线程创建好之后处于新建（new）状态,需要手动调用start方法，进入就绪(runnable)状态，没有类方法简单。 123- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;- (instancetype)initWithBlock:(void (^)(void))block;注意：- (instancetype)init方法得到的线程是主线程。 【隐式创建】优缺点和类方法的优缺点相同 12- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg注意：该方法不是NSThread类的方法，而是NSObject的NSThreadPerformAdditions分类中的方法。 【自定义线程类】 123第一步：自定义一个线程类，例如ZXGThread,继承自NSThread类第二步：在ZXGThread类中，重写继承自父类的main方法，把需要在后台子线程中执行的代码放到main方法中。第三步：通过alloc+init方法创建ZXGThread对象，然后调用start方法，即可。 二 常见属性： 12345678910111213141516171819202122232425 &#x2F;&#x2F;线程优先级，double类型，取值范围是：0.0~1.0，默认是0.5，1.0表示优先级最高， &#x2F;&#x2F;优先级越高，表示被CPU调度的概率越高。 逐渐被废弃，用qualityOfService替代thread.threadPriority &#x2F;&#x2F;线程服务质量约等于线程优先级，枚举值，默认是NSQualityOfServiceDefault&#x3D;-1,优先级最低。 &#x2F;&#x2F;iOS8之后比threadPriority好用thread.qualityOfService; &#x2F;&#x2F;线程的名称,主线程默认名称是main，子线程默认名称为null,thread.name; &#x2F;&#x2F;判断当前线程是否是主线程，只读属性thread.isMainThread; &#x2F;&#x2F;判断当前线程是否正在执行任务，只读属性thread.isExecuting; &#x2F;&#x2F;判断当前线程是否执行结束，只读属性thread.isFinished; &#x2F;&#x2F;判断当前线程是否被取消，只读属性thread.isCancelled; &#x2F;&#x2F;线程在stack栈上占用的存储空间，通常为512kb，线程释放后，空间收回。thread.stackSize; 三 常用方法： 12345678910111213141516&#x2F;&#x2F;阻塞方法&#x2F;&#x2F;休眠到指定的时间+ (void)sleepUntilDate:(NSDate *)date;&#x2F;&#x2F;休眠多久+ (void)sleepForTimeInterval:(NSTimeInterval)time;&#x2F;&#x2F;在调试中经常使用，用来获取当前所在的线程对象的。[NSThread currentThread]&#x2F;&#x2F;获取主线程对象[NSThread mainThread]&#x2F;&#x2F;退出线程[NSThread exit];&#x2F;&#x2F;如果自定义线程类，把要执行的任务，放在重写的main方法中。- (void)main &#x2F;&#x2F; thread body method 直接操作线程对象可能引发一个问题是，如果你的代码和项目中使用到的框架的代码都创建了自己的线程时，那么活动的线程的数量有可能以指数级增长。这在大型项目中是一个常见问题。例如：在8核CPU中，你创建了8个线程来发挥CPU性能。然而在这些线程中调用到的框架代码也做了同样的事情（以为他不知道你创建了这些线程），这样会很快产生成百上千的线程，代码每个部分自身都没有问题，但是最终还是导致了问题。每个线程都会消耗一些内存和内核资源。接下来，我将介绍两个基于队列的并发编程API：GCD和NSOperationQueue,它们是通过管理一个可以协同使用的线程池，来解决上面的问题的。 3，GCDGCD(Grand Central Dispatch)是一套底层纯C语言的API,是并发多核的解决方案，其实就是为了让开发者更加容易的使用设备上多核CPU的。 GCD会自动管理线程的生命周期，开发者不用直接和线程打交道，只需要向队列中添加任务即可，GCD在后端管理着一个线程池，通过统一的管理，来避免开启过多的线程。 在学习GCD编程之前，首先我们要深刻理解队列和任务的概念，这是基础，也是GCD的核心概念。 一：队列队列定义：用来存放任务的，先进先出的（FIFO，First in first out)容器。 12&#x2F;&#x2F;队列的类型dispatch_queue_tdispatch_queue_t queue; 队列分类：队列分为两类：串型队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue），系统提供了一个主队列（特殊的串行队列）和一个全局并发队列（属于并发队列）。 【串行队列】让内部的任务一个接着一个执行，等待上一个任务执行完毕，才会接着执行下一个任务。 12345&#x2F;&#x2F;创建一个串行队列dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL); 参数解释：1，队列的名称。 2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。 【并发队列】让队列内部的多个任务同时执行(并发队列只有在异步执行dispatch_async的时候才有效，底层线程池会提供多个线程同时去执行队列中的任务)。 12345&#x2F;&#x2F;创建一个并发队列dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); 参数解释：1，队列的名称。 作用：可以协助开发调试和崩溃报告分析2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。 【主队列】也叫【全局串行队列】主队列是特殊的串行队列，由系统提供的，使用的时候只要去获取即可，无需开发者手动创建，主队列中的任务都是由主线程去执行的。 特点：1，如果主线程正在执行代码暂时不调度任务，等主线程执行结束后在调度任务。这是主队列中同步执行导致死锁的原因。2，UI更新的操作都要放在主线程中处理。 12&#x2F;&#x2F;获取系统提供的主队列dispatch_queue_t mainQueue &#x3D; dispatch_get_main_queue(); 【全局并发队列】全局并发队列就是并发队列，和并发队列行为相同，使用的时候只要去获取即可，无需开发者手动创建。 123456789&#x2F;&#x2F;获取系统提供的全局并发队列dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);&#x2F;&#x2F;参数解释1，指定队列的优先级。DISPATCH_QUEUE_PRIORITY_HIGH (2)DISPATCH_QUEUE_PRIORITY_DEFAULT (0)&#x2F;&#x2F;自定义队列的优先级都是默认优先级DISPATCH_QUEUE_PRIORITY_LOW (-2)DISPATCH_QUEUE_PRIORITY_BACKGROUND (INT16_MIN)2，作为保留字段备用（一般为0) 二：任务任务定义：放到线程中去执行的代码块。 1234&#x2F;&#x2F;任务的类型dispatch_block_tdispatch_block_t task;&#x2F;&#x2F;声明一个任务变量。注意：dispatch_block_t类型是这么定义的typedef void (^dispatch_block_t)(void); 由定义可以看出它本质就是一个无参数无返回值的block. 三：执行任务的函数执行任务的函数有两个，同步执行（dispatch_sync）和异步执行（dispatch_async）*核心区别：是否开启子线程，同步不开启子线程在当前线程执行，异步开启子线程。****使用方法：把任务放到队列里dispatch_sync(queue, block) 和dispatch_async(queue, block) *** 【同步】 123dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);queue：队列block：任务 【异步】 123dispatch_async(dispatch_queue_t queue, dispatch_block_t block);queue：队列block：任务 在了解完了GCD的一些核心基本概念之后，我们研究GCD的真正使用方法 串型队列的执行【串行队列的同步执行】 同步执行:不开线程(在当前线程)。串行队列:任务一次只能执行一个。12345678910#define DISPATCH_QUEUE_SERIAL NULL&#x2F;&#x2F;1，创建串行队列dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);&#x2F;&#x2F;2,创建一个任务dispatch_block_t task &#x3D; ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;;&#x2F;&#x2F;3,将任务添加到队列中&#x2F;&#x2F;同步执行dispatch_sync(serialQueue,task); 【串行队列的异步执行】 异步执行:开启一个子线程，任务在子线程执行，为什么只开启一个，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务。串行队列:任务一次只能执行一个。123456789&#x2F;&#x2F;1，创建串行队列dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);&#x2F;&#x2F;2,创建一个任务dispatch_block_t task &#x3D; ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;;&#x2F;&#x2F;3,将任务添加到队列中&#x2F;&#x2F;异步执行dispatch_async(serialQueue,task); 一般在开发中代码要简写，我上面这么写的目的，是帮助理解。 12345678&#x2F;&#x2F;1，创建串行队列dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);&#x2F;&#x2F;&#x2F;&#x2F;2,异步执行dispatch_async(serialQueue, ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 并发队列的执行【并发队列的同步执行】 同步执行:不开线程(在当前线程)。并发队列:多个任务可以同时执行。执行情况与串行队列的同步执行一模一样。 【并发队列的异步执行】 异步执行:开启多个子线程，任务在子线程执行，具体开启多少个线程是不固定的(线程数，不由我们控制)，线程数是由gcd来决定的。并发队列:多个任务可以同时执行。1234567&#x2F;&#x2F;1，创建并发队列dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);&#x2F;&#x2F;将任务添加到队列中&#x2F;&#x2F;2,异步执行dispatch_async(concurrentQueue,^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 系统提供队列的执行系统已经为我们准备好了2个常用队列主队列（全局串行队列）和全局并发队列，**开发中很多都是使用系统提供的队列，不用自己手动创建** 【主队列的同步执行】 不开线程(在当前主线程执行)，会导致死锁。12345678&#x2F;&#x2F;dispatch_sync(dispatch_get_main_queue(),^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;);注意:当程序执行到这段代码的时候,向主队列中添加了一个任务，此时如果主线程要继续往下执行的话，必须要执行刚添加到主队列中的任务，只有把这个任务执行完毕之后，才可以继续，所以现在要等待调度该任务。而主队列有个特点就是只有主线程不忙的时候，才会去调度主线程执行任务，现在的情况是主线程很忙，所以不会去调度任务，一个等待调度任务执行，一个不让去调度任务，最终导致了死锁。 【主队列的异步执行】 不开线程，因为主队列的任务只有主线程可以执行。同步执行任务。1234&#x2F;&#x2F;异步执行dispatch_async(dispatch_get_main_queue(),^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 【全局并发队列的同步执行】 不开启子线程，在当前线程中顺序执行任务，与执行情况与串行队列的同步执行一模一样。1234&#x2F;&#x2F;同步执行dispatch_sync(dispatch_get_global_queue(0, 0),^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;); 【全局并发队列的异步执行】 执行情况与并发队列的异步执行一模一样。不同的是队列直接获取即可，不用开发者创建。123dispatch_async(dispatch_get_global_queue(0, 0),^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;); 队列的区别比较表格 全局并发队列 手动创建串行队列 主队列 同步(sync) 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 死锁 异步(async) 有开启新线程，并行执行任务 开启新线程，串行执行任务 没有开启新线程，串行执行任务 GCD的其他用法 【GCD延时操作】 dispatch_after 12345678dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);&#x2F;&#x2F;参数解释1，dispatch_time_t when多少纳秒之后执行2，dispatch_queue_t queue任务添加到哪个队列3，dispatch_block_t block要执行的任务 1234&#x2F;&#x2F;延时操作dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;&#125;);注意：如果任务在子线程中执行，那么一定要开启该子线程的消息循环Runloop,此定时任务才会有效执行。 【GCD一次执行】 dispatch_once 代码从程序启动就执行一次 1234567static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; &#x2F;&#x2F;要执行的代码块 &#x2F;&#x2F;只会被执行一次&#125;);实现机制：在静态区分配内存给onceToken变量，并且初始化为0(静态区变量为全局变量，且直到程序退出才会释放onceToken),线程执行到这里时，判断onceToken的值为0，就去执行block,并且onceToken的值更改为-1，第二次再有线程来执行时，判断onceToken的值为-1，就不执行block。 苹果推荐单例的创建方式为 12345678+ (instancetype)sharedSingleton &#123; static id instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance &#x3D; [[self alloc] init]; &#125;); return instance;&#125; 【GCD的队列组】 使用场景：在组里的异步任务都执行完毕后，再去执行其他操作。简言之，就是可以获取到多个线程执行结束的统一时间点。 1234567891011&#x2F;&#x2F; 队列dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);&#x2F;&#x2F; 调度组dispatch_group_t group &#x3D; dispatch_group_create();&#x2F;&#x2F; 添加异步dispatch_group_async(group, queue, ^&#123;&#125;);&#x2F;&#x2F; 调度组通知 - 监听群组中，所有异步执行的代码完成后，得到通知 &#x2F;&#x2F; 异步监听dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F;UI操作&#125;); 1234567891011&#x2F;&#x2F; 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作dispatch_group_t group &#x3D; dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; &#x2F;&#x2F; 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; &#x2F;&#x2F; 执行1个耗时的异步操作&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F; 等前面的异步操作都执行完毕后，回到主线程...&#125;); 4，NSOperation NSOperation是OC基于GCD的封装，相比GCD，NSOperation的使用更加简单，苹果推荐的安全可靠的使用并发编程的方式。 首先详细的介绍两个核心类NSOperation和NSOperationQueue。 NSOperationQueue通过alloc+init创建的队列默认是并发队列。 NSOperation查看原文件发现NSOperation是一个抽象类，不能够直接使用，主要通过它的两个子类NSInvocationOperation和NSBlockOperation来使用的。NSOperation的使用常常是配合NSOperationQueue来进行的。只要是使用NSOperation的子类创建的实例就能添加到NSOperationQueue操作队列之中，一旦添加到队列，操作就会自动异步执行。操作直接调用start方法，则在当前线程执行。 【NSInvocationOperation】 执行操作 123456&#x2F;&#x2F;创建操作NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithTarget:方法所在类对象 selector:@selector(方法名称) object:给方法传递的参数];&#x2F;&#x2F;在当前线程执行方法(开始执行操作)[operation start];注意：不开线程，在当前线程执行。 操作添加到队列 1234567&#x2F;&#x2F;创建操作NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithTarget:方法所在类对象 selector:@selector(方法名称) object:给方法传递的参数];&#x2F;&#x2F;操作添加到队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;默认创建的并发队列[queue addOperation: operation];&#x2F;&#x2F;默认是异步执行注意：开线程，异步执行。 添加多个操作到队列 12345678910&#x2F;&#x2F;创建并发队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];for (int i &#x3D; 0; i &lt; n; ++i) &#123;&#x2F;&#x2F;创建操作NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithTarget:方法所在类对象 selector:@selector(方法名称) object:给方法传递的参数];&#x2F;&#x2F;操作添加到队列[queue addOperation: operation];&#x2F;&#x2F;默认是异步执行&#125;注意：开启多个线程,并发执行相当于GCD并发队列,异步执行。 【NSBlockOperation】 相比NSInvocationOperation使用起来更加简便，所以开发中经常使用。 1234567&#x2F;&#x2F;队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F;操作NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;];&#x2F;&#x2F;添加[queue addOperation:op]; 简便写法 12345&#x2F;&#x2F;队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F;添加操作[queue addOperationWithBlock:^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;]; 监听操作完成 1234567&#x2F;&#x2F;操作NSBlockOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;];&#x2F;&#x2F;监听操作完成[operation setCompletionBlock:^&#123; NSLog(@&quot;over&quot;);&#125;]; 接下来再介绍NSOperationQueue的一些其它的特性和用法。 【最大并发数】 123NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;最大并发数为n：一次最多只能开启n个子线程，同时去执行并发队列中的任务。[operationQueue setMaxConcurrentOperationCount:n]; 【优先级】 队列的优先级iOS8.0之后队列优先级使用qualityOfService属性 123NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;优先级高代表被执行的概率高，而不是一定会先执行。operationQueue.qualityOfService &#x3D; NSQualityOfServiceUserInteractive; 任务的优先级iOS8.0之后任务优先级使用qualityOfService属性替代queuePriority属性 12345NSBlockOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; &#125;];&#x2F;&#x2F;优先级高代表被执行的概率高，而不是一定会先执行。&#x2F;&#x2F;qualityOfService的值是枚举类型，可到文档中具体查看，这里不一一介绍了。operation.qualityOfService &#x3D; NSOperationQueuePriorityNormal; 【队列挂起和任务取消】 12345678NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;挂起 暂停队列中还没有被调度的任务，正在调度的任务，不能被暂停[operationQueue setSuspended:YES];&#x2F;&#x2F;取消挂起 线程继续调度任务执行[operationQueue setSuspended:NO];&#x2F;&#x2F; 取消队列中的所有操作，同样不会影响到正在执行中的操作[operationQueue cancelAllOperations]; 【操作依赖】作用：可以使的任务有序执行。 12345678910111213141516171819202122&#x2F;&#x2F;实例化4个操作NSBlockOperation *operationOne &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1- %@&quot;,[NSThread currentThread]); &#125;];NSBlockOperation *operationTwo &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2- %@&quot;,[NSThread currentThread]); &#125;];NSBlockOperation *operationThree &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;3- %@&quot;,[NSThread currentThread]); &#125;];NSBlockOperation *operationFour &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;4- %@&quot;,[NSThread currentThread]); &#125;]; &#x2F;&#x2F;给操作添加依赖,[operationTwo addDependency:operationOne];[operationThree addDependency:operationTwo];[operationFour addDependency:operationThree];&#x2F;&#x2F;[operationOne addDependency: operationFour];一定不能出现循环依赖结果：1-2-3-4，任务是有序执行的。而且操作依赖更强大的是可以跨队列设置，就算第4步的操作是添加在主队列中的结果不变，依赖依然有效。 【队列中的操作数】 123NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;NSOperationQueue的operationCount属性可以获取当前队列中的任务数量NSLog(@&quot;%@&quot;,operationQueue.operationCount);","categories":[],"tags":[]},{"title":"在MacOS上使用Hexo+GitHub搭建个人博客","slug":"hexo-github-1","date":"2017-02-20T10:21:56.000Z","updated":"2020-10-05T13:24:43.052Z","comments":true,"path":"2017/02/20/hexo-github-1/","link":"","permalink":"http://onzxgway.github.io/2017/02/20/hexo-github-1/","excerpt":"","text":"IT行业的知识体系更新迭代非常频繁，开发者需要不停的去学习新的知识新的技术，那么往往老的知识技术会遗忘的非常快，通过记录总结可以在需要的时候快速回忆起来，其次，互联网IT的精神核心是分享、共享，总结记录下来就可以分享给需要的人。所以，我需要一个可以满足我的需求的方式，个人博客就是一个非常好的方式。 通过Hexo + Github搭建的个人博客，就是一个非常好的选择。首先介绍一下Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 建站具体的建站过程，在这篇博文中不是重点，因为在网络上可以搜索到非常多的教程，任意选择一个即可，我推荐官方的中文建站文档，里面的说明非常全面详细。 重点来了，我在建站过程中踩过的坑，犯过的错误，浪费的时间精力，是我非常想和大家分享的。 执行安装语句出错1sudo npm install -g hexo-cli 报错信息提示需要在语句末尾加上–force 1sudo npm install -g hexo-cli --force 安装成功。 执行hexo d语句出错1hexo d 报错信息 1234You should configure deployment settings in _config.yml first!Available deployer plugins: gitFor more help, you can check the online docs: http://hexo.io/ 纳尼，我就拷贝了deploy的配置语句，追加在_config.yml文件末尾，其他啥也没干啊，怎么就不对了呢，奇怪。 12345deploy:type: gitrepo: git@github.com:onzxgway/onzxgway.github.io.gitbranch: master 在网上查了一番资料才发现，是没有缩进导致的，😭，正确的格式应该是这样的 1234deploy: type: git repo: git@github.com:onzxgway/onzxgway.github.io.git branch: master 更换主题不生效系统默认的主题landscape被我更换为archer之后，重新生成静态文件，部署上线，但是实际不生效。解决方法：在重新生成静态文件前，执行 1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况下（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 配置文件_config.yml您可以在 _config.yml 文件中修改大部分的配置。 在文章中插入图片Hexo配置文件的设置在博客根目录下，配置_config.yml文件，把post_asset_folder字段值由false改为true。设置post_asset_folder参数后，运行hexo n “xxxx”来生成md博文时，hexo会自动创建一个与文章同名的文件夹，您可以把相关的资源都放到此文件夹内，这样就可以更方便的管理和使用资源。 安装hexo-asset-image插件由于hexo默认不支持文章插入本地图片，那么就需要安装hexo-asset-image图片路径转换插件来支持。切换到博客根目录下，运行如下指令安装插件。 1npm install hexo-asset-image --save 插件安装完以后，实际上是存放在…/node_modules/hexo-asset-image目录文件夹下的，如果想要卸载这个插件的话，直接删掉这个文件夹即可。 插入图片运行hexo n “firstblog”指令，创建一篇名为firstblog.md文章，然后查看博客的 …/source/_posts目录，会看到存在一个firstblog文件夹和firstblog.md文件，将博文所需要的资源放到firstblog文件夹下，写博客时使用![图片描述](xxx/xxx.png)直接插入该文件夹内的图片即可。 在文章中插入图片遇到的坑1，在md文件中使用![图片描述](xxx/xxx.png)语法引用图片，图片无法成功加载。 开始查找错误，通过浏览器调试，发现是图片的路径不对，显示为http://example.com/......，奥，瞬间明白了，是由于_config.yml文件中的url没有设置正确值，解决方式很简单就是把url的值修改为http://onzxgway.github.io。修改好了之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 接着查找问题，通过浏览器调试，发现还是图片的路径不对，显示为http://onzxgway.github.io/io//ReferenceCount.png，这就奇怪了，怎么会生成这种路径呢，通过查找资料发现是由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径不对。解决方法就是卸载hexo-asset-image插件，重新安装已经修改过得新插件npm install https://github.com/7ym0n/hexo-asset-image --save 安装成功之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 这就有点不爽了，哪里出问题了呢，还是用浏览器调试，发现图片的路径依然不对，而且第二步更新hexo-asset-image插件一点作用也没起，路径纹丝没动，还是http://onzxgway.github.io/io//ReferenceCount.png，漫长的调试中…，最后发现是我自己犯了一个低级错误，我在博客根目录下安装了hexo-asset-image插件，又在博客的同级目录下也安装了hexo-asset-image插件，我卸载更新的是博客的同级目录下的插件，而真正起作用的根目录下的插件并没有卸载更新，所以最终生成的页面没有任何改变，吐血，因为这个疏忽，多耗费了我两个小时的时间，下次一点要头脑清晰，思路明捷去作业。","categories":[],"tags":[]}],"categories":[],"tags":[]}