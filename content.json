{"meta":{"title":"朱献国的博客","subtitle":"","description":"","author":"朱献国","url":"http://onzxgway.github.io","root":"/"},"pages":[],"posts":[{"title":"RunLoop","slug":"RunLoop","date":"2020-03-03T23:21:52.000Z","updated":"2020-11-05T00:45:28.723Z","comments":true,"path":"2020/03/04/RunLoop/","link":"","permalink":"http://onzxgway.github.io/2020/03/04/RunLoop/","excerpt":"","text":"RunLoop是 iOS 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。 RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234567function loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 OSX/iOS 里的 RunLoop实现了Event Loop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 下载到整个 CoreFoundation 的源码来查看。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。 二者之间是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 123456789101112131415161718192021222324252627282930313233343536373839/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRefCFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRefCFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRefCFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;;struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; /// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次：应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。应用框架层即开发人员接触到的 Cocoa 等框架。核心框架层包括各种核心框架、OpenGL 等内容。Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t; typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, sources1 = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, timers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, sources1 = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, timers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 还有更多苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。","categories":[],"tags":[]},{"title":"runtime(2)","slug":"runtime3","date":"2019-11-02T02:52:11.000Z","updated":"2020-11-02T09:28:57.445Z","comments":true,"path":"2019/11/02/runtime3/","link":"","permalink":"http://onzxgway.github.io/2019/11/02/runtime3/","excerpt":"","text":"消息机制Objective-C语言是运行时语言，消息机制是运行时机制中一个重要的组成部分。方法调用的本质就是发送消息。 定义一个Person类，如下所示。 12345678910111213141516171819202122232425262728@interface Person : NSObject@property (nonatomic, assign)NSUInteger age;- (NSString *)sayHello;- (NSString *)howOldAreYou:(NSString *)name;+ (NSString *)howOldAreYou:(NSString *)name;@end@implementation Person- (NSString *)sayHello &#123; return @&quot;Thank you very much!&quot;;&#125;- (NSString *)howOldAreYou:(NSString *)name &#123; return [NSString stringWithFormat:@&quot;%@ 18 years old!&quot;, name];&#125;+ (NSString *)howOldAreYou:(NSString *)name &#123; return [[[self alloc] init] howOldAreYou:name];&#125;@end 向Person实例发送howOldAreYou消息的方式，有如下几种： 123456789101112131415161718192021222324252627282930313233- (void)demo &#123; Person *person = [[Person alloc] init]; // 1.直接调用 NSString *rst1 = [person howOldAreYou:@&quot;kobe&quot;]; NSLog(@&quot;直接调用 -&gt; %@&quot;, rst1); // 2.performSelector NSString *rst2 = [person performSelector:@selector(howOldAreYou:) withObject:@&quot;kobe&quot;]; NSLog(@&quot;performSelector -&gt; %@&quot;, rst2); // 3.方法签名 + NSInvocation NSMethodSignature *signature = [person methodSignatureForSelector:@selector(howOldAreYou:)]; // 获取方法签名对应的invocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; /** 设置消息接受者，与[invocation setArgument:(__bridge void * _Nonnull)(person) atIndex:0]等价 */ [invocation setTarget:person]; /**设置要执行的selector，与[invocation setArgument:@selector(howOldAreYou:) atIndex:1] 等价*/ [invocation setSelector:@selector(howOldAreYou:)]; // 设置参数 NSString *str = @&quot;kobe&quot;; [invocation setArgument:&amp;str atIndex:2]; // 开始执行 [invocation invoke]; void *returnValue = NULL; if (signature.methodReturnLength) &#123; [invocation getReturnValue:&amp;returnValue]; &#125; id rst3 = (__bridge id)returnValue; NSLog(@&quot;方法签名 -&gt; %@&quot;, rst3); // 4.objc_msgSend id rst4 = ((id(*)(id, SEL, NSString *))objc_msgSend)(person, @selector(howOldAreYou:), @&quot;kobe&quot;); NSLog(@&quot;objc_msgSend -&gt; %@&quot;, rst4);&#125; 该代码的关键之处主要有以下几点： * import runtime 相关的头文件 objc/message.h。 * 使用objc_msgSend函数来负责消息发送。 向Person类发送howOldAreYou消息的方式，有如下几种： 123456789101112- (void)demo &#123; Class clazz = [Person class]; // 1.直接调用 NSString *rst1 = [Person howOldAreYou:@&quot;Mary&quot;]; NSLog(@&quot;直接调用 -&gt; %@&quot;, rst1); // 2.performSelector NSString *rst2 = [clazz performSelector:@selector(howOldAreYou:) withObject:@&quot;Mary&quot;]; NSLog(@&quot;performSelector -&gt; %@&quot;, rst2); // 3.objc_msgSend id rst3 = ((id(*)(id, SEL, NSString *))objc_msgSend)(clazz, @selector(howOldAreYou:), @&quot;Mary&quot;); NSLog(@&quot;objc_msgSend -&gt; %@&quot;, rst3);&#125; 注意：使用objc_msgSend函数时，第一步需要#import &lt;objc/message.h&gt;。第二步需要关闭objc_msgSend函数的严格check（Build Setting -&gt; 搜索msg -&gt; 设置属性为No）。如果不关闭，就需要手动对objc_msgSend函数进行类型转换。 分析：直接调用的方式[person howOldAreYou:@”kobe”]，它的底层是基于objc_msgSend的。下面两行代码就是等价的： OC: [person howOldAreYou:@”kobe”]; C: objc_msgSend(person, @selector(howOldAreYou:), @”kobe”); 消息发送的主要步骤 OC的方法调用最终会生成C函数objc_msgSend(person, @selector(howOldAreYou:), @&quot;kobe&quot;)。这个C函数objc_msgSend就负责消息发送。 消息发送的时候，在C语言函数中发生了什么事情？编译器是如何找到这个方法的呢？消息发送的主要步骤如下： 1.首先检查这个选择器是不是要忽略。比如Mac OS X开发，有了垃圾回收就不会理会retain，release这些函数。 2.检测这个选择器的target是不是nil，OC允许我们对一个nil对象执行任何方法不会Crash，因为运行时会被忽略掉。 3.如果上面两步都通过了，根据实例的isa指针找到类对象，开始查找这个SEL的实现IMP，先从类对象的cache里查找，如果找到了就运行对应的函数去执行相应的代码。 4.如果cache中没有找到就找类的method_list中是否有对应的方法。 5.如果类的方法列表中找不到就到父类的方法列表中查找，一直找到NSObject类为止。 6.如果还是没找到就要开始进入动态方法解析和消息转发，后面会说。 应用场景字典转模型原理：遍历模型类的所有属性，然后用属性名作为key去字典中找对应的value，如果找不到不会crash。 关键代码： 1 KVO原理：系统自动新建一个被监听类的子类，重写被监听属性的set方法，修改被监听对象的isa指针的值，让它指向子类对象。 关键代码：使用objc_setAssociatedObject和objc_getAssociatedObject关联对象。使用object_setClass函数修改对象isa指针。 1","categories":[],"tags":[]},{"title":"runtime(1)","slug":"runtime2","date":"2019-10-28T10:15:32.000Z","updated":"2020-11-02T08:50:04.341Z","comments":true,"path":"2019/10/28/runtime2/","link":"","permalink":"http://onzxgway.github.io/2019/10/28/runtime2/","excerpt":"","text":"动态获取类对象信息使用Objective-C语言提供的与runtime相关的函数，动态的获取类的所有信息包括成员变量、函数列表和协议列表等，如下所示。 先定义一个继承自NSObject的类CTMObject。 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@protocol CTMObjectDelegate1 &lt;NSObject&gt;@end@protocol CTMObjectDelegate2 &lt;NSObject&gt;@end@protocol CTMObjectDelegate4 &lt;NSObject&gt;@end@interface CTMObject : NSObject &lt;CTMObjectDelegate1, CTMObjectDelegate2&gt; &#123; NSNumber *_weight; // 成员变量 对象类型 int _age; // 成员变量 基本数据类型&#125;@property (nonatomic, copy) NSString *name; // 属性 对象类型@property (nonatomic, strong, readonly) NSNumber *height; // 只读属性 对象类型// 类方法+ (void)start:(NSString *)logo;// 实例方法- (NSString *)finish:(BOOL)isOK;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728#import &quot;CTMObject.h&quot;@protocol CTMObjectDelegate3 &lt;NSObject&gt;@end@interface CTMObject()&lt;CTMObjectDelegate3&gt; &#123; NSNumber *_privateWeight; // 私有成员变量 对象类型 int _privateAge; // 私有成员变量 基本数据类型&#125;@property (nonatomic, copy) NSString *privateName; // 私有属性 对象类型@property (nonatomic, strong, readonly) NSNumber *privateHeight; // 私有只读属性 对象类型@end@implementation CTMObject+ (void)start:(NSString *)logo &#123; &#125;- (NSString *)finish:(BOOL)isOK &#123; return @&quot;&quot;;&#125;@end runtime动态获取类信息，如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (void)demo &#123; // isa NSLog(@&quot;元类: %@&quot;, object_getClass(CTMObject.class)); NSLog(@&quot;根元类: %@&quot;, object_getClass(object_getClass(CTMObject.class))); NSLog(@&quot;根元类: %@&quot;, object_getClass(object_getClass(object_getClass(CTMObject.class)))); // super_class NSLog(@&quot;super_class: %@&quot;, class_getSuperclass(CTMObject.class)); // name NSLog(@&quot;name: %s&quot;, class_getName(CTMObject.class)); // version NSLog(@&quot;version: %d&quot;, class_getVersion(CTMObject.class)); // instance_size NSLog(@&quot;instance_size: %ld&quot;, class_getInstanceSize(CTMObject.class)); // ivars unsigned int outCountV = 0; Ivar *ivars = class_copyIvarList(CTMObject.class, &amp;outCountV);// 获取成员变量 (公 + 私) for (int i = 0; i &lt; outCountV; ++i) &#123; Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); const char * type = ivar_getTypeEncoding(ivar); // @&quot;NSNumber&quot; NSLog(@&quot;ivar:%s --&gt; %s&quot;, name, type); &#125; // property unsigned int outCountPL = 0; objc_property_t *pts = class_copyPropertyList(CTMObject.class, &amp;outCountPL);// 获取属性 (公 + 私) for (int i = 0; i &lt; outCountPL; ++i) &#123; objc_property_t pt = pts[i]; const char * name = property_getName(pt); // 获取属性名 const char * type = property_getAttributes(pt); // 获取属性特性描述字符串 T@&quot;NSString&quot;,C,N,V_name T@&quot;NSNumber&quot;,R,N,V_height NSLog(@&quot;property:%s --&gt; %s&quot;, name, type); &#125; // methodLists unsigned int outCountM = 0; Method *methods = class_copyMethodList(CTMObject.class, &amp;outCountM); // 获取成员实例方法 for (int i = 0; i &lt; outCountM; ++i) &#123; Method method = methods[i]; SEL name = method_getName(method); NSLog(@&quot;method:%s --&gt; %s&quot;, sel_getName(name), method_getTypeEncoding(method)); // v16@0:8 // v：代表 void @：代表OC对象 : ：代表 SEL &#125; // protocols unsigned int outCountP = 0; Protocol __unsafe_unretained **pros = class_copyProtocolList(CTMObject.class, &amp;outCountP); // 获取协议 for (int i = 0; i &lt; outCountP; ++i) &#123; Protocol *p = pros[i]; NSLog(@&quot;protocol:%s&quot;, protocol_getName(p)); &#125; &#125; 该代码的关键之处主要有以下几点： * import runtime 相关的头文件 objc/message.h。 * 使用object_getClass函数来获取类对象的isa指针所指向的对象。 * 使用class_getSuperclass函数来获取类对象的父类。 * 使用class_getName函数来获取类对象的类名。 * 使用class_getVersion函数来获取类对象的版本。 * 使用class_getInstanceSize函数来获取类对象实例的大小。 * 使用class_copyIvarList函数来获取类对象成员变量列表（共有+私有）。 * 使用class_copyPropertyList函数来获取类对象属性列表（共有+私有）。 * 使用class_copyMethodList函数来获取类对象成员方法列表（共有实例方法+私有实例方法）。 * 使用class_copyProtocolList函数来获取类对象成员协议列表。 最终得到运行结果如下。 123456789101112131415161718192021222324252627282930313233343536373839元类: CTMObject根元类: NSObject根元类: NSObjectsuper_class: NSObjectname: CTMObjectversion: 0instance_size: 72ivar:_weight --&gt; @&quot;NSNumber&quot;ivar:_age --&gt; iivar:_privateWeight --&gt; @&quot;NSNumber&quot;ivar:_privateAge --&gt; iivar:_name --&gt; @&quot;NSString&quot;ivar:_height --&gt; @&quot;NSNumber&quot;ivar:_privateName --&gt; @&quot;NSString&quot;ivar:_privateHeight --&gt; @&quot;NSNumber&quot;property:privateName --&gt; T@&quot;NSString&quot;,C,N,V_privateNameproperty:privateHeight --&gt; T@&quot;NSNumber&quot;,R,N,V_privateHeightproperty:name --&gt; T@&quot;NSString&quot;,C,N,V_nameproperty:height --&gt; T@&quot;NSNumber&quot;,R,N,V_heightproperty:hash --&gt; TQ,Rproperty:superclass --&gt; T#,Rproperty:description --&gt; T@&quot;NSString&quot;,R,Cproperty:debugDescription --&gt; T@&quot;NSString&quot;,R,Cmethod:privateFinish: --&gt; @20@0:8B16method:privateName --&gt; @16@0:8method:setPrivateName: --&gt; v24@0:8@16method:privateHeight --&gt; @16@0:8method:.cxx_destruct --&gt; v16@0:8method:name --&gt; @16@0:8method:setName: --&gt; v24@0:8@16method:height --&gt; @16@0:8method:finish: --&gt; @20@0:8B16protocol:CTMObjectDelegate3protocol:CTMObjectDelegate1protocol:CTMObjectDelegate2 根据运行结果可以得出如下结论： * 类在runtime面前是透明的，通过runtime可以获取到类的所有信息。 * 成员变量和属性，不论公有还是私有，都可以获取到。 * 类对象中只保存实例方法，类方法保存在对应的元类中。 类对象动态新增信息使用Objective-C语言提供的与runtime相关的函数，动态的给已有类添加新信息，如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#import &lt;objc/runtime.h&gt;#import &quot;CTMObject.h&quot;@implementation AddMemberController- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self demo]; &#125;- (void)eatWithPersonName:(NSString *)name &#123; NSLog(@&quot;Person %@ start eat.&quot;, name);&#125;- (void)highCopy &#123; NSLog(@&quot;highCopy iCanDoIt.&quot;);&#125;// 需求：动态的给CTMObject类，添加成员变量_sex、成员方法newMethod、属性hometown、协议CTMObjectDelegate4- (void)demo &#123; Class clazz = CTMObject.class; // 1.为CTMObject类动态添加成员变量 _sex BOOL res = class_addIvar(clazz, &quot;_sex&quot;, sizeof(NSString *), log2(sizeof(NSString *)), @encode(NSString *)); NSLog(@&quot;%@&quot;, res ? @&quot;ivar 添加成功&quot;: @&quot;ivar 添加失败&quot;); // 2.为CTMObject类动态添加成员方法 newMethod Method method1 = class_getInstanceMethod([self class], @selector(eatWithPersonName:));#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; BOOL resM = class_addMethod(clazz, @selector(newMethod), class_getMethodImplementation([self class], @selector(eatWithPersonName:)), method_getTypeEncoding(method1));#pragma clang diagnostic pop NSLog(@&quot;%@&quot;, resM ? @&quot;Method 添加成功&quot;: @&quot;Method 添加失败&quot;); // 2.1.为CTMObject类动态添加 和已存在方法finish:同名的成员方法 Method method2 = class_getInstanceMethod(clazz, @selector(highCopy));#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; BOOL resO = class_addMethod(clazz, @selector(finish:), class_getMethodImplementation([self class], @selector(highCopy)), method_getTypeEncoding(method2));#pragma clang diagnostic pop NSLog(@&quot;%@&quot;, resO ? @&quot;同名Method 添加成功&quot;: @&quot;同名Method 添加失败&quot;); // 3.为CTMObject类动态添加属性 hometown NSString *propertyName = @&quot;hometown&quot;; // 先判断该属性存在不，不存在再添加 Ivar ivar = class_getInstanceVariable(clazz, [[NSString stringWithFormat:@&quot;_%@&quot;, propertyName] UTF8String]); if (ivar == nil) &#123; objc_property_attribute_t type = &#123;&quot;T&quot;, [[NSString stringWithFormat:@&quot;@\\&quot;%@\\&quot;&quot;, NSStringFromClass(NSString.class)] UTF8String]&#125;; // type = NSString objc_property_attribute_t ownership0 = &#123;&quot;C&quot;, &quot;&quot;&#125;; // C = copy objc_property_attribute_t ownership = &#123;&quot;N&quot;, &quot;&quot;&#125;; // N = nonatomic objc_property_attribute_t backingivar = &#123;&quot;V&quot;, [[NSString stringWithFormat:@&quot;_%@&quot;, propertyName] UTF8String] &#125;; // variable name // Type encoding must be first，Backing ivar must be last。 objc_property_attribute_t attrs[] = &#123;type, ownership0, ownership, backingivar&#125;; BOOL result = class_addProperty(clazz, [propertyName UTF8String], attrs, 4); NSLog(@&quot;%@&quot;, result ? @&quot;property 添加成功&quot;: @&quot;property 添加失败&quot;); if (result) &#123; // 添加get和set方法 class_addMethod(clazz, NSSelectorFromString(propertyName), (IMP)getter, &quot;@@:&quot;); class_addMethod(clazz, NSSelectorFromString([NSString stringWithFormat:@&quot;set%@:&quot;, [propertyName capitalizedString]]), (IMP)setter, &quot;v@:@&quot;); &#125; else &#123; // 如果不能添加成功说明本类已有该property，那就替换。 class_replaceProperty(clazz, [propertyName UTF8String], attrs, 4); // 添加get和set方法 class_addMethod(clazz, NSSelectorFromString(propertyName), (IMP)getter, &quot;@@:&quot;); class_addMethod(clazz, NSSelectorFromString([NSString stringWithFormat:@&quot;set%@:&quot;,[propertyName capitalizedString]]), (IMP)setter, &quot;v@:@&quot;); &#125; &#125; // 4.为CTMObject类动态添加协议 CTMObjectDelegate4 BOOL rstP = class_addProtocol(clazz, @protocol(CTMObjectDelegate4)); NSLog(@&quot;%@&quot;, rstP ? @&quot;protocol 添加成功&quot;: @&quot;protocol 添加失败&quot;); [self auth];&#125;- (void)auth &#123; CTMObject *obj = [[CTMObject alloc] init];#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; // 使用动态新增的方法newMethod [obj performSelector:@selector(newMethod) withObject:@&quot;kobe&quot;];#pragma clang diagnostic pop // 使用动态新增的属性hometown [obj performSelector:NSSelectorFromString([NSString stringWithFormat:@&quot;set%@:&quot;, [@&quot;hometown&quot; capitalizedString]]) withObject:@&quot;kobe&quot;]; NSLog(@&quot;%@&quot;, [obj performSelector:NSSelectorFromString(@&quot;hometown&quot;)]);&#125;id getter(id self, SEL _cmd) &#123; NSString *key = NSStringFromSelector(_cmd); Ivar ivar = class_getInstanceVariable([self class], &quot;_dictCustomerProperty&quot;); //basicsViewController里面有个_dictCustomerProperty属性 NSMutableDictionary *dictCustomerProperty = object_getIvar(self, ivar); return [dictCustomerProperty objectForKey:key];&#125;void setter(id self, SEL _cmd, id newValue) &#123; // 移除set NSString *key = [NSStringFromSelector(_cmd) stringByReplacingCharactersInRange:NSMakeRange(0, 3) withString:@&quot;&quot;]; // 首字母小写 NSString *head = [key substringWithRange:NSMakeRange(0, 1)]; head = [head lowercaseString]; key = [key stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:head]; // 移除后缀 &quot;:&quot; key = [key stringByReplacingCharactersInRange:NSMakeRange(key.length - 1, 1) withString:@&quot;&quot;]; Ivar ivar = class_getInstanceVariable([self class], &quot;_dictCustomerProperty&quot;); //basicsViewController里面有个_dictCustomerProperty属性 NSMutableDictionary *dictCustomerProperty = object_getIvar(self, ivar); if (!dictCustomerProperty) &#123; dictCustomerProperty = [NSMutableDictionary dictionary]; object_setIvar(self, ivar, dictCustomerProperty); &#125; [dictCustomerProperty setObject:newValue forKey:key];&#125;@end 该代码的关键之处主要有以下几点： * import runtime 相关的头文件 objc/message.h。 * 使用class_addMethod函数给类添加成员方法。 * 使用class_getInstanceMethod函数获取Method。 * 使用class_getInstanceVariable函数获取Ivar。 * 使用class_addProperty函数给类添加属性。 * 使用class_addProtocol函数给类添加协议。 注意：class_addIvar函数不能给已有类添加成员变量。 最终，得到的运行结果如下： 1234567ivar 添加失败Method 添加成功同名Method 添加失败property 添加成功protocol 添加成功Person kobe start eat. 根据运行结果，可得出如下结论：1，已存在的类，不可以动态添加成员变量。2，已存在的类，可以动态添加成员方法，且能够遍历到动态添加的方法，但是不能和已有成员方法重名。3，已存在的类，可以动态添加属性。优点：能够在已有的类中添加property，且能够遍历到动态添加的属性。缺点：比较麻烦，getter和setter需要自己写，且值也需要自己存储，如上面的代码，是把setter中的值存储到了_dictCustomerProperty里面，在getter中再从_dictCustomerProperty读出值。4，已存在的类，可以动态添加协议，且能够遍历到动态添加的协议。 动态创建类对象使用Objective-C语言提供的与runtime相关的函数，动态的创建一个新的类，如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#import &lt;objc/message.h&gt;@implementation RTIsaViewController &#123; Class _clazz;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self demo];&#125;// 动态创建类- (void) demo &#123; // 创建一个名为CustomView的类，它是UIView的子类。 _clazz = objc_allocateClassPair(UIView.class, &quot;CustomView&quot;, 0); // 为CustomView类添加report方法 class_addMethod(_clazz, @selector(report), (IMP)report, &quot;v@:&quot;); // 为CustomView类添加_name成员变量 class_addIvar(_clazz, [@&quot;_name&quot; UTF8String], sizeof(NSString *), log2(sizeof(NSString *)), @encode(NSString *)); // 注册该类 注册之后，不能再添加成员变量了 objc_registerClassPair(_clazz); [self auth];&#125;- (void)auth &#123; // 创建CustomView实例 id obj = [[_clazz alloc] init];#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; // 调用report方法 [obj performSelector:@selector(report)];#pragma clang diagnostic pop // 设置_name成员变量值 [obj setValue:@&quot;kobe&quot; forKey:@&quot;_name&quot;]; // 获取_name成员变量值 NSLog(@&quot;%@&quot;, [obj valueForKey:@&quot;_name&quot;]);&#125;void report(id self, SEL _cmd) &#123; NSLog(@&quot;This object is %@&quot;, self); NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]); Class curClass = [self class]; for (int i = 0; i &lt; 5; ++i) &#123; NSLog(@&quot;Following the isa pointer %d times gives %p.&quot;, i, curClass); curClass = object_getClass(curClass); &#125; NSLog(@&quot;NSObject Class is %p.&quot;, [NSObject class]); NSLog(@&quot;NSObject meta class is %p.&quot;, object_getClass([NSObject class]));&#125;@end 该代码的关键之处主要有以下几点： * import runtime 相关的头文件 objc/message.h。 * 使用objc_allocateClassPair函数创建新的类。 * 使用class_addMethod函数给类添加实例方法。 * 使用class_addIvar函数给类添加成员变量。 * 使用objc_registerClassPair函数来注册新的类。 * 使用object_getClass函数来获取类对象的isa指针所指向的对象。 最终，得到的运行结果如下： 12345678910This object is &lt;CustomView: 0x7f9720c23ec0; frame = (0 0; 0 0); layer = &lt;CALayer: 0x60000082e380&gt;&gt;Class is CustomView, and super is UIView.Following the isa pointer 0 times gives 0x600000639050.Following the isa pointer 1 times gives 0x6000006390e0.Following the isa pointer 2 times gives 0x7fff89c1ecd8.Following the isa pointer 3 times gives 0x7fff89c1ecd8.Following the isa pointer 4 times gives 0x7fff89c1ecd8.NSObject Class is 0x7fff89c1ed00.NSObject meta class is 0x7fff89c1ecd8.kobe 将上面的运行结果中的内存地址与对应的类画在下图中，可以清楚看到：1，从CustomView对象开始，在连续取了3次isa指针所指向的对象后，isa指针指向的地址变成了0x7fff89c1ecd8，也就是NSObject元类的地址。之后第四次取isa指针所指的对象时，其结果仍然为0x7fff89c1ecd8，这说明NSObject元类的isa指针确实是指向它自己的。 2，作为对比，我们在代码最后获取了NSObject类的isa指针地址，其值是0x7fff89c1ecd8，这说明所有的元类对象的isa指针，都是指向NSObject元类的。 3，已存在的类中不能添加成员变量，所有必须通过objc_allocateClassPair动态创建一个类，才能调用class_addIvar添加Ivar，最后通过objc_registerClassPair注册class。 Method Swizzling方法交换的本质是交换两个方法的IMP。 Objective-C提供了以下API来动态替换类方法或实例方法的实现： class_replaceMethod method_exchangeImplementations method_setImplementation 具体使用方式如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#import &quot;ExChangeMethodController.h&quot;#import &lt;objc/runtime.h&gt;@interface ExChangeMethodController ()@end@implementation ExChangeMethodController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self methodOne]; [self methodTwo]; [self methodThree]; &#125;);&#125;// 1.交换两个方法的实现+ (void)methodOne &#123; Method method1 = class_getInstanceMethod(self.class, @selector(viewWillAppear:)); Method method2 = class_getInstanceMethod(self.class, @selector(__viewWillAppear:)); method_exchangeImplementations(method1, method2);&#125;- (void)__viewWillAppear:(BOOL)animated &#123; NSLog(@&quot;交换两个方法的实现&quot;); [self __viewWillAppear:YES];&#125;// 2.给方法设置实现方式+ (void)methodTwo &#123; Method method = class_getInstanceMethod(self.class, @selector(viewDidAppear:)); void(*originalIMP)(id self, SEL _cmd) = nil; originalIMP = (typeof(originalIMP))method_getImplementation(method); id block = ^(id self, SEL _cmd) &#123; NSLog(@&quot;给方法设置实现方式&quot;); originalIMP(self, _cmd); &#125;; IMP newIMP = imp_implementationWithBlock(block); method_setImplementation(method, newIMP);&#125;// 3.替换方法定义+ (void)methodThree &#123; Method replaceMethod = class_getInstanceMethod(self.class, @selector(kobe)); class_replaceMethod(self.class, @selector(james), method_getImplementation(replaceMethod), method_getTypeEncoding(replaceMethod)); id obj = [[self.class alloc] init]; [obj james];&#125;- (void)kobe &#123; NSLog(@&quot;kobe 替换方法定义&quot;);&#125;- (void)james &#123; NSLog(@&quot;james 替换方法定义&quot;);&#125;@end 该代码的关键之处主要有以下几点： * import runtime 相关的头文件 objc/runtime.h。 * 使用class_getInstanceMethod函数获取类对象的Method。 * 使用method_exchangeImplementations函数交换两个方法的实现。 * 使用method_getImplementation函数获取Method的实现IMP。 * 使用method_getTypeEncoding函数获取Method的类型。 * 使用method_setImplementation函数设置一个方法的实现。 * 使用class_replaceMethod函数替换类方法的定义。 注意：1，class_replaceMethod，当类中没有想替换的原方法时，该方法会调用class_addMethod来为该类增加一个新方法，正因为如此，class_replaceMethod在调用是需要传入types函数。 2，method_exchangeImplementations的内部实现其实是调用了两次method_setImplementation方法，从苹果的文档中能清晰的了解到，如下如所示。 由以上的区别可以总结出这三个API的使用场景： class_replaceMethod，当需要替换的方法有可能不存在时，可以考虑使用该方法。 method_exchangeImplementations，当需要交换两个方法的实现时使用。 method_setImplementation是最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。","categories":[],"tags":[]},{"title":"Objective-C对象模型","slug":"runtime1","date":"2019-03-27T12:10:50.000Z","updated":"2020-10-28T13:13:21.651Z","comments":true,"path":"2019/03/27/runtime1/","link":"","permalink":"http://onzxgway.github.io/2019/03/27/runtime1/","excerpt":"","text":"isa指针Objective-C是一门面向对象的编程语言，每一个对象都是一个类的实例。在Objective-C语言的内部，每一个对象都有一个名为isa的指针，指向该对象所属的类。每一个类描述了一系列它的实例的特点，包括成员变量列表、成员函数列表等。每一个对象都可以接受消息，而对象能够接受的消息列表保存在它所对应的类中。 在Xcode中，打开NSObject的定义头文件，可以看到，NSObject就是一个包含isa指针的结构体，如下所示。 1234567// NSObject.h@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 12345678// objc.h/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 按照面向对象语言的设计原则，所有事物都应该是对象（严格来说Objective-C并没有完全做到这一点，因为它有像int、double这样的简单变量类型）。在Objective-C语言中，每一个类实际上也是一个对象。每一个类也有一个名为isa的指针。每一个类也可以接收消息，例如代码[NSObject alloc]，就是向NSObject这个类发送名为alloc的消息。 在Xcode中，打开Class的定义头文件，可以看到，Class也是一个包含isa指针的结构体，如下所示。 123456789101112131415161718// runtime.hstruct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 因为类也是一个对象，所有它也必须是另一个类的实例，这个类是元类（metaclass）。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，这样可以一直找到继承链的头。 元类也是一个对象，那么元类的isa指针又指向哪里呢？为了设计上的完整，所有元类的isa指针都会指向一个根元类（root metaclass）。根元类本身的isa指针指向自己，这样就形成了一个闭环。上面提到，一个对象能够接收的消息列表是保存咋它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发信息的情况，那它的isa指针在实际上很少用到。不过这么设计保证了面向对象概念在Objective-C语言中完整，即语言中的所有事物都是对象，都有isa指针。 再来看看继承关系，由于类方法的定义是保存在元类中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法在子类中可以被调用，所有子类的元类都会继承父类的元类，换言之，类对象和元类对象有着同样的继承关系。 下面这张图更清楚的说明了isa和继承的关系。 从图中可以看出： NSObject的类中定义了实例方法，例如-(id)init和-(void)dealloc方法。 NSObject的元类中定义了类方法，例如+(id)alloc、+(void)load和+(void)initialize方法。 NSObject的元类继承自NSObject类，所以NSObject是所有类的根，因此NSObject中定义的实例方法可以被所有对象调用，例如-(id)init和-(void)dealloc方法。 NSObject的元类的isa指向自己。 类的成员变量如果把类的实例看成一个结构体的话，上面说的isa指针就是这个结构体的第一个成员变量，而类的其他成员变量依次排列在结构体中。如下图所示。 因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化，所以无法在运行时动态地给对象添加成员变量。 相应地，对象的方法定义都保存在类的可变区域中，方法的定义列表是一个名为methodLists的指针的指针，通过修改该指针指向的指针的值，就可以动态地为某一个类增加成员方法。这也是Category实现的原理。同时也说明了为什么Category只可为对象增加成员方法，却不能增加成员变量。 因为isa本身也只是一个指针，所以除了对象的方法可以动态地修改外，我们也可以在运行时动态地修改isa指针的值，达到替换对象整个行为的目的，不过该应用场景较少。 objc_class详解类对象是由Class类型来表示的，它是一个objc_class结构类型，如下所示。 objc_class结构类型 12345678910111213141516171819202122232425struct objc_class &#123; // 类对象的指针指向其所属的类，即元类。元类中存储着类对象的类方法，当访问某个类的类方法时会通过该isa指针从元类中寻找方法对应的函数指针。 Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ // 指向该类所继承的父类对象，如果该类已经是最顶层的根类(如NSObject或NSProxy), 则为NULL。 Class _Nullable super_class OBJC2_UNAVAILABLE; // 类的名称 const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; // 类的实例大小 long instance_size OBJC2_UNAVAILABLE; // 类成员变量列表 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; // 类成员函数列表 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; // 缓存调用过的方法 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; // 类成员协议列表 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ objc_ivar结构类型 1234567891011struct objc_ivar &#123; // 成员变量名称 char * _Nullable ivar_name OBJC2_UNAVAILABLE; // 成员变量类型 char * _Nullable ivar_type OBJC2_UNAVAILABLE; // 成员变量偏移 int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; objc_method结构类型 12345678struct objc_method &#123; // 方法名称 SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法编码 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法地址 函数实现体指针 IMP _Nonnull method_imp OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;","categories":[],"tags":[]},{"title":"网络安全","slug":"AFNetworking-Security","date":"2018-11-24T02:30:07.000Z","updated":"2020-10-26T11:55:04.634Z","comments":true,"path":"2018/11/24/AFNetworking-Security/","link":"","permalink":"http://onzxgway.github.io/2018/11/24/AFNetworking-Security/","excerpt":"","text":"HTTP超文本传输协议用于客户与服务器端之间的通信。 告知服务器客户端意图的HTTP方法，包括以下几种： ① GET：直接访问URI识别的资源，也就是说根据URI来获取资源。 ② POST： 用来传输实体的主体。 ③ PUT：用来传输文件。 ④ HEAD：用来获取报文首部，和GET方法差不多，只是响应部分不会返回主体内容。 ⑤ DELETE：删除文件，和PUT恰恰相反。按照请求的URI来删除指定位置的资源。 ⑥ OPTIONS：询问支持的方法，用来查询针对请求URI指定的资源支持的方法。 ⑦ TRACE：追踪路径，返回服务器端之前的请求通信环信息。 ⑧ CONNECT：要求用隧道协议连接代理，要求在与代理服务器通信时简历隧道，实现用隧道协议进行TCP通信。SSL(Secure Sockets Layer)和TLS(Transport Layer Security)就是把通信内容加密后进行隧道传输的。 HTTP是一套很简单、高效的通信协议。缺点就是通信数据都是明文发送的，很容易被拦截后造成破坏，所以使用HTTP协议传输隐私数据时非常不安全。于是网景公司在1994年设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS(Hyper Text Transfer Protocol over Secure Socket Layer)。 HTTPS超文本传输安全协议是客户端与服务端之间通信安全的解决方案。HTTP + 加密 + 认证 + 完整性保护 = HTTPS，其实HTTPS就是身披SSL外壳的HTTP。HTTPS采用共享密钥加密（对称）和公开密钥加密（非对称）两者并用的混合加密机制。 HTTPS工作流程①. 客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 ②. 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 ③. 传送证书这个证书其实就是公钥，包含了很多信息，如证书的颁发机构，过期时间等等。 ④. 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，否则看不到被锁住的内容。 ⑤. 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加解密了。 ⑥. 服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(对称加密的私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，否则无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 ⑦. 传输加密后的信息这部分信息是服务段用对称加密的私钥加密后的信息，可以在客户端被还原。 ⑧. 客户端解密信息客户端用之前生成的对称加密的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 以上就是HTTPS的原理解析。 HTTPS更加详细的流程 AFSecurityPolicy苹果已经封装了HTTPS连接的建立、数据的加密解密功能，我们可以直接访问https网站。但苹果并没有验证证书合法性，无法避免中间人攻击。要做到真正安全通讯，需要我们手动去验证服务端返回的证书。AFNetworking中的AFSecurityPolicy模块主要是用来验证HTTPS请求时证书的合法性。AFSecurityPolicy封装了证书验证的过程，让用户可以轻易使用，除了去系统信任CA机构列表验证，还支持SSL Pinning方式的验证。 AFSecurityPolicy 是用来验证证书的 AFSecurityPolicy.h 认证方式的枚举 1234567891011/* 要实现认证功能需要添加系统的Security */#import &lt;Security/Security.h&gt; // 当满足一个有限的并具有统一主题集合的时候，就考虑用枚举。typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; AFSSLPinningModeNone, // 客户端不认证 无条件信任服务器的证书 AFSSLPinningModePublicKey, // 客户端认证公钥 AFSSLPinningModeCertificate,// 客户端会对服务器返回的证书同本地证书全部进行校验&#125;; 本类提供了四个属性来让我们获取需要的内容 123456789101112131415161718192021&#x2F;** SSL Pinning的类型。默认的是&#96;AFSSLPinningModeNone&#96;. *&#x2F;@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;&#x2F;** 这个属性保存着所有的可用做校验的证书的集合。AFNetworking默认会搜索工程中所有.cer的证书文件。如果想制定某些证书，可使用certificatesInBundle在目标路径下加载证书，然后调用policyWithPinningMode:withPinnedCertificates创建一个本类对象。注意： 只要在证书集合中任何一个校验通过，evaluateServerTrust:forDomain: 就会返回true，即通过校验。 *&#x2F;@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;&#x2F;** 允许无效或过期的证书，默认是不允许 *&#x2F;@property (nonatomic, assign) BOOL allowInvalidCertificates; &#x2F;** 验证证书中的域名domain，默认是&#96;YES&#96; *&#x2F;@property (nonatomic, assign) BOOL validatesDomainName; 初始化方法 12345678910111213141516171819&#x2F;** 默认的实例对象，默认的认证设置为：1. 不允许无效或过期的证书2. 验证domain3. 不对证书和公钥进行验证 *&#x2F;+ (instancetype)defaultPolicy;&#x2F;** 根据pinningMode 创建security policy *&#x2F;+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode;&#x2F;** 根据pinningMode和pinnedCertificates 创建security policy *&#x2F;+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet &lt;NSData *&gt; *)pinnedCertificates; 功能方法 12345678910&#x2F;**返回指定bundle中的证书。如果使用AFNetworking的证书验证 ，就必须实现此方法，并且使用policyWithPinningMode:withPinnedCertificates 方法来创建实例对象。 *&#x2F;+ (NSSet &lt;NSData *&gt; *)certificatesInBundle:(NSBundle *)bundle;&#x2F;** 核心方法：使用起来是这样的，这个方法AFNetworking在内部调用了。 *&#x2F;- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain; AFSecurityPolicy.m 判断服务器是否是可信任的 1234567891011121314151617static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid &#x3D; NO; SecTrustResultType result; &#x2F;&#x2F; 这个方法会把结果赋值给result 评估／判定（根据策略，如果policy是通过domain生成的，则是域名相关policy验证） __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); &#x2F;&#x2F;kSecTrustResultUnspecified：不是自己设的证书的通过 &#x2F;&#x2F;kSecTrustResultProceed：用户自己生成证书通过 &#x2F;* 大概意思是分两种方式：下边的自定义的意思是，用户是否是自己主动设置信任的，比如有些弹窗，用户点击了信任 1.用户自定义的，成功是 kSecTrustResultProceed 失败是kSecTrustResultDeny 2.非用户定义的， 成功是kSecTrustResultUnspecified 失败是kSecTrustResultRecoverableTrustFailure *&#x2F; isValid &#x3D; (result &#x3D;&#x3D; kSecTrustResultUnspecified || result &#x3D;&#x3D; kSecTrustResultProceed);_out: return isValid;&#125; 取出服务器返回的所有证书 1234567891011static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; CFIndex certificateCount &#x3D; SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain &#x3D; [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i &#x3D; 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate &#x3D; SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; return [NSArray arrayWithArray:trustChain];&#125; 取出服务器返回的所有证书中的公钥 123456789101112131415161718192021222324252627282930313233static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; SecPolicyRef policy &#x3D; SecPolicyCreateBasicX509(); CFIndex certificateCount &#x3D; SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain &#x3D; [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i &#x3D; 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate &#x3D; SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] &#x3D; &#123;certificate&#125;; CFArrayRef certificates &#x3D; CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125; 取出证书中的公钥 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey &#x3D; nil; SecCertificateRef allowedCertificate; SecPolicyRef policy &#x3D; nil; SecTrustRef allowedTrust &#x3D; nil; SecTrustResultType result; &#x2F;&#x2F; 1. 根据二进制的certificate生成SecCertificateRef类型的证书 &#x2F;&#x2F; NSData *certificate 通过CoreFoundation (__bridge CFDataRef)转换成 CFDataRef &#x2F;&#x2F; 看下边的这个方法就可以知道需要传递参数的类型 &#x2F;* SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef __nullable allocator, CFDataRef data) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0); *&#x2F; allowedCertificate &#x3D; SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); &#x2F;&#x2F; 2.如果allowedCertificate为空，则执行标记_out后边的代码 __Require_Quiet(allowedCertificate !&#x3D; NULL, _out); &#x2F;&#x2F; 3.新建policy为X.509 policy &#x3D; SecPolicyCreateBasicX509(); &#x2F;&#x2F; 4.创建SecTrustRef对象，如果出错就跳到_out标记处 __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); &#x2F;&#x2F; 5.校验证书的过程，这个不是异步的。 __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); &#x2F;&#x2F; 6.在SecTrustRef对象中取出公钥 allowedPublicKey &#x3D; (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; return allowedPublicKey;&#125; 比较两个SecKeyRef是否相等 123456789101112131415161718192021222324252627#if !TARGET_OS_IOS &amp;&amp; !TARGET_OS_WATCH &amp;&amp; !TARGET_OS_TV&#x2F;&#x2F; SecKeyRef转为NSDatastatic NSData * AFSecKeyGetData(SecKeyRef key) &#123; CFDataRef data &#x3D; NULL; __Require_noErr_Quiet(SecItemExport(key, kSecFormatUnknown, kSecItemPemArmour, NULL, &amp;data), _out); return (__bridge_transfer NSData *)data;_out: if (data) &#123; CFRelease(data); &#125; return nil;&#125;#endif&#x2F;&#x2F; 这个方法是比较两个key是否相等，如果是ios&#x2F;watch&#x2F;tv直接使用isEqual方法就可进行比较。因为SecKeyRef本质上是一个struct，是不能直接用isEqual比较的，正好使用上边的那个方法把它转为NSData就可以了。static BOOL AFSecKeyIsEqualToKey(SecKeyRef key1, SecKeyRef key2) &#123;#if TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV return [(__bridge id)key1 isEqual:(__bridge id)key2];#else return [AFSecKeyGetData(key1) isEqual:AFSecKeyGetData(key2)];#endif&#125; 核心方法 当服务器响应提出进行证书验证时，根据之前设置的验证策略来调用该方法进行验证是否通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; &#x2F;&#x2F; 当使用自建证书验证域名时，需要使用AFSSLPinningModePublicKey或者AFSSLPinningModeCertificate进行验证 if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode &#x3D;&#x3D; AFSSLPinningModeNone || [self.pinnedCertificates count] &#x3D;&#x3D; 0)) &#123; &#x2F;&#x2F; https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;mac&#x2F;documentation&#x2F;NetworkingInternet&#x2F;Conceptual&#x2F;NetworkingTopics&#x2F;Articles&#x2F;OverridingSSLChainValidationCorrectly.html &#x2F;&#x2F; According to the docs, you should only trust your provided certs for evaluation. &#x2F;&#x2F; Pinned certificates are added to the trust. Without pinned certificates, &#x2F;&#x2F; there is nothing to evaluate against. &#x2F;&#x2F; &#x2F;&#x2F; From Apple Docs: &#x2F;&#x2F; &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). &#x2F;&#x2F; Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot; NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;); return NO; &#125; NSMutableArray *policies &#x3D; [NSMutableArray array]; &#x2F;&#x2F; 需要验证域名时，需要添加一个验证域名的策略 SecPolicyRef if (self.validatesDomainName) &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; &#x2F;&#x2F; 设置验证的策略 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); if (self.SSLPinningMode &#x3D;&#x3D; AFSSLPinningModeNone) &#123; &#x2F;&#x2F; SSLPinningMode为AFSSLPinningModeNone时，allowInvalidCertificates为YES，则代表服务器任何证书都能验证通过； 如果它为NO，则需要判断此服务器证书是否是系统信任的证书 return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; &#x2F;* 代码能够走到这里说明了 1 全部信任：allowInvalidCertificates &#x3D; YES 或者 域名是对的 信任 2 通过了根证书的验证（AFServerTrustIsValid） *&#x2F; &#x2F;&#x2F; 1 获取验证策略的数据 2 设置策略 3 验证 switch (self.SSLPinningMode) &#123; case AFSSLPinningModeCertificate: &#123; &#x2F;&#x2F; 全部校验 &#x2F;* self.pinnedCertificates 取本地证书文件.cer，转化成NSData类型 *&#x2F; NSMutableArray *pinnedCertificates &#x3D; [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];&#x2F;&#x2F; 根据data生成证书对象 &#125; &#x2F;* 给serverTrust设置锚证书，即再SecTrustEvaluate评估过程中，会根据锚(pinnedCertificates)来进行验证 *&#x2F; SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); &#x2F;&#x2F; 校验能够信任 if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; &#x2F;&#x2F; obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#39;s the Root CA) &#x2F;&#x2F; 从serverTrust评估信任的证书链中获取的证书（AFServerTrustIsValid后再次验证） NSArray *serverCertificates &#x3D; AFCertificateTrustChainForServerTrust(serverTrust); &#x2F;&#x2F; 判断本地证书和服务器证书是否相同 for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; case AFSSLPinningModePublicKey: &#123; NSUInteger trustedPublicKeyCount &#x3D; 0; &#x2F;&#x2F; AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证 NSArray *publicKeys &#x3D; AFPublicKeyTrustChainForServerTrust(serverTrust);&#x2F;&#x2F; 从证书中拿公钥数据 &#x2F;&#x2F; 找到相同的公钥就通过 for (id trustChainPublicKey in publicKeys) &#123; for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount +&#x3D; 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; default: return NO; &#125; return NO;&#125;","categories":[],"tags":[]},{"title":"AFNetworking解析","slug":"AFNetworking解析","date":"2018-10-22T00:58:30.000Z","updated":"2020-10-24T02:25:36.780Z","comments":true,"path":"2018/10/22/AFNetworking解析/","link":"","permalink":"http://onzxgway.github.io/2018/10/22/AFNetworking%E8%A7%A3%E6%9E%90/","excerpt":"","text":"第一步使用AFNetworking的第一步，就是创建AFHTTPSessionManager对象，方式如下： 1AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager]; AFHTTPSessionManager继承自AFURLSessionManager。这句代码完成了如下工作：1，在AFURLSessionManager类中： 123456// 属性1，sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];2，operationQueue = [[NSOperationQueue alloc] init]; operationQueue.maxConcurrentOperationCount = 1;3，session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:operationQueue];4，securityPolicy = [AFSecurityPolicy defaultPolicy]; 2，在AFHTTPSessionManager类中： 123// 属性1，requestSerializer = [AFHTTPRequestSerializer serializer];2，responseSerializer = [AFJSONResponseSerializer serializer]; 第二步第二步调用POST方法POST方法功能： 1.获取NSURLRequest实例。2.获取NSURLSessionDataTask实例。3.开启任务。POST方法实现了网络请求的整个流程。 1234567891011121314151617181920212223242526272829303132333435363738- (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure&#123; // 1.获取NSURLRequest实例 NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; if (serializationError) &#123; if (failure) &#123; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123; failure(nil, serializationError); &#125;); &#125; return nil; &#125; // 2.获取NSURLSessionDataTask实例 __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123; if (error) &#123; if (failure) &#123; failure(task, error); &#125; &#125; else &#123; if (success) &#123; success(task, responseObject); &#125; &#125; &#125;]; // 3.开启任务 [task resume]; return task;&#125; NSURLRequest创建过程创建NSURLRequest实例的过程，主要与AFHTTPRequestSerializer、AFStreamingMultipartFormData、AFMultipartBodyStream、AFHTTPBodyPart类有关。 它们之间的关系如下如所示： 在AFHTTPRequestSerializer类中创建NSMutableURLRequest实例，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(![method isEqualToString:@&quot;GET&quot;] &amp;&amp; ![method isEqualToString:@&quot;HEAD&quot;]); // 1 根据url创建一个NSMutableURLRequest实例，并且配置了HTTPMethod NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error]; // 2 创建AFStreamingMultipartFormData实例，并把NSMutableURLRequest实例作为属性。 __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; // 3 把请求参数（非文件数据）传递给AFStreamingMultipartFormData实例。 if (parameters) &#123; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) &#123; data = pair.value; &#125; else if ([pair.value isEqual:[NSNull null]]) &#123; data = [NSData data]; &#125; else &#123; data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[pair.field description]]; &#125; &#125; &#125; // 4 把请求参数（文件数据）传递给AFStreamingMultipartFormData实例。 if (block) &#123; block(formData); &#125; // 5 此步骤之前，拼接表单所需要的全部数据都保存在了AFStreamingMultipartFormData实例中。 // 给NSMutableURLRequest实例配置HTTPBodyStream和HTTPHeaderField return [formData requestByFinalizingMultipartFormData];&#125; 第1步的作用是，根据url创建一个NSMutableURLRequest实例，并且配置了HTTPMethod。第2+3+4四步的作用是，把拼接表单所需要的全部数据都保存在AFStreamingMultipartFormData实例中，且把NSMutableURLRequest实例传递过去。第5步的作用是，给NSMutableURLRequest实例配置HTTPBodyStream和HTTPHeaderField。 在AFStreamingMultipartFormData类中，拼接表单的数据都以AFHTTPBodyPart实例形式保存在属性bodyStream的HTTPBodyParts数组中。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name&#123; NSParameterAssert(name); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@&quot;form-data; name=\\&quot;%@\\&quot;&quot;, name] forKey:@&quot;Content-Disposition&quot;]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;// 2- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body&#123; NSParameterAssert(body); AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; // AFMultipartBodyStream [self.bodyStream appendHTTPBodyPart:bodyPart];&#125;// 3- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;]; [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;]; return self.request;&#125; 根据方法1和2可知，表单数据保存在AFHTTPBodyPart实例中，AFHTTPBodyPart实例保存在属性bodyStream内部的数组中。根据方法3可知，给NSMutableURLRequest实例设置HTTPBodyStream和HTTPHeaderField的值。 AFMultipartBodyStream是继承自NSInputStream类，重写内部方法read:maxLength:实现表单拼接。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)open &#123; if (self.streamStatus == NSStreamStatusOpen) &#123; return; &#125; self.streamStatus = NSStreamStatusOpen; [self setInitialAndFinalBoundaries]; // 把AFHTTPBodyPart数组，转换成枚举 self.HTTPBodyPartEnumerator = [self.HTTPBodyParts objectEnumerator];&#125;- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; if ([self streamStatus] == NSStreamStatusClosed) &#123; return 0; &#125; NSInteger totalNumberOfBytesRead = 0; while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123; if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123; if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) &#123; break; &#125; &#125; else &#123; NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead; // 调用AFHTTPBodyPart实例的read:maxLength:，拼接表单 NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; if (numberOfBytesRead == -1) &#123; self.streamError = self.currentHTTPBodyPart.inputStream.streamError; break; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if (self.delay &gt; 0.0f) &#123; [NSThread sleepForTimeInterval:self.delay]; &#125; &#125; &#125; &#125; return totalNumberOfBytesRead;&#125; 由代码可知，AFMultipartBodyStream中的read:maxLength:方法并不是真正做表单拼接的地方，真正的地方在AFHTTPBodyPart实例的read:maxLength:方法中。 在AFHTTPBodyPart类中，实现了真正的表单拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; NSInteger totalNumberOfBytesRead = 0; if (_phase == AFEncapsulationBoundaryPhase) &#123; NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFHeaderPhase) &#123; NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFBodyPhase) &#123; NSInteger numberOfBytesRead = 0; numberOfBytesRead = [self.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; if (numberOfBytesRead == -1) &#123; return -1; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123; [self transitionToNextPhase]; &#125; &#125; &#125; if (_phase == AFFinalBoundaryPhase) &#123; NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; return totalNumberOfBytesRead;&#125;// 2- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length)); [data getBytes:buffer range:range]; _phaseReadOffset += range.length; if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123; [self transitionToNextPhase]; &#125; return (NSInteger)range.length;&#125; 核心代码是方法2中的[data getBytes:buffer range:range]; NSURLSessionDataTask创建过程创建NSURLSessionDataTask实例的过程，主要与AFURLSessionManager类有关。 123456789101112131415- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; // self.session在初始化方法中已经创建好了。 uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;","categories":[],"tags":[]},{"title":"对象拷贝","slug":"object-copy","date":"2018-02-08T12:38:40.000Z","updated":"2020-11-09T10:01:03.517Z","comments":true,"path":"2018/02/08/object-copy/","link":"","permalink":"http://onzxgway.github.io/2018/02/08/object-copy/","excerpt":"","text":"NSObject类提供了两个用于拷贝的方法：- (id)copy 和- (id)mutableCopy，这两个方法都可以复制已有对象生成副本。 由于Objective-C中几乎所有的类都继承自NSObject，所以类中都有copy和mutableCopy两个方法，那么是否就意味着对象可以直接调用这两个方法进行拷贝了呢？ 定义一个AMPerson类继承自NSObject 进行测试，代码如下： 12AMPerson *p1 = [[AMPerson alloc] init];AMPerson *p2 = [p1 copy]; 运行程序，发生崩溃，并输出以下错误信息：-[AMPerson copyWithZone:]: unrecognized selector sent to instance 0x7bf5e880错误信息意思是：AMPerson类中找不到copyWithZone:方法。 把copy方法换成mutableCopy， 12AMPerson * p2 = [[AMPerson alloc] init];AMPerson *p2 = [p1 mutableCopy]; 运行之后，依然发生崩溃，并输出以下错误信息：-[AMPerson mutableCopyWithZone:]: unrecognized selector sent to instance 0x7a2415f0错误信息意思是：AMPerson类中找不到mutableCopyWithZone:方法。 由以上错误可知：拷贝操作表面是调用copy和mutableCopy方法，其实底层是调用对象自身的copyWithZone和mutableCopyWithZone方法来完成实际的复制工作。copy返回实际上就是copyWithZone:方法的返回值，mutableCopy与mutableCopyWithZone:方法也是同样的道理。 由该例就引出了下面的讨论内容了。就是对象具体要满足什么条件，才可以被复制。 自定义对象要想自定义对象可以复制，那么该类就必须 一，遵守NSCopying 或 NSMutableCopying协议。二，实现协议中copyWithZone或者mutableCopyWithZone方法。 所以为了让AMPerson类能够复制自身，我们需要让AMPerson遵守NSCopying协议，实现copyWithZone:方法。 1234567891011121314151617@interface AMPerson: NSObject &lt;NSCopying&gt;@property (copy,nonatomic)NSString *name;@end@implementation AMPerson- (id)copyWithZone:(NSZone *)zone &#123; AMPerson *p = [[[self class] allocWithZone:zone] init]; p.name = [self.name copy]; return p;&#125;@end 运行代码 1234AMPerson *p1 = [[AMPerson alloc] init];AMPerson *p2 = [p1 copy];NSLog(@&quot;p1 = %p,p2 = %p&quot;, p1, p2); log信息如下：p1 = 0x7969cc40,p2 = 0x7969c6e0结果表明：p1和p2是两个地址不同的对象，复制操作成功。 系统对象copy方法用于复制对象的副本，通常来说，copy方法总是返回对象的不可修改副本，即使对象本身是可修改的。例如，NSMutableString调用copy方法，将会返回不可修改的字符串对象。 mutableCopy方法用于复制对象的可变副本，通常来说，mutableCopy方法总是返回对象可修改的副本，即使被复制的对象本身是不可修改的。例如，程序调用NSString的mutableCopy方法，将会返回一个NSMutableString对象。 下图详细列出了常用的NSString、NSMutableString、NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等调用copy与mutableCopy方法后的结果。 深复制与浅复制对象拷贝有两种方式：浅拷贝和深拷贝。浅拷贝，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深拷贝是直接拷贝整个对象内容到另一块内存中。再简单些说：浅拷贝就是指针拷贝，深拷贝就是内容拷贝。 多层数组在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？ 如下所示 123456789AMPerson *p1 = [[AMPerson alloc] init];AMPerson *p2 = [[AMPerson alloc] init];AMPerson *p3 = [[AMPerson alloc] init];NSArray *ps = @[p1, p2, p3];NSArray *psCopy = [ps mutableCopy]; // 复制NSLog(@&quot;p = %p, pCopy = %p&quot;, ps, psCopy);NSLog(@&quot;p = %p, pCopy = %p&quot;, ps[0], psCopy[0]); log信息如下：p = 0x6000039f3ab0, pCopy = 0x6000039f3840p = 0x6000035ac9b0, pCopy = 0x6000035ac9b0 结果表明：数组复制只是单单对于数组对象本身而言是深复制，而数组的成员对象默认仍然是浅拷贝的。我们称之为单层深复制。 那么要想实现完全深复制该怎么办呢？ 尤其是当该对象包含大量的指针类型的实例变量时，如果某些实例变量里再次包含指针类型的实例变量，那么实现完全深复制会更加复杂。上面的深复制就是因为集合对象中可能会包含指针类型的实例变量，从而导致深复制不完全。 解决方法很简单，复制的代码换成NSArray *pCopy = [[NSMutableArray alloc] initWithArray:p copyItems:YES]即可。 如下所示 123456789AMPerson *p1 = [[AMPerson alloc] init];AMPerson *p2 = [[AMPerson alloc] init];AMPerson *p3 = [[AMPerson alloc] init];NSArray *ps = @[p1, p2, p3];NSArray *psCopy = [[NSMutableArray alloc] initWithArray:ps copyItems:YES];//复制NSLog(@&quot;p = %p, pCopy = %p&quot;, ps, psCopy);NSLog(@&quot;p = %p, pCopy = %p&quot;, ps[0], psCopy[0]); log信息如下：p = 0x600003dae190, pCopy = 0x600003dae3d0p = 0x6000031e42a0, pCopy = 0x6000031e42f0 结果表明这次的复制是 完全深复制。不仅仅复制了第一层的数组对象，也复制了数组内部的指针类型的实例变量。当然内部的实例变量要遵守NSCoping协议。 copy修饰属性上面介绍完了copy相关的知识点，那么趁热打铁了解一下为什么字符串的属性，要用copy修饰。 介绍之前，先回忆一下属性修饰符都有哪些： 123456789101112MRC：assign：基本数据类型（当出现循环引用时，也可用assign）retain：除Block和NSString外的其他对象copy：一般用于NSString和BlockARC：strong：默认weak：多用于ui和解决循环引用copy：用于NSString和Blockassign：非OC对象 NSString属于OC对象，我们先不使用Copy修饰，在ARC模式下，声明的属性默认是strong修饰，接下来就演示strong修饰NSString的效果。 先定义一个AMPerson类，如下： 123@interface AMPerson: NSObject@property (strong, nonatomic)NSString *name;@end 在控制器中的viewDidLoad方法中执行如下代码： 123456AMPerson *p = [[AMPerson alloc] init];NSMutableString *str = [NSMutableString string];[str appendString:@&quot;anmav&quot;];p.name = str;[str appendString:@&quot;yc&quot;];NSLog(@&quot;%@&quot;,p.name); 打印结果为：anmavyc 结果分析：如果使用strong修饰NSString类型属性，p.name 指向可变字符串对象的地址，当可变字符串内容发生变化时，p.name相对应的值也发生变化。 使用copy修饰后，将可变字符串拷贝一份，重新开辟内存空间，外部修改mutableString的值，不会对p.name造成影响。 刚刚使用了NSMutableString(可变字符串)，对mutableString执行copy操作，属于深拷贝，所以开辟了新的内存空间，如果使用的是NSString(不可变内存)，对NSString进行copy属于浅拷贝,不会开辟新的内存空间，是不是就不会出现这个问题了呢? 123456AMPerson *p = [[AMPerson alloc] init];NSString *str = [NSString string];str = @&quot;anmav&quot;;p.name = str;str = @&quot;yc&quot;;NSLog(@&quot;%@&quot;,p.name); 打印结果为：anmav 将之前的可变字符串变为不可变字符串，因为NSString不支持append添加操作，我这里的两次str赋值操作，其实是让str重新指向了一片内存空间，并不是修改了str原本内存中的值。 OC中对象即指针，实际上存储的是内存地址，p.name = str; 实际是将str存储的@”xiaoming”这块地址给了p.name，p.name还指向着@”xiaoming”)。 所以改变str的指向后，p.name的指向并没有改变,输出没有受到影响。 总结对于对象的深复制的概念没有必要那么纠结，只要我们理解了复制的本质，并且运用到我们的业务场景，选择我们想要的复制方式就可以。最主要的还是理解本质并且学会使用。","categories":[],"tags":[]},{"title":"iOS并发编程进阶","slug":"Multi-threading-2","date":"2018-01-16T13:00:50.000Z","updated":"2020-10-29T09:54:24.168Z","comments":true,"path":"2018/01/16/Multi-threading-2/","link":"","permalink":"http://onzxgway.github.io/2018/01/16/Multi-threading-2/","excerpt":"","text":"NSThread需求一：用NSThread实现三个线程任务A、B、C，它们结束之后，再执行D、E任务。思路：用KVO监听NSThread实例的isFinished属性。 1demo 需求二：把有三个参数的函数放在子线程执行。 1NSThread暂时实现不了。 NSOperation需求一：用NSOperation实现三个线程任务A、B、C，它们结束之后，再执行D、E任务。 方式一：先执行封装了A + B + C操作的NSBlockOperation，KVO监听属性finished=YES时，再执行封装了D + E操作的NSBlockOperation对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// NSBlockOperation- (void)demo &#123; // 任务 NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work A done.&quot;, [NSThread currentThread]); &#125;]; void(^task)(void) = ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work B done.&quot;, [NSThread currentThread]); &#125;; [blockOperation addExecutionBlock:task]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work C done.&quot;, [NSThread currentThread]); &#125;]; // 监听NSOperation状态 [blockOperation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil]; // 队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:blockOperation];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;finished&quot;] &amp;&amp; [change valueForKey:NSKeyValueChangeNewKey]) &#123; [self performMehtod]; &#125;&#125;- (void)performMehtod &#123; NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work D done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work E done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation start];&#125; log信息显示如下： 12345&lt;NSThread: 0x600001944240&gt;&#123;number = 3, name = (null)&#125; work A done.&lt;NSThread: 0x600001960100&gt;&#123;number = 8, name = (null)&#125; work B done.&lt;NSThread: 0x600001966180&gt;&#123;number = 9, name = (null)&#125; work C done.&lt;NSThread: 0x600001944240&gt;&#123;number = 3, name = (null)&#125; work D done.&lt;NSThread: 0x600001960100&gt;&#123;number = 8, name = (null)&#125; work E done. 方式二：使用操作依赖功能，依赖的底层实现就是基于KVO的。 1234567891011121314151617181920212223242526272829303132333435363738// NSBlockOperation- (void)demo &#123; // 任务 NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work A done.&quot;, [NSThread currentThread]); &#125;]; void(^task)(void) = ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work B done.&quot;, [NSThread currentThread]); &#125;; [blockOperation addExecutionBlock:task]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work C done.&quot;, [NSThread currentThread]); &#125;]; NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work D done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation1 addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work E done.&quot;, [NSThread currentThread]); &#125;]; // 通过操作依赖可以实现先后顺序 [blockOperation1 addDependency:blockOperation]; // 队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:blockOperation]; [queue addOperation:blockOperation1];&#125; log信息显示如下： 12345&lt;NSThread: 0x600000717640&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; work C done.&lt;NSThread: 0x600000760700&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125; work A done.&lt;NSThread: 0x600000776e80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125; work B done.&lt;NSThread: 0x600000776e80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125; work D done.&lt;NSThread: 0x600000717640&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; work E done. 需求二：把有三个参数的函数放在子线程执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// NSInvocationOperation@interface DemoViewController ()@property (nonatomic, strong) NSInvocation *invocation;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self demo];&#125;// NSInvocation + NSMethodSignature 功能：方法的对象化，包括相关的结构信息：返回值，调用者，方法名，参数- (void)demo &#123; // 方法签名 NSMethodSignature *signature = [self methodSignatureForSelector:@selector(name:age:sex:)]; // NSInvocation作用是把方法对象化 self.invocation = [NSInvocation invocationWithMethodSignature:signature]; /** &lt;NSInvocation: 0x604000471ac0&gt; return value: &#123;@&#125; 0x0 target: &#123;@&#125; 0x0 selector: &#123;:&#125; null argument 2: &#123;@&#125; 0x0 argument 3: &#123;@&#125; 0x0 argument 4: &#123;@&#125; 0x0 */ self.invocation.target = self; self.invocation.selector = @selector(name:age:sex:); // 和签名的seletor要对应起来 // 配置参数 NSString *name = @&quot;kobe&quot;; NSString *age = @&quot;40&quot;; NSString *sex = @&quot;man&quot;; [self.invocation setArgument:&amp;name atIndex:2]; [self.invocation setArgument:&amp;age atIndex:3]; [self.invocation setArgument:&amp;sex atIndex:4]; // [self.invocation invoke]; // 调用方法 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithInvocation:self.invocation]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operation]; [operation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;- (NSString *)name:(NSString *)name age:(NSString *)age sex:(NSString *)sex &#123; NSLog(@&quot;name: age: sex:%@&quot;, [NSThread currentThread]); return [NSString stringWithFormat:@&quot;%@-%@-%@&quot;, name, age, sex];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;finished&quot;] &amp;&amp; [change valueForKey:NSKeyValueChangeNewKey]) &#123; __unsafe_unretained NSString *returnValue; [self.invocation getReturnValue:&amp;returnValue]; NSLog(@&quot;returnValue:%@&quot;, returnValue); &#125;&#125;@end log信息显示如下： 12name: age: sex:&lt;NSThread: 0x600001b8cd00&gt;&#123;number = 6, name = (null)&#125;returnValue:kobe-40-man 自定义NSOperation12345#import &lt;Foundation/Foundation.h&gt;@interface NSCustomOperation : NSOperation@end 12345678910111213141516171819202122232425262728293031323334353637#import &quot;NSCustomOperation.h&quot;@implementation NSCustomOperation@synthesize finished = _finished;// 主要的业务逻辑放到main处理- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;---%@---&quot;, [NSThread currentThread]); &#125; &#125; _finished = YES;&#125;- (void)start &#123; // 异常处理 if (self.isFinished) &#123; return; &#125; if (self.isExecuting) &#123; return; &#125; [self main];&#125;// NSOperation对象销毁前，finished属性必须为YES，否则不销毁。// 如果 dealloc 没被执行，是因为 _finished = NO- (void)dealloc &#123; NSLog(@&quot;%s&quot;, __func__);&#125;@end 操作依赖可以使任务有序执行。操作依赖强大的是可以跨队列依赖。 123456789101112131415161718192021222324252627- (void)method3 &#123; // 实例化4个操作 NSBlockOperation *operationOne = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationTwo = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationThree = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;3- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationFour = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;4- %@&quot;,[NSThread currentThread]); &#125;]; // 给操作添加依赖 [operationTwo addDependency:operationOne]; [operationThree addDependency:operationTwo]; [operationFour addDependency:operationThree]; // [operationOne addDependency: operationFour]; // 一定不能出现循环依赖 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operationOne]; [[NSOperationQueue mainQueue] addOperation:operationTwo]; [queue addOperation:operationThree]; [queue addOperation:operationFour];&#125; log信息显示如下： 12341- &lt;NSThread: 0x600000931700&gt;&#123;number = 7, name = (null)&#125;2- &lt;NSThread: 0x600000900240&gt;&#123;number = 1, name = main&#125;3- &lt;NSThread: 0x600000948380&gt;&#123;number = 5, name = (null)&#125;4- &lt;NSThread: 0x600000948380&gt;&#123;number = 5, name = (null)&#125; 1-2-3-4，任务是有序执行的，而且操作依赖更强大的是可以跨队列设置，就算第2步的操作是添加在主队列中的，结果依然有效。 线程取消正在运行的线程不能被真正的取消，只是标识状态节点的作用。 GCDdispatch_group_t (队列组)在组内的任务都执行完毕后，再去执行其他操作。简言之，可以获取到多个并发线程全部执行结束的时间点，汇总结果。队列组内任务只支持异步执行。 方式一： 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.test&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.abc&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.abcd&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block1 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_block_t block2 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_block_t block3 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue1, block1); dispatch_group_async(group, queue2, block2); dispatch_group_async(group, queue3, block3); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600003fc40c0&gt;&#123;number = 7, name = (null)&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600003fe8040&gt;&#123;number = 9, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600003fccc40&gt;&#123;number = 10, name = (null)&#125;----执行最后的汇总任务---当前线程&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125; 方式二： 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); // 组内任务数加一 dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); // 组内任务数减一 &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125;__----执行第二个任务---当前线程&lt;NSThread: 0x600002f7cc00&gt;&#123;number = 8, name = (null)&#125;----执行第一个任务---当前线程&lt;NSThread: 0x600002f55540&gt;&#123;number = 3, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002f78800&gt;&#123;number = 9, name = (null)&#125;----执行最后的汇总任务---当前线程&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125; dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1。dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。当group中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。 和内存管理的引用计数类似，我们可以假设group也持有一个整形变量，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify 以上两种基本使用方式注意事项：添加到队列中的任务，必须是同步的，如果再开启新线程，group会失效。如果一定要开启新线程，就搭配信号量使用，如下方式： 方式三： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); // 组内任务数加一 dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); // 组内任务数减一 &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125;- (void) network &#123; NSString *urlstr = @&quot;https://www.xxx.com&quot;; NSURL *url = [NSURL URLWithString:urlstr]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; // 信号量：异步变同步。 dispatch_semaphore_t sema = dispatch_semaphore_create(0); NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSDictionary *infoDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;%@_%@&quot;,[NSThread currentThread], infoDict.class); dispatch_semaphore_signal(sema); &#125;]; [task resume]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125;__&lt;NSThread: 0x600003687b00&gt;&#123;number = 9, name = (null)&#125;___NSDictionaryI&lt;NSThread: 0x600003687b00&gt;&#123;number = 9, name = (null)&#125;___NSDictionaryI&lt;NSThread: 0x600003687a40&gt;&#123;number = 10, name = (null)&#125;___NSDictionaryI----执行最后的汇总任务---当前线程&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125; dispatch_semaphore_t(信号量)信号量，相当于NSOperationQueue中最大并发数的功能，用来控制线程的数量。示例一： 123456789101112131415161718192021222324252627282930313233// 信号量可以理解为最大并发数 具备异步变同步的功能- (void)demo &#123; // create的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 任务1 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 1&quot;); sleep(1); NSLog(@&quot;complete task 1&quot;); dispatch_semaphore_signal(semaphore); &#125;); // 任务2 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 2&quot;); sleep(1); NSLog(@&quot;complete task 2&quot;); dispatch_semaphore_signal(semaphore); &#125;); // 任务3 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 3&quot;); sleep(1); NSLog(@&quot;complete task 3&quot;); dispatch_semaphore_signal(semaphore); &#125;);&#125; log信息显示如下： 123456run task 1run task 2complete task 2complete task 1run task 3complete task 3 示例二： 1234567891011121314151617181920212223242526272829303132333435363738- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); // 创建信号量，参数：信号量的初值，如果小于0则会返回NULL dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----结束执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----结束执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----结束执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345678__BEGIN:&lt;NSThread: 0x600002d5c140&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002d5c140&gt;&#123;number = 1, name = main&#125;__----开始执行第二个任务---当前线程&lt;NSThread: 0x600002d18980&gt;&#123;number = 4, name = (null)&#125;----结束执行第二个任务---当前线程&lt;NSThread: 0x600002d18980&gt;&#123;number = 4, name = (null)&#125;----开始执行第一个任务---当前线程&lt;NSThread: 0x600002d01580&gt;&#123;number = 7, name = (null)&#125;----结束执行第一个任务---当前线程&lt;NSThread: 0x600002d01580&gt;&#123;number = 7, name = (null)&#125;----开始执行第三个任务---当前线程&lt;NSThread: 0x600002d62300&gt;&#123;number = 6, name = (null)&#125;----结束执行第三个任务---当前线程&lt;NSThread: 0x600002d62300&gt;&#123;number = 6, name = (null)&#125; dispatch_barrier_async(栅栏)dispatch_barrier_async 相当于一个分界线，分界线前面任务先执行，分界线里面的任务再执行，分界线后面的任务最后执行。（栅栏内部队列，可以看成串行的，依序执行） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.test.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;----执行第一个写入任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----执行第二个写入任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----等待前面的任务完成 一阶段---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----等待前面的任务完成 二阶段---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; // 第一个读取任务 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----执行第一个读取任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; // 第二个读取任务 [NSThread sleepForTimeInterval:3]; NSLog(@&quot;----执行第二个读取任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]); &#125; log信息显示如下： 12345678__BEGIN:&lt;NSThread: 0x600001ac0400&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600001ac0400&gt;&#123;number = 1, name = main&#125;__----执行第二个写入任务---当前线程&lt;NSThread: 0x600001aa6c40&gt;&#123;number = 7, name = (null)&#125;----执行第一个写入任务---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----等待前面的任务完成 一阶段---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----等待前面的任务完成 二阶段---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----执行第一个读取任务---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----执行第二个读取任务---当前线程&lt;NSThread: 0x600001aa6c40&gt;&#123;number = 7, name = (null)&#125; 【dispatch_barrier_async 与 dispatch_barrier_sync异同】 共同点： 等待在它前面插入队列的任务先执行完，等待他们自己的任务执行完再执行后面的任务不同点： 1、dispatch_barrier_sync将自己内部的任务插入到队列的之后，需要把该任务执行结束之后才会继续插入后面的任务。 2、dispatch_barrier_async将自己内部的任务插入到队列之后，不会去执行任务，它会继续把后面的任务插入到队列。 用途：在多个异步操作完成之后，统一的对非线程安全的对象进行更新操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@interface BarrierViewController () &#123; NSMutableArray *_safeAry; dispatch_queue_t _queue;&#125;@end@implementation BarrierViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _safeAry = [NSMutableArray array]; [_safeAry addObject:@&quot;0&quot;]; [_safeAry addObject:@&quot;1&quot;]; [_safeAry addObject:@&quot;2&quot;]; [_safeAry addObject:@&quot;3&quot;]; _queue = dispatch_queue_create(&quot;com.barrier1.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); [self demo];&#125;/** 多线程来操作可变数组mutableAry，肯定会出错，因为集合都是线程不安全的。 解决方案：使用dispatch_barrier_async。 只要涉及到写操作（要做保护） */- (void) demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.barrier2.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 20; i++) &#123; // 写 dispatch_async(queue, ^&#123; [self addObject:[NSString stringWithFormat:@&quot;%d&quot;, i + 4]]; &#125;); // 读 dispatch_async(queue, ^&#123; NSLog(@&quot;%d::%@&quot;, i, [self indexTo:i]); &#125;); &#125;&#125;// 写 保证只有一个在操作（避免了同时多个写操作导致的问题）- (void)addObject:(NSString *)object &#123; dispatch_barrier_async(_queue, ^&#123; if (object != nil) &#123; [_safeAry addObject:object]; &#125; &#125;);&#125;// 注意同步，因为业务关系，必须马上返回数据- (NSString *)indexTo:(NSInteger)index &#123; __block NSString *result = nil; dispatch_sync(_queue, ^&#123; if (index &lt; _safeAry.count) &#123; result = _safeAry[index]; &#125; &#125;); return result;&#125;@end dispatch_apply(重复)dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API，将任务按照指定的次数追加到队列中，并等待全部队列任务执行结束。 123456789101112131415- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); /** 同步队列组 @param 5 指定次数 @param queue 追加对象的Dispatch Queue @param count 带有参数的Block, count的作用是为了按执行的顺序区分各个Block */ dispatch_apply(5, queue, ^(size_t count) &#123; NSLog(@&quot;%zu&quot;, count); &#125;); NSLog(@&quot;Done!&quot;);&#125; log信息显示如下： 12345601234Done! 如果在for循环中使用 dispatch_async 需要管理好线程的数量，否则会发生线程爆炸或死锁。而dispatch_apply是由GCD管理并发的，可以避免上述情况发生。 123456789101112131415161718- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); // // 有问题的情况，可能会死锁// for (int i = 0; i &lt; 999 ; i++) &#123;// dispatch_async(queue, ^(size_t i)&#123;// NSLog(@&quot;wrong %zu&quot;, i);// &#125;);// &#125; // 正确方式 dispatch_apply(999, queue, ^(size_t i)&#123; NSLog(@&quot;correct %zu&quot;, i); &#125;); // 等待上述任务执行结束之后，当前线程才会继续往下执行。 NSLog(@&quot;Done!&quot;);&#125; dispatch_after(延后)123456789101112- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.timer.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@&quot;start:%@&quot;, [NSThread currentThread]); dispatch_after(1, queue, ^&#123; NSLog(@&quot;dispatch_after:%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;end&quot;); &#125;);&#125; log信息显示如下： 123start:&lt;NSThread: 0x6000020a1d80&gt;&#123;number = 7, name = (null)&#125;enddispatch_after:&lt;NSThread: 0x600002081380&gt;&#123;number = 8, name = (null)&#125; 注意：dispatch_after原理是，先把操作添加到队列，指定时间后再执行，而不是指定时间后才把操作添加到队列。 dispatch_once代码从程序启动就执行一次 12345static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; //要执行的代码块 //只会被执行一次&#125;); 实现机制：在静态区分配内存给onceToken变量，并且初始化为0(静态区变量为全局变量，且直到程序退出才会释放onceToken)，线程执行到这里时，判断onceToken的值为0，就去执行block，并且onceToken的值更改为-1，第二次再有线程来执行时，判断onceToken的值为-1，就不执行block。 苹果推荐单例的创建方式为： 12345678+ (instancetype)sharedSingleton &#123; static id instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; dispatch_queue_t激活使用DISPATCH_QUEUE_CONCURRENT_INACTIVE创建的队列，是未激活队列，在使用的时候，需要手动激活。 1234567- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.active.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT_INACTIVE); dispatch_async(queue, ^&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;); dispatch_activate(queue);&#125; log信息显示如下： 1&lt;NSThread: 0x600000178080&gt;&#123;number = 3, name = (null)&#125; dispatch_source用dispatch_source实现定时器。 123456789101112131415dispatch_source_t source;- (void)timeSource &#123; // 1 创建一个队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.source.serial&quot;, DISPATCH_QUEUE_SERIAL); // io source关联到队列 source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 配置soure的时间 dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 1, 1); // 配置source的处理事件 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;soure_event:==%@&quot;, [NSThread currentThread]); &#125;); // 开启定时器 dispatch_resume(source);&#125; dispatch_async_f12345678void testMethod() &#123; NSLog(@&quot;testMethod::--&gt;%@&quot;, [NSThread currentThread]);&#125;- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.f.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async_f(queue, nil, testMethod);&#125; log信息显示如下： 1testMethod::--&gt;&lt;NSThread: 0x600003c8fa00&gt;&#123;number = 3, name = (null)&#125; 僵死线程先执行如下代码 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; NSLog(@&quot;%s&quot;, __func__);&#125; log信息显示如下： 12startend 根据log信息可知，method_one函数没有被执行。原因：子线程执行完ThreadOne函数之后，任务就完成了，被回收了。不会再等待2秒钟之后去执行method_one函数了。解决方式：开启runloop，保活线程。如下所示 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; NSPort *port = [[NSPort alloc] init]; [[NSRunLoop currentRunLoop] addPort:port forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; NSLog(@&quot;%s&quot;, __func__);&#125; log信息显示如下： 12start-[ViewController method_one] 根据log信息可知，method_one函数被执行了。但是有个新问题产生了，程序始终没有执行到NSLog(@”end”)代码，造成了内存泄露。解决方式：在method_one函数中，关闭runloop。如下所示 1234567891011121314151617181920212223242526272829303132@interface ViewController () &#123; NSPort *_port;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; _port = [[NSPort alloc] init]; [[NSRunLoop currentRunLoop] addPort:_port forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; [[NSRunLoop currentRunLoop] removePort:_port forMode:NSDefaultRunLoopMode]; NSLog(@&quot;%s&quot;, __func__);&#125;@end log信息显示如下： 123start-[ViewController method_one]end 在A线程中开启定时器，必须在A线程中关闭，否则会造成内存泄露。 123456789101112131415161718192021222324252627282930313233343536@interface ViewController () &#123; NSTimer *_timer;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadTwo) toTarget:self withObject:nil];&#125;- (void)ThreadTwo &#123; NSLog(@&quot;start&quot;); _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(stopTimer) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)stopTimer &#123; NSLog(@&quot;stopTimer&quot;); static int count = 0; count++; if (count &gt; 5) &#123; [_timer invalidate]; &#125; &#125;@end log信息显示如下： 12345678startstopTimerstopTimerstopTimerstopTimerstopTimerstopTimerend","categories":[],"tags":[]},{"title":"使用CocoaPods做依赖管理","slug":"CocoaPods","date":"2017-12-09T10:04:21.000Z","updated":"2020-11-09T13:35:47.430Z","comments":true,"path":"2017/12/09/CocoaPods/","link":"","permalink":"http://onzxgway.github.io/2017/12/09/CocoaPods/","excerpt":"","text":"每种语言发展到一定阶段，都会出现相应的依赖管理工具，例如Java语言的Maven、Node.js的npm等。本篇介绍iOS项目的依赖管理工具CocoaPods。 CocoaPods简介随着iOS开发者的增多，业界也出现了为iOS程序提供依赖管理的工具，它的名字叫作CocoaPods。CocoaPods 项目的源码在 Github 上管理。该项目开始于2011年8月，经过多年发展，现在已经成为iOS开发事实上的依赖管理标准工具。 开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和 更新第三方开源库的时间。 在使用CocoaPods以前，我需要：1.把这些第三方开源库的源代码文件复制到项目中，或者设置成git的submodule。2.这些开源库通常需要依赖系统的一些framework，我需要手工地将这些framework 增加到项目依赖中。比如通常情况下，一个网络库就需要增加以下framework： CFNetwork、 SystemConfiguration、MobileCoreServices、CoreGraphics, zlib。3.对于某些开源库，我还需要设置-licucore或者-fno-objc-arc等编译参数。4.管理这些依赖包的更新。 这些“体力活”虽然简单，但毫无技术含量并且浪费时间。在使用CocoaPods之后，我只需要 将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。 CocoaPods的安装和使用CocoaPods的安装和使用，在网上可以找到很多教程，这里不做说明。 注意事项关于.gitignore当你执行pod install之后，除了Podfile外，CocoaPods还会生成一个名为Podfile.lock的文件，你不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock。在多人协作的时候，这样可以防止第三方库升级时造成大家各自的第三方库版本不一致。CocoaPods 的一篇官方文档也在 What is a Podfile.lock 一节中介绍了 Pod\u001ffile.lock 的作用，并且指出：This file should always be kept under version control。 使用私有的pods我们可以直接指定某一个依赖的podspec，这样就可以使用企业内部的私有库。该方案有利 于使企业内部的公共项目支持CocoaPods。如下是一个示例：pod ‘MyCommon’, :podspec =&gt; ‘https://xxx.com/common/myCommon.podspec&#39; 原理CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作就从主项目移到了Pods项目中。下面是一些技术细节：1.Pods项目最终会编译成一个名为IibPods.a的文件，主项目只需要依赖这个.a文件即可。2.对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。3.CocoaPods通过一个名为Pods.xcconfig的文件在编译时设置所有的依赖和参数。 参考资料：《iOS开发进阶》","categories":[],"tags":[]},{"title":"Block基础","slug":"Block基础","date":"2017-11-08T12:53:40.000Z","updated":"2020-10-13T10:29:30.974Z","comments":true,"path":"2017/11/08/Block基础/","link":"","permalink":"http://onzxgway.github.io/2017/11/08/Block%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是blockblock就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。 block内存分布三种类型block在Objective-C语言中，有三种类型的block。1，__NSGlobalBlock__ 保存在全局区，不会访问任何外部变量。2，__NSStackBlock__ 保存在栈中，当函数返回时会被销毁。3，__NSMallocBlock__ 保存在堆中，当引用计数为0时会被销毁。 在MRC模式下，运行如下代码，从log中可以证明存在三种类型的block。 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; // 一 void(^globalBlock)(void) = ^&#123; NSLog(@&quot;hello world!&quot;); &#125;; NSLog(@&quot;%s&quot;, object_getClassName(globalBlock)); // 二 NSInteger i = 10; void(^stackBlock)(void) = ^&#123; NSLog(@&quot;stackBlock %zd&quot;, i); &#125;; NSLog(@&quot;%s&quot;, object_getClassName(stackBlock)); // 三 void(^mallocBlock)(void) = [stackBlock copy]; NSLog(@&quot;%s&quot;, object_getClassName(mallocBlock)); &#125; log信息： 123__NSGlobalBlock____NSStackBlock____NSMallocBlock__ 对三种类型的block实例发送消息 如何判断block类型我们知道有三种类型block，那么如何判断一个block是属于哪种的呢？依据如下规则即可。 没有使用外部变量的（外部变量不包括全局变量和静态变量）block，在全局区，属于__NSGlobalBlock__。 12345678910111213141516171819202122232425262728293031323334// 在MRC模式下运行typedef void(^TestBlock)(void);int globalVal = 666;static int staticVal = 888;@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _strongBlock = ^&#123; NSLog(@&quot;hello world!&quot;); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, globalVal); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, staticVal); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); NSLog(@&quot;_weakBlock %s&quot;, object_getClassName(_weakBlock));&#125;@end log信息显示如下： 123_strongBlock __NSGlobalBlock___copyBlock __NSGlobalBlock___weakBlock __NSGlobalBlock__ 使用外部变量的（外部变量不包括全局变量和静态变量）block，在栈区，属于__ NSStackBlock__。 123456789101112131415161718192021222324252627282930313233// 在MRC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int tempV = 100; _strongBlock = ^&#123; NSLog(@&quot;_strongBlock %d&quot;, tempV); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, tempV); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, tempV); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); NSLog(@&quot;_weakBlock %s&quot;, object_getClassName(_weakBlock));&#125;@end log信息显示如下： 123_strongBlock __NSStackBlock___copyBlock __NSStackBlock___weakBlock __NSStackBlock__ 对栈区block进行copy之后，得到新的block，在堆区，属于__ NSMallocBlock__。 123456789101112131415161718192021222324252627282930313233// 在MRC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int tempV = 100; _strongBlock = ^&#123; NSLog(@&quot;_strongBlock %d&quot;, tempV); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, tempV); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, tempV); &#125;; NSLog(@&quot;_strongBlock copy %s&quot;, object_getClassName([_strongBlock copy])); NSLog(@&quot;_copyBlock copy %s&quot;, object_getClassName([_copyBlock copy])); NSLog(@&quot;_weakBlock copy %s&quot;, object_getClassName([_weakBlock copy]));&#125;@end log信息显示如下： 123_strongBlock copy __NSMallocBlock___copyBlock copy __NSMallocBlock___weakBlock copy __NSMallocBlock__ ARC对block的影响ARC会自动把strong类型且捕获外部变量的block从栈copy到堆中。 1234567891011121314151617181920212223242526272829303132333435// 在ARC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger i = 10; // _strongBlock = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); // _copyBlock = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); // void(^_localBlock)(void) = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_localBlock %s&quot;, object_getClassName(_localBlock)); &#125;@end log信息显示如下： 123_strongBlock __NSMallocBlock___copyBlock __NSMallocBlock___localBlock __NSMallocBlock__ 根据log信息可以判断strong、copy修饰的或者局部变量引用的block实例，都属于__NSMallocBlock__。 原因：_strongBlock、_copyBlock和_localBlock都使用了外部变量，属于栈区block，但是在ARC模式下，被strong或copy等非weak修饰符修饰的栈区block，会自动copy到堆区，变成__NSMallocBlock__。（block实例赋值给局部变量_localBlock，就相当于被变量强引用=strong，所以_localBlock是__NSMallocBlock__） 变量的复制对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的，如果对象是引用类型，则block会将其引用计数加一 ，如下图所示：对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的，如下图所示：","categories":[],"tags":[]},{"title":"内存管理（下）","slug":"memory-management-2","date":"2017-09-18T10:32:14.000Z","updated":"2020-10-18T09:00:11.614Z","comments":true,"path":"2017/09/18/memory-management-2/","link":"","permalink":"http://onzxgway.github.io/2017/09/18/memory-management-2/","excerpt":"","text":"在开始之前先思考一个问题，就是为什么需要内存管理？iOS系统会在程序退出以后，回收其所有内存，那么开发者还有必要在程序运行过程中去管理内存吗？答案是肯定的，1，程序运行的过程中，如果不去管理内存，可能会发生内存泄露，而内存泄露会导致程序运行出错甚至直接崩溃闪退。虽然有些情况下的内存泄露，并不会导致上述状况，2，严格的内存管理可以让应用更加合理、高效的使用有限的硬件条件，提高应用程序的性能。 内存泄露什么是内存泄露内存泄露指一个对象或者变量在使用完成后没有及时释放掉，一直占用着内存，直到应用停止。 哪些情况下会发生内存泄露iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。所以如果发生了内存泄露，肯定与引用计数有关。1，引用计数的天生缺陷是循环引用，以下是项目中常见的循环引用： delegate：xxxx block：xxxx controller+view：xxxx NSTimer：xxxx 2，错误使用手动引用计数 底层Core Foundation对象，需要手动去管理，如果创建使用完成后，没有调用CFRelease方法去释放的话，也会造成内存泄露。3，大次数循环内存暴涨 123 while (true) &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init];&#125; 该循环内产生大量的临时对象，直到循环结束才释放，可能导致内存泄露，解决方法是把循环体放到自动释放池中，及时释放占用内存大的临时变量。 123456 while (true) &#123; @autoreleasepool &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init]; &#125;&#125;4，项目中的第三方导致的内存泄露。 到github上查看三方的Issues，看是否有相关的问答。或者通过网络、书籍、前辈查询相关解决方案。 5，子线程中使用延时操作或者使用定时器不当，也会造成内存泄露。具体请看并发编程进阶中说明。 如何检测内存泄露Xcode集成功能Analyze静态分析在程序没运行的时候，通过工具对代码直接进行分析，根据代码的上下文的语法结构，让编译器分析内存情况, 检查是否有内存泄露。 主要分析以下四种问题：1，逻辑错误：访问空指针或未初始化的变量等；2，内存管理错误：如内存泄漏等；3，声明错误：从未使用过的变量；4，Api调用错误：未包含使用的库和框架。缺点：静态内存分析由于是编译器根据代码进行的判断，做出的判断不一定会准确，因此如果遇到提示, 应该去结合代码上文检查一下。 在Xcode的菜单栏选择Product -&gt; Analyze启动静态分析。逻辑错误：The ‘viewDidLoad’ instance method in UIViewController subclass ‘ViewController’ is missing a [super viewDidLoad] call解决办法：添加[super viewDidLoad];内存管理错误：内存泄漏（Object leaked: object allocated and stored into ‘cfStr’ is not referenced later in this execution path and has a retain count of +1）声明错误：从未使用过的变量(Value stored to ‘xxx’ during its initialization is never read)。如下图所示解决办法：把未使用的变量删除 Instruments中的Leaks动态分析Xcode自带Instruments工具集可以很方便的检测内存泄露，为了测试效果，在一个测试使用的ViewController中填写如下代码，该代码中first和second互相强引用了对方，构成了循环引用造成内存泄露。 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *first = [NSMutableArray array]; NSMutableArray *second = [NSMutableArray array]; [first addObject:second]; [second addObject:first];&#125; 在Xcode的菜单栏选择Product -&gt; Profile进入Instruments工具集，然后选择leaks，再单击右下角的Choose按钮开始检测。进入检测页面，如下图所示选择好了检测设备和检测项目，点击开始检测按钮，这时候iOS应用会运行起来，由于Leaks是动态监测，所以需要一边操作APP，一边观察Leaks的变化，稍等几秒钟，就可以看到Instruments检测到了我们这次内存泄露，点击暂停检测(也可继续检测)，Instruments会用一个红色的叉叉来表示一次内存泄露的产生，如下图所示。暂停检测之后，点击红色叉（内存泄漏点），Leaks-&gt;选择Call Tree，如下图所示。点击页面底部栏的Call Tree(此处指的是Xcode8以上, Xcode7在右下角)，选择Invert Call Tree和Hide System Libraries，如下图所示。此时界面显示是就是内存泄漏的代码部分，双击代码行，或者右键选择reveal in Xcode即可定位到内存泄漏的代码行。我们也可以切换到Leaks这栏，单击Cycles&amp;Roots，就可以以图的形式显示出来循环引用。这样就可以很方便的找到循环引用对象了。定位到具体错误代码处，剩下的工作就需要开发者自己去完成了。 第三方工具MLeaksFinder点击查看具体原理，这里我只讨论它的优点： 使用简单，不侵入业务逻辑代码，不用打开 Instruments 不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测 内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了） 精准，能准确地告诉你哪个对象没被释放 FBRetainCycleDetector能够检测指定对象的引用情况，并把所存在的引用循环中各对象和引用在终端进行打印。 Facebook开源的循环引用检测工具 FBRetainCycleDetector。当传入内存中的任意一个OC对象，FBRetainCycleDetector会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。我们知道，很多循环引用是 block 的使用不当造成的。而 FBRetainCycleDetector 最大的技术亮点，正在于如何找出一个 block 的所有强引用对象。 然而，FBRetainCycleDetector 的使用存在两个问题：1，需要找到候选的检测对象。2，检测循环引用比较耗时。 正是由于这两个问题，FBRetainCycleDetector 通常是结合其它工具一起使用，通过其它工具先找出候选的检测对象，然后进行有选择的检测。当 MLeaksFinder 与 FBRetainCycleDetector 结合使用时，正好能达到很好的效果。我们先通过 MLeaksFinder 找到内存泄漏的对象，然后再过FBRetainCycleDetector检测该对象有没有循环引用即可。 内存警告这篇文章对内存警告介绍比较详细，可以仔细阅读。","categories":[],"tags":[]},{"title":"内存管理（上）","slug":"memory-management-1","date":"2017-08-27T07:34:47.000Z","updated":"2020-10-06T16:05:40.380Z","comments":true,"path":"2017/08/27/memory-management-1/","link":"","permalink":"http://onzxgway.github.io/2017/08/27/memory-management-1/","excerpt":"","text":"关于iOS开发中内存管理的知识脉络，我依据自己的思路整理了一下，根据管理的是哪个区域的内存-&gt;管理的方式-&gt;内存泄露-&gt;内存警告线索来展开。具体的每个步骤里面会有更多的关联知识点，但是能力有限，写作匆忙，有瑕疵错误的地方，多多包涵。 内存分区内存区域划分程序如果想要执行，第一步就需要从磁盘加载到内存中。运行过程中内存的分区是怎样的呢，如下图所示。1，栈区（stack）由编译器自动分配并释放的变量存储区。存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］2，堆区（heap）由程序员申请和释放，如果程序员不释放，程序结束时，会由OS回收，比如在iOS中alloc都是存放在堆中。优点是灵活方便，数据适应面广泛，但是效率有一定降低。3，BSS区 全局变量和静态变量的存储是放在一起的，存放未初始化的全局变量和静态变量的区域，程序结束后有系统释放。4，数据区 存放初始化的全局变量和静态变量的区域，程序结束后由系统释放。5，代码区 存放函数的二进制代码，程序结束后由系统释放。 堆和栈的区别 管理方式：堆空间的申请释放工作由程序员控制，容易产生内存泄漏。而栈是由编译器自动管理，无需我们手工控制。 空间大小：堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址，堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。 内存碎片：对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出。 分配方式：堆都是动态分配的。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈由系统自动分配，速度较快，不会产生内存碎片。但程序员是无法控制的。堆是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便。 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 由以上的内存分区知识点可知，堆区内存是由程序员管理，其他区域全部是由编译器自动管理。所以iOS开发过程中管理的是堆区内存。 引用计数iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。本段博文就是讲解引用计数的原理及特点。 Objective-C和Swift语言内存管理的方式是引用计数，Java和C#语言的内存管理方式是GC垃圾回收机制(Garbage Collection) 什么是引用计数、引用计数原理引用计数（Reference Count）是一种简单有效的管理对象生命周期的方式。它的原理是：当我们创建一个新对象的时候，它的引用计数为1，当有一个新的指针指向该对象时，我们把其引用计数加1，当某个指针不再指向该对象时，我们将其引用计数减1，当对象的引用计数为0的时候，说明不再被任何指针引用了，我们可以将对象销毁，回收内存。 引用计数的分类1，手动引用计数手动引用计数（Manual Reference Count，简称MRC），在此模式下，对象的生命周期需要开发者手动调用retain,release等方法去管理。运行以下代码，可以通过log看到引用计数的变化。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; &#x2F;&#x2F; Override point for customization after application launch. NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); NSObject *antherObj &#x3D; [obj retain]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [antherObj release]; antherObj &#x3D; nil; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [obj release]; &#x2F;&#x2F; 到这里时，obj的内存被释放 return YES;&#125; 运行结果如下： Reference Count = 1 Reference Count = 2 Reference Count = 1 上述代码中NSObject实例的retainCount属性、retain和release方法只在MRC的模式下才能够调用。现在新建的工程默认都是ARC模式，允许以文件为单位关闭ARC模式，开启MRC模式。具体方法就是通过编译列表找到目标文件，在文件后面加上-fno-objc-arc的编译参数即可。 2，自动引用计数自动引用计数（Automatic Reference Count，简称ARC），是苹果在WWDC 2011大会上提出的用于管理内存的技术。在此模式下，编译器会自动添加内存管理的方法，让开发者从繁琐的内存管理中解放出来。 过度依赖ARC问题1.ARC技术能够解决iOS开发中90%的内存管理问题，但是另外10%是需要开发者自己处理的。这主要与底层Core Foundation对象交互的那部分，因为Core Foundation对象不在ARC的管理范畴，所以需要开发者去维护这些对象的引用计数。2.没有正确使用Block导致的循环引用的问题。如果过度依赖ARC，不了解引用计数原理，那面对以上两种情况，会显得一筹莫展。 3，Core Foundation对象内存管理底层Core Foundation对象，大多数以XxxCreateWithXxx形式创建。例如 1234&#x2F;&#x2F; 创建一个CFStringRef对象CFStringRef cfStr &#x3D; CFStringCreateWithCString(kCFAllocatorDefault, &quot;Hello World&quot;, kCFStringEncodingUTF8);&#x2F;&#x2F; 创建一个CFStringRef对象CTFontRef font &#x3D; CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, 16.0, NULL); 对于这些对象引用计数的修改，要相应的使用CFRetain和CFRelease方法。 12345&#x2F;&#x2F; 引用计数加1CFStringRef newStr &#x3D; CFRetain(cfStr); &#x2F;&#x2F; 引用计数减1CFRelease(newStr); CFRetain和CFRelease方法，我们直观的认为，它们与Objective-C中的retain和release方法等价。除此之外，还有另外一个问题需要解决。在ARC下，有时候需要将一个Core Foundation对象转换成一个Objective-C对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整。这就引入了与bridge相关的关键字，以下是这些关键字的说明： __bridge 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_retained 类型转换后，将相关对象的引用计数加1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_transfer 类型转换后，将该对象的引用计数交给ARC管理，原来的Core Foundation对象在不用时，不需要调用CFRelease方法。 根据具体业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objective-C对象相对转换的问题了。 引用计数的优点简单有效。 为什么需要引用计数？在没有引用计数的情况下，一般内存管理的原则是“谁申请谁释放”，假如对象A生成了一个对象M，需要调用对象B，将对象M作为参数传递过去。那么对象A就需要在对象B不再需要对象M的时候，将对象M销毁。但是对象B可能只是临时用一下对象M，也可能觉得对象M很重要，将它设置成自己的一个成员变量，在这种情况下，什么时候销毁对象M就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象A在调用完对象B之后，马上就销毁参数对象M，然后对象B需要将参数另外复制一份，生成另一个对象M2，然后自己管理对象M2的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。 还有另外一种方法，就是对象A在构造完对象M之后，始终不销毁对象M，由对象B来完成对象M的销毁工作。如果对象B需要长时间使用对象M，就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好的解决了对象复制的问题，但是它强烈依赖于A、B两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象M的申请是在对象A中，释放在对象B中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象B需要向对象C传递对象M，那么这个对象在对象C中又不能让对象C管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好地解决了这个问题，在参数M的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完了之后再把引用计数减1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便的享受到共享对象带来的好处。 引用计数的缺点引用计数这种管理内存的方式虽然简单有效，但是有一个比较大的瑕疵，就是它不能很好的解决循环引用的问题。如下图所示对象A和对象B，相互引用对方作为自己的成员变量，只有自己销毁时，才会将成员变量的引用计数减1。因为对象A的销毁依赖于对象B的销毁，而对象B的销毁又依赖于对象A的销毁，这样就造成了循环应用（reference cycle）的问题。实际项目中不止两个对象存在循环引用问题，多个对象间依次持有，形成一个环状，也会造成循环引用，而且环状越大越难发现。 解决方式：1.明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用。2.弱应用的办法。弱引用虽然持有对象，但是并不增加引用计数。","categories":[],"tags":[]},{"title":"断点下载与文件上传","slug":"network-1","date":"2017-06-20T10:56:59.000Z","updated":"2020-10-26T11:51:03.754Z","comments":true,"path":"2017/06/20/network-1/","link":"","permalink":"http://onzxgway.github.io/2017/06/20/network-1/","excerpt":"","text":"本篇博文的所有网络操作的对象都是一张图片。 普通下载使用NSURLSessionDownloadTask实现。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@interface DownloadController ()&lt;NSURLSessionDownloadDelegate&gt;@endstatic NSString *const ImageURL = @&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603118011167&amp;di=fd9df24b9d887970aed9a6ec147d40da&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.pconline.com.cn%2Fimages%2Fupload%2Fupc%2Ftx%2Fwallpaper%2F1209%2F05%2Fc0%2F13630426_1346827472062.jpg&quot;;@implementation DownloadController &#123; NSString *_fullPath;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *fileName = @&quot;smile.png&quot;; // 文件名称 通常需要通过md5生成一个唯一文件名 NSString *docuPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; _fullPath = [docuPath stringByAppendingPathComponent:fileName];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self loadImage];&#125;- (void)loadImage &#123; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:ImageURL]]; request.HTTPMethod = @&quot;GET&quot;; // ephemeralSessionConfiguration 不带缓存 defaultSessionConfiguration带缓存 NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; // NSURLSessionDownloadTask把数据直接下载到沙盒下tmp目录中 NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request]; [task resume];&#125;#pragma mark - NSURLSessionDelegate//1 响应头 这次网络数据的属性（下载的总数据大小 content-Length, Content-Type）// 响应的过滤- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123; completionHandler(NSURLSessionResponseAllow);&#125;// 下载过程 下载的进度 接收数据回掉// 下载的数据自动写入沙盒下tmp目录中，未下载完的文件会一直保存，下载完成的话，会自动从目录中移除。- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; // bytesWritten 当前包收到的数据 totalBytesWritten已经接受的数据 totalBytesExpectedToWrite总数据大小 NSLog(@&quot;当前包收到的数据:%lld&quot;, bytesWritten); NSLog(@&quot;已经接收到的总数据:%lld&quot;, totalBytesWritten); NSLog(@&quot;需接收的总数据:%lld&quot;, totalBytesExpectedToWrite);&#125;// 文件下载完成// @param location 文件下载到沙盒下tmp目录中，系统会自动清理- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location &#123; NSError *error = nil; [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:_fullPath] error:&amp;error];&#125;// 网络任务结束- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; &#125; 运行代码之后，在沙盒的Document目录中会有smile.png的图片，表示下载成功了。 注意： NSURLSessionDownloadTask下载的数据自动写入沙盒下tmp目录中，未下载完的文件会一直保存，下载完成的话，会自动移除。所以一定要在下载完成时刻把文件移动到目标路径下，否则文件就被移除了。 断点下载断点下载的流程如下图 断点下载原理：在网络请求之前，先获取本地已下载数据的size，配置请求头Range。如下代码所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@interface BreakDownloadController ()&lt;NSURLSessionTaskDelegate&gt;@endstatic NSString *const ImageURL = @&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603118011167&amp;di=fd9df24b9d887970aed9a6ec147d40da&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.pconline.com.cn%2Fimages%2Fupload%2Fupc%2Ftx%2Fwallpaper%2F1209%2F05%2Fc0%2F13630426_1346827472062.jpg&quot;;@implementation BreakDownloadController &#123; NSString *_filePathDocument; NSOutputStream *_outputStream;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *fileName = @&quot;smile&quot;; NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; _filePathDocument = [filePath stringByAppendingPathComponent:fileName]; _outputStream = [[NSOutputStream alloc] initToFileAtPath:_filePathDocument append:YES];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self loadImage];&#125;- (void)loadImage &#123; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:ImageURL]]; request.HTTPMethod = @&quot;GET&quot;; NSDictionary *fileInfo = [[NSFileManager defaultManager] attributesOfItemAtPath:_filePathDocument error:nil]; long filesize = [[fileInfo objectForKey:NSFileSize] longValue]; [request setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, filesize] forHTTPHeaderField:@&quot;Range&quot;]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request]; [task resume];&#125;#pragma mark - NSURLSessionDelegate// 响应的过滤- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; [_outputStream open]; completionHandler(NSURLSessionResponseAllow);&#125;// 数据接收- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; [_outputStream write:[data bytes] maxLength:data.length];&#125;// 完成- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(nullable NSError *)error &#123; [_outputStream close];&#125;@end 注意一： NSURLSessionDataTask下载的数据是在内存中的。需要通过NSOutputStream写入沙盒。（不要NSData直接写入沙盒，性能较差）注意二： 使用NSFileManager获取沙盒文件的size。 文件上传文件上传的核心是表单的拼接，如下是表单的示例 12345678910111213--Boundary+AA1C6D73B71C103FContent-Disposition: form-data; name=&quot;paramKey1&quot; paramValue1--Boundary+AA1C6D73B71C103FContent-Disposition: form-data; name=&quot;paramKey2&quot; paramValue2--Boundary+AA1C6D73B71C103FContent-Disposition: form-data; name=&quot;image&quot;; filename=&quot;customName&quot;Content-Type: image/png PNG;��^3��\u000f��)or�\u001a!�.\u0003s\u0007t�n��x(+9&#x27;���... 表单由四部分组成： 1，开始和结束边界，如–Boundary+28FBA24634750C95– 2，请求参数，如Content-Disposition: form-data;name=”paramKey1” paramValue1 3，上传文件的属性，如Content-Type: image/png 4，上传文件的数据，如PNG;��^3��\u000f��)or�\u001a!�.\u0003s\u0007t�n��x(+9’��� 二进制形式的表单就是请求体。 使用NSMutableURLRequest.HTTPBody属性设置请求体，如下代码所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 文件上传- (void)uploadImage &#123; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:UploadImageURL]]; // 表单拼接 NSString *bounary = @&quot;******&quot;; // 分界线 // 一 配置请求头 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data;charset=utf-8;boundary=%@&quot;, bounary] forHTTPHeaderField:@&quot;Content-Type&quot;]; // 二 配置请求体 NSMutableData *bodyData = [NSMutableData data]; // 1，开始边界 NSString *beginBoundary = [NSString stringWithFormat:@&quot;--%@\\r\\n&quot;, bounary]; [bodyData appendData:[beginBoundary dataUsingEncoding:NSUTF8StringEncoding]]; // 2，属性 name和服务的name要匹配,相当于服务获取图片的key // filename 服务器图片文件命名 NSString *serverFileKey = @&quot;image&quot;; NSString *serverFileName = @&quot;101.png&quot;; NSString *serverContentTypes = @&quot;image/png&quot;; NSMutableString *string = [NSMutableString string]; [string appendFormat:@&quot;Content-Disposition:form-data; name=\\&quot;%@\\&quot;; filename=\\&quot;%@\\&quot; \\r\\n&quot;, serverFileKey, serverFileName]; [string appendFormat:@&quot;Content-Type: %@\\r\\n&quot;, serverContentTypes]; [string appendFormat:@&quot;\\r\\n&quot;]; [bodyData appendData:[string dataUsingEncoding:NSUTF8StringEncoding]]; // 3，上传文件数据 UIImage *image = [UIImage imageNamed:@&quot;demo.png&quot;]; NSData *imageData = UIImagePNGRepresentation(image); [bodyData appendData:imageData]; // 4，结束边界 NSString *endBoundary = [NSString stringWithFormat:@&quot;\\r\\n--%@&quot;, bounary]; [bodyData appendData:[endBoundary dataUsingEncoding:NSUTF8StringEncoding]]; request.HTTPBody = bodyData; request.HTTPMethod = @&quot;POST&quot;; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request]; [task resume];&#125;// 进度- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; NSLog(@&quot;didSendBodyData:: %lld--%lld--%lld&quot;, bytesSent, totalBytesSent, totalBytesExpectedToSend);&#125;// 完成- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;上传完成&quot;);&#125; 表单注意点：一，每个部分都是以\\n为结束点。二，属性中的name和服务的name要匹配。 使用NSMutableURLRequest.HTTPBodyStream属性设置请求体，如下代码所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@interface InputStreamUploadController ()&lt;NSURLSessionDelegate&gt;@end#define UploadImageURL @&quot;http://www.8pmedu.com/themes/jianmo/img/upload.php&quot;@implementation InputStreamUploadController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = UIColorRandomColor; [self inputStream];&#125;- (void)inputStream &#123; NSString *bodyStr = @&quot;versions_id=1&amp;system_type=1&quot;; NSInputStream *inputsteam = [[NSInputStream alloc] initWithData:[bodyStr dataUsingEncoding:NSUTF8StringEncoding]]; [inputsteam open]; uint8_t buffer[256]; memset(buffer, 0, 256);// 清空该段内存 [inputsteam read:buffer maxLength:9]; NSLog(@&quot;++++%s&quot;, buffer); memset(buffer, 0, 256);// 清空该段内存 [inputsteam read:buffer maxLength:3]; NSLog(@&quot;----%s&quot;, buffer); [inputsteam close];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self uploadImage];&#125;- (void)uploadImage &#123; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:UploadImageURL]]; // 配置请求头和请求体 NSString *bounary = @&quot;******&quot;; // 分界线 // 一 配置请求头 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data;charset=utf-8;boundary=%@&quot;, bounary] forHTTPHeaderField:@&quot;Content-Type&quot;]; // 二 配置请求体 NSMutableData *bodyData = [NSMutableData data]; // 1 开始边界 NSString *beginBoundary = [NSString stringWithFormat:@&quot;--%@\\r\\n&quot;, bounary]; [bodyData appendData:[beginBoundary dataUsingEncoding:NSUTF8StringEncoding]]; // 2 属性 name和服务的name要匹配，相当于获取服务图片的key // filename 服务器图片文件命名 NSString *serverFileKey = @&quot;image&quot;; NSString *serverFileName = @&quot;101.png&quot;; NSString *serverContentTypes = @&quot;image/png&quot;; NSMutableString *string = [NSMutableString string]; [string appendFormat:@&quot;Content-Disposition:form-data; name=\\&quot;%@\\&quot;; filename=\\&quot;%@\\&quot; \\r\\n&quot;, serverFileKey, serverFileName]; [string appendFormat:@&quot;Content-Type: %@\\r\\n&quot;, serverContentTypes]; [string appendFormat:@&quot;\\r\\n&quot;]; [bodyData appendData:[string dataUsingEncoding:NSUTF8StringEncoding]]; // 3 文件数据 UIImage *image = [UIImage imageNamed:@&quot;1&quot;]; NSData *imageData = UIImagePNGRepresentation(image); [bodyData appendData:imageData]; // 4 结束边界 NSString *endBoundary = [NSString stringWithFormat:@&quot;\\r\\n--%@&quot;, bounary]; [bodyData appendData:[endBoundary dataUsingEncoding:NSUTF8StringEncoding]]; NSInputStream *inputsteam = [[NSInputStream alloc] initWithData:bodyData]; [request setHTTPBodyStream:inputsteam]; // 请求的时候，系统底层会对NSInputStream执行read操作 NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionTask *task = [session dataTaskWithRequest:request]; [task resume];&#125;#pragma mark - NSURLSessionDelegate// 进度- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; NSLog(@&quot;didSendBodyData:: %lld--%lld--%lld&quot;, bytesSent, totalBytesSent, totalBytesExpectedToSend);&#125;// 完成- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; NSLog(@&quot;over %@&quot;, error);&#125;@end ** 文件上传的NSURLRequest实例，需要配置如下属性：**1，URL2，HTTPMethod3，setValue:forHTTPHeaderField:4，HTTPBody/HTTPBodyStream","categories":[],"tags":[]},{"title":"时间与日期（下）","slug":"Time-And-Date2","date":"2017-04-08T11:30:11.000Z","updated":"2020-11-08T12:35:00.034Z","comments":true,"path":"2017/04/08/Time-And-Date2/","link":"","permalink":"http://onzxgway.github.io/2017/04/08/Time-And-Date2/","excerpt":"","text":"NSDateComponentsNSDateComponents类的作用是把日期拆分成一个一个的组件。一个日期是由年月日时分秒组成的，该类可以把日期拆分成单独的年、月、日、时、分、秒。通常是和NSCalendar类一起使用。 初始化方法 - (instancetype)init 默认的初始化方法 123456789101112131415// 创建NSDateComponents对象，设置时间点NSDateComponents *components = [[NSDateComponents alloc] init];[components setEra:1]; // 时代[components setYear:2017];[components setMonth:3];[components setDay:25];[components setHour:11];[components setMinute:20];[components setSecond:55];[components setQuarter:2]; // 季度[components setWeekday:1]; // 星期 Sunday:1, Monday:2, Tuesday:3, Wednesday:4, Friday:5, Saturday:6[components setWeekOfMonth:3]; // 当月的第几个星期[components setWeekOfYear:2]; // 当年的第几个星期[components setTimeZone:[NSTimeZone systemTimeZone]];[components setCalendar:[NSCalendar currentCalendar]]; 用法一获取一个绝对的时间点对象 12345678NSDateComponents *dateComponents = [[NSDateComponents alloc] init];[dateComponents setDay:6];[dateComponents setMonth:5];[dateComponents setYear:2017];NSCalendar *calendar = [NSCalendar currentCalendar];NSDate *date = [calendar dateFromComponents:dateComponents];NSLog(@&quot;%@&quot;, date); log信息如下：2017-05-06 00:00:00 +0000 用法二在date基础上，增加一个NSDateComponents类型的时间增量 1234567NSDateComponents *dateComponents = [[NSDateComponents alloc] init];[dateComponents setDay:3];NSCalendar *calendar = [NSCalendar currentCalendar];NSDate *date = [calendar dateByAddingComponents:dateComponents toDate:[NSDate date] options:0];NSLog(@&quot;%@&quot;, date); 如果现在的时间是：2017-03-26 02:21:08 +0000那么打印结果就是：2017-03-29 02:21:08 +0000 在当前时间基础上增加3天。不过这是格林尼治时区的时间，可以转化为当前东8区的时间 12345NSTimeZone *zone = [NSTimeZone systemTimeZone];NSInteger interval = [zone secondsFromGMTForDate:date]; // 当前时区和标准时区相差的秒数NSDate *localeDate = [date dateByAddingTimeInterval:interval];NSLog(@&quot;%@&quot;, localeDate); 常用方法下面这些方法都是属于NSCalendar类的，都返回一个NSDateComponents类。 - (NSDateComponents *)components:(NSCalendarUnit)unitFlags fromDate:(NSDate *)date; 取得一个NSDate对象的1个或多个部分，结果用NSDateComponents来封装 123456NSCalendar *calendar = [NSCalendar currentCalendar];NSDateComponents *components = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:[NSDate date]];NSLog(@&quot;%zd&quot;, [components year]);NSLog(@&quot;%zd&quot;, [components month]);NSLog(@&quot;%zd&quot;, [components day]);NSLog(@&quot;%zd&quot;, [components weekday]); 需要注意的是，只有明确指定了unitFlags，NSDateComponents相应的那部分才有值。 年、月、日可以正常取到值，weekday则取不到正常值。 - (NSDateComponents *)components:(NSCalendarUnit)unitFlags fromDate:(NSDate )startingDate toDate:(NSDate \\)resultDate options:(NSCalendarOptions)opts; 取得两个NSDate对象的时间间隔，结果用NSDateComponents来封装 123456789NSDate *date1 = [NSDate date];NSDate *date2 = [NSDate dateWithTimeInterval:24*60*60+15 sinceDate:date1];NSCalendar *calendar = [NSCalendar currentCalendar];NSDateComponents *components = [calendar components:NSCalendarUnitDay|NSCalendarUnitSecond fromDate:date1 toDate:date2 options:0];NSLog(@&quot;%zd&quot;,[components year]);NSLog(@&quot;%zd&quot;,[components day]);NSLog(@&quot;%zd&quot;,[components second]); day、second可以正常取到值，year则取不到正常值。 注意： 1）得到的NSDateComponents对象可能会包含负数。例如：当toDate比fromDate晚10秒，second部分返回10;当toDate比fromDate早10秒，second部分返回-10 2）当指定unitFlags返回多个部分时，相隔的时间由多个部分共同组成(不是独立去表示)。例如：上面的例子时间相差24时15秒，如果指定只返回second部分，将得到86415秒;如果指定返回day和second部分，将得到1天15秒;如果指定返回hour、minute和second，将得到24时0分15秒。 NSCalendarNSCalendar对世界上现存的常用历法进行了封装，既提供了不同历法的时间信息，又支持日历的计算。 初始化方法 + (id)currentCalendar 获取当前客户端的逻辑日历 12NSCalendar *calendar = [NSCalendar currentCalendar];NSLog(@&quot;%@&quot;, calendar.calendarIdentifier); log信息显示：gregorian表示客户端当前是公历 - (nullable id)initWithCalendarIdentifier:(NSCalendarIdentifier)ident 根据日历标示符来初始化日历对象 12NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierChinese];NSLog(@&quot;%@&quot;, calendar.calendarIdentifier); log信息显示：chinese表示中国农历 系统中定义的有：NSGregorianCalendar –公历NSBuddhistCalendar –佛教日历NSChineseCalendar –中国农历NSHebrewCalendar –希伯来日历NSIslamicCalendar –伊斯兰日历NSIslamicCivilCalendar –伊斯兰教日历NSJapaneseCalendar –日本日历NSRepublicOfChinaCalendar –中华民国日历(台湾)NSPersianCalendar –波斯日历NSIndianCalendar –印度日历NSISO8601Calendar – ISO8601 常用方法 - (void)setLocale:(NSLocale *)locale 设置本地化信息 123NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];[calendar setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]];NSLog(@&quot;%@&quot;, calendar.locale.localeIdentifier); log信息显示：zh_CN - (void)setTimeZone:(NSTimeZone *)tz 设置时区信息 123NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];[calendar setTimeZone:[NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;]];NSLog(@&quot;%@&quot;, calendar.timeZone); log信息显示：Asia/Shanghai (GMT+8) offset 28800 - (void)setFirstWeekday:(NSUInteger)weekday 设置每周的第一天从星期几开始，如：1代表星期一开始，2代表星期二开始，以此类推。默认值是1。 12NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];[calendar setFirstWeekday:3]; - (void)setMinimumDaysInFirstWeek:(NSUInteger)mdw 设置每年及每月第一周必须包含的最少天数， 如:设定第一周最少包括3天，则value传3。 12NSCalendar *calendar = [NSCalendar currentCalendar];[calendar setMinimumDaysInFirstWeek:3]; NSDateFormatterNSDateFormatter的日期格式如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960G --纪元一般会显示公元前(BC)和公元(AD)y --年假如是2017年，那么yyyy=2017，yy=17M --月假如是3月，那么M=3，MM=03，MMM=Mar，MMMM=March假如是11月，那么M=11，MM=11，MMM=Nov，MMMM=Novemberw --年内的第几周假如是1月8日，那么w=2(这一年的第二个周)W --月内的第几周(与日历排列有关)假如是2017年4月21，那么W=4(这个月的第四个周)F --月份包含的周(与日历排列无关)和上面的W不一样，F只是单纯以7天为一个单位来统计周，例如7号一定是第一个周，15号一定是第三个周，与日历排列无关。D --年包含的天数假如是1月20，那么D=20(这一年的第20天)假如是2月25，那么D=31+25=56(这一年的第56天)d --月份包含的天数假如是5号，那么d=5，dd=05假如是15号，那么d=15，dd=15E --星期假如是星期五，那么E=Fri，EEEE=Fridaya --上午(AM)/下午(PM)H -- 24时制，显示为0--23假如是午夜00:40，那么H=0:40，HH=00:40h -- 12时制，显示为1--12假如是午夜00:40，那么h=12:40K -- 12时制，显示为0--11假如是午夜00:40，那么K=0:40，KK=00:40k -- 24时制，显示为1--24假如是午夜00:40，那么k=24:40m --分钟假如是5分钟，那么m=5，mm=05假如是45分钟，那么m=45，mm=45s --秒假如是5秒钟，那么s=5，ss=05假如是45秒钟，那么s=45，ss=45S --毫秒一般用SSS来显示z --时区表现形式为GMT+08:00Z --时区表现形式为+0800 NSDateFormatter的两个最实用的方法是dateFromString和stringFromDate，前者将字符串经过格式化后变成NSDate对象，后者将NSDate对象格式化成字符串。 常用方法 setDateFormat 在调setDateFormat设置格式化字符串时，可以使用单引号来引入其他字符串。 1234567NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@&quot;yyyy-MM-dd &#x27;I Love China!&#x27; HH:mm:ss&quot;];NSDate *currentDate = [NSDate date];NSString *dateStr = [dateFormatter stringFromDate:currentDate];NSLog(@&quot;%@&quot;, dateStr); log信息显示：2017-03-26 I Love China! 18:45:14 dateFromString 使用NSDateFormatter转换时间字符串时，默认的时区是系统时区，例如在中国都是北京时间(+8)，如果直接转换会导致结果相差8小时，所以一般的做法是先指定时区为GMT标准时间再转换。 12345678NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];[dateFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];NSString *dateStr = @&quot;2017-03-26 18:45:14&quot;;NSDate *date = [dateFormatter dateFromString:dateStr];NSLog(@&quot;%@&quot;,date); log信息显示：2017-03-26 18:45:14","categories":[],"tags":[]},{"title":"时间与日期（上）","slug":"TimeANdDate","date":"2017-03-24T09:41:31.000Z","updated":"2020-11-02T14:19:04.797Z","comments":true,"path":"2017/03/24/TimeANdDate/","link":"","permalink":"http://onzxgway.github.io/2017/03/24/TimeANdDate/","excerpt":"","text":"NSDateNSDate表示公历（阳历）的格林尼治（G.M.T.）时间。 初始化方法 - (instancetype)init 默认的初始化方法，返回当前时间，也可以直接调用+ (instancetype)date方法 12345NSDate *date = [[NSDate alloc] init];// NSDate *date = [NSDate date]; // 等同于上句NSLog(@&quot;%@&quot;,date); log信息如下：2017-03-24 01:47:29 +0000打印的时间是格林尼治标准时间，不是我们所在的东八区时间。 - (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs 以当前时间的偏移秒数来初始化，也可以直接调用+ (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs方法 123NSDate *date = [[NSDate alloc] init];NSDate *date1 = [[NSDate alloc] initWithTimeIntervalSinceNow:-88];NSLog(@&quot;%@ --&gt; %@&quot;, date, date1); log信息如下：2017-03-24 02:11:37 +0000 –&gt; 2017-03-24 02:10:09 +0000 - (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs 以1970-01-01 00：00：00时间的偏移秒数来初始化，也可以直接调用+ (instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs 12NSDate *date = [[NSDate alloc] initWithTimeIntervalSince1970:-20];NSLog(@&quot;%@&quot;,date); log信息如下：1969-12-31 23:59:40 +0000 - (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti 以2001-01-01 00：00：00时间的偏移秒数来初始化，也可以直接调用+ (instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti; 123NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:20];NSLog(@&quot;%@&quot;,date); log信息如下：2001-01-01 00:00:20 +0000 - (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date 以参数date基准时间的偏移秒数来初始化，也可以直接调用+ (instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date 12345NSDate *currentDate = [[NSDate alloc] initWithTimeIntervalSince1970:20];NSLog(@&quot;%@&quot;,currentDate);NSDate *date = [[NSDate alloc] initWithTimeInterval:20 sinceDate:currentDate];NSLog(@&quot;%@&quot;,date); log信息如下：1970-01-01 00:00:20 +00001970-01-01 00:00:40 +0000 - (instancetype)dateByAddingTimeInterval:(NSTimeInterval)ti 返回以NSDate对象为基准，偏移多少秒后得到的新NSDate对象。与- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date方法相似。 12345NSDate *currentDate = [[NSDate alloc] initWithTimeIntervalSince1970:20];NSLog(@&quot;%@&quot;,currentDate);NSDate *date = [currentDate dateByAddingTimeInterval:20];NSLog(@&quot;%@&quot;,date); log信息如下：1970-01-01 00:00:20 +00001970-01-01 00:00:40 +0000 +(NSDate)distantPast与+(NSDate)distantFuture 这两个类方法，分别返回一个极早的时间点和一个极晚的时间点。 1234NSDate *PastDate = [NSDate distantPast];NSDate *futureDate = [NSDate distantFuture];NSLog(@&quot;%@ --&gt; %@&quot;,PastDate,futureDate); log信息如下：0000-12-30 00:00:00 +0000 –&gt; 4001-01-01 00:00:00 +0000 常用方法 - (BOOL)isEqualToDate:(NSDate *)otherDate 将当前日期对象与参数传递的日期对象进行比较，根据是否相同返回BOOL值 123456NSDate *firstDate = [[NSDate alloc] initWithTimeIntervalSince1970:20];NSDate *secondDate = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:-20];BOOL result = [firstDate isEqualToDate:secondDate];NSLog(@&quot;%d&quot;,result); log信息如下：NO - (NSDate *)earlierDate:(NSDate *)anotherDate方法与- (NSDate *)laterDate:(NSDate *)anotherDate方法 两个日期比较，返回较早/较晚的那个日期对象。 123456NSDate *firstDate = [[NSDate alloc] initWithTimeIntervalSince1970:20];NSDate *secondDate = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:-20];NSDate *result1 = [firstDate earlierDate:secondDate];NSDate *result2 = [firstDate laterDate:secondDate]; - (NSComparisonResult)compare:(NSDate *)other 比较两个日期对象的大小，返回值是NSComparisonResult枚举类型。{NSOrderedAscending (升序)， NSOrderedSame(相同) ，NSOrderedDescending(降序)} 12345NSDate *firstDate = [[NSDate alloc] initWithTimeIntervalSince1970:20];NSDate *secondDate = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:-20];NSComparisonResult result = [firstDate compare:secondDate]; - (NSTimeInterval)timeIntervalSince1970 - (NSTimeInterval)timeIntervalSinceReferenceDate - (NSTimeInterval)timeIntervalSinceNow - (NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate 返回当前对象时间与1970-01-01 00:00:00的相隔秒数返回当前对象时间与2001-01-01 00:00:00的相隔秒数返回当前时间对象与现在系统时间的相隔秒数返回当前对象时间与参数传递的对象时间的相隔秒数 123456789101112NSDate *currentDate = [[NSDate alloc] initWithTimeIntervalSinceNow:-20];NSTimeInterval resultNow = [currentDate timeIntervalSinceNow];NSTimeInterval result1970 = [currentDate timeIntervalSince1970];NSTimeInterval result2001 = [currentDate timeIntervalSinceReferenceDate];NSDate *date = [[NSDate alloc] init];NSTimeInterval result = [currentDate timeIntervalSinceDate:date];NSLog(@&quot;%f+++%f+++%f+++%f&quot;,resultNow,result1970,result2001,result); log信息如下：-20.000006+++1490326647.182058+++512019447.182058+++-20.000003 NSTimeZoneNSTimeZone表示时区信息。iOS中的时区表示方法：GMT+0800，GMT-0800 (+：东区，-：西区，08：小时数，00：分钟数)。GMT+0800 表示比GMT早8小时0分钟的时区。 初始化方法 - (nullable instancetype)initWithName:(NSString *)tzName 根据时区名称初始化，返回一个时区对象，也可以直接调用+ (nullable instancetype)timeZoneWithName:(NSString *)tzName。 12345NSTimeZone *zone = [[NSTimeZone alloc] initWithName:@&quot;Asia/Shanghai&quot;];// NSTimeZone *zone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];NSLog(@&quot;%@&quot;,zone); log信息如下：Asia/Shanghai (GMT+8) offset 28800 时区名称也可以以GMT+0800形式设置。例如[NSTimeZone timeZoneWithName:@”GMT+0800”]; + (NSArray *)knownTimeZoneNames 返回所有的时区名称。 123NSArray *timeZoneNames = [NSTimeZone knownTimeZoneNames];NSLog(@&quot;%@&quot;,timeZoneNames); log信息如下：“Africa/Abidjan”,“Africa/Accra”,“Africa/Addis_Ababa”,“Africa/Algiers”,… 等等 + (nullable instancetype)timeZoneWithAbbreviation:(NSString *)abbreviation 根据时区名称缩写初始化,例如HKT(香港标准时间) 123NSTimeZone *zone = [NSTimeZone timeZoneWithAbbreviation:@&quot;HKT&quot;];NSLog(@&quot;%@&quot;,zone); log信息如下：Asia/Hong_Kong (GMT+8) offset 28800 时区名称也可以以GMT+0800形式设置。例如[NSTimeZone timeZoneWithAbbreviation:@”GMT+0800”]; + (NSDictionary *)abbreviationDictionary 返回所有的时区名称缩写。 123NSDictionary *dict = [NSTimeZone abbreviationDictionary];NSLog(@&quot;%@&quot;,dict); log信息如下：ADT = “America/Halifax”;AKDT = “America/Juneau”;AKST = “America/Juneau”;… 等等 常用方法 + (NSTimeZone *)systemTimeZone + (NSTimeZone *)localTimeZone + (NSTimeZone *)defaultTimeZone 返回系统时区返回本地时区返回默认时区，它与以上二者的区别在于，默认时区可以修改，本地和系统时区不能修改。 123456NSTimeZone *localZone = [NSTimeZone localTimeZone];NSTimeZone *systemZone = [NSTimeZone systemTimeZone];[NSTimeZone setDefaultTimeZone:[NSTimeZone timeZoneWithAbbreviation:@&quot;EST&quot;]];NSTimeZone *defaultZone = [NSTimeZone defaultTimeZone]; NSLog(@&quot;%@ --&gt; %@ --&gt; %@&quot;, localZone, systemZone, defaultZone); log信息如下：Local Time Zone (Asia/Shanghai (GMT+8) offset 28800) –&gt;Asia/Shanghai (GMT+8) offset 28800 –&gt;America/New_York (EST) offset -18000 + (id)timeZoneForSecondsFromGMT:(NSInteger)seconds 根据零时区的秒数偏移返回一个新时区对象 123NSTimeZone *zone = [NSTimeZone timeZoneForSecondsFromGMT:28800];NSLog(@&quot;%@&quot;,zone); log信息如下：GMT+0800 (GMT+8) offset 28800为东八区 *- (NSString \\)name ** - (NSString *)abbreviation 返回时区对象的名称返回时区对象的缩写 123456NSTimeZone *zone = [NSTimeZone localTimeZone];NSString *strZoneName = [zone name];NSString *strZoneAbbreviation = [zone abbreviation];NSLog(@&quot;name is %@&quot;,strZoneName);NSLog(@&quot;abbreviation is %@&quot;,strZoneAbbreviation); log信息如下：name is Asia/Shanghaiabbreviation is GMT+8 - (NSInteger)secondsFromGMT 得到当前时区与零时区的间隔秒数 1234NSTimeZone *zone = [NSTimeZone systemTimeZone];NSInteger seconds = [zone secondsFromGMT];NSLog(@&quot;%zd&quot;,seconds); log信息如下：28800 NSLocaleNSLocale类的主要作用是用来封装本地化相关的各种信息，包括语言，货币类型，数字，日期格式等等。 初始化方法 - (instancetype)initWithLocaleIdentifier:(NSString *)string 用本地标示符初始本地化信息，例如zh_CN标示中国大陆 1234NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];NSString *localeStr = [locale localeIdentifier];NSLog(@&quot;locale:%@&quot;,localeStr); log信息如下：zh_CN + (NSArray *)availableLocaleIdentifiers 返回所有的可用标识符。 123NSArray *availableLocaleIdentifiers = [NSLocale availableLocaleIdentifiers];NSLog(@&quot;%@&quot;,availableLocaleIdentifiers); log信息如下：eu,“hr_BA”,“en_CM”,…ast,“en_SZ”,“he_IL”,…等等 常用方法 + (id)currentLocale + (id)autoupdatingCurrentLocale 返回当前客户端的本地化信息 1234NSLocale *locale = [NSLocale currentLocale];NSString *localeStr = [locale localeIdentifier];NSLog(@&quot;%@&quot;,localeStr); log信息如下：en_US [NSLocale ISOCountryCodes] 获取所有已知合法的ISO国家代码数组列表 [NSLocale ISOCurrencyCodes] 获取所有已知合法的ISO货币代码数组列表 [NSLocale ISOLanguageCodes] 获取所有已知合法的ISO语言代码数组列表 -(NSStrng *) currencySymbol 返回当前货币符号 1234NSLocale *locale = [NSLocale currentLocale];NSString *currencySymbol = [locale currencySymbol];NSLog(@&quot;%@&quot;,currencySymbol); log信息如下：$ + (NSLocaleLanguageDirection)lineDirectionForLanguage: 获取当前语言的排版方向 + (NSLocaleLanguageDirection)characterDirectionForLanguage: 获取当前语言的字符方向 - (NSString *)displayNameForKey:(id)key value:(id)value 以本地化方式获取国际化信息的显示名称 1234567NSArray * availableLocaleIdentifiers = [NSLocale availableLocaleIdentifiers];NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];for (NSString *identifiers in availableLocaleIdentifiers) &#123; NSString *str = [locale displayNameForKey:NSLocaleIdentifier value:identifiers]; NSLog(@&quot;%@--%@&quot;,identifiers,str);&#125; log信息如下：eu–巴斯克语hr_BA–克罗地亚语（波斯尼亚和黑塞哥维那）en_CM–英语（喀麦隆）en_BI–英语（布隆迪）en_AE–英语（阿拉伯联合酋长国）…等等 监听用户本地化设置的消息 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(localChangedHandler:) name:NSCurrentLocaleDidChangeNotification object:nil];","categories":[],"tags":[]},{"title":"iOS并发编程基础","slug":"Multi-threading-1","date":"2017-03-22T10:21:56.000Z","updated":"2020-10-26T04:06:25.648Z","comments":true,"path":"2017/03/22/Multi-threading-1/","link":"","permalink":"http://onzxgway.github.io/2017/03/22/Multi-threading-1/","excerpt":"","text":"并发 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种**API(pthread,NSThread,GCD,NSOperation)**用于并发编程。本文以讲解四种API的使用方法为切入点，带你了解多线程的全貌。 在学习并发编程之前，首先我们要知道线程的概念，以及线程的一些相关基础知识，这是学习并发编程的基础。 什么是线程线程（thread）是进程的基本单位，一个进程包含一个或多个线程（至少包含一个），操作系统的调度器可以直接调度线程。所有的并发编程API都是构建在线程上的。 线程的状态 新建：线程对象在内存中被创建出来。 就绪：除了CPU以外的所有资源都已分配好了，等待CPU调度。（已经加入可调度线程池中） 运行：CPU正在运行该线程。（当CPU切换执行其它线程的时候，当前线程退回到就绪状态） 阻塞：除了CPU以外，还有其它资源没有分配，（阻塞状态的线程，被移出了可调度线程池） 死亡：线程被销毁，占用的内存空间被释放。 并发编程的四种API介绍pthreadpthread(posix线程) 是一套纯C的API，平时几乎不会使用，如果没有兴趣可以不用了解，当然如果想多掌握一些的话，可以继续往下阅读。 1234567891011121314如何使用：1，导入头文件 #import &lt;pthread.h&gt;2，调用函数 int pthread_create(pthread_t * __restrict,pthread_attr_t * __restrict,void * (*) (void *),void * __restrict);&#x2F;*参数解释 返回值是0 表示创建线程成功 非0表示创建线程失败 1,pthread_t * 线程的标示 2,pthread_attr_t 线程的属性 3,void* (*) (void *) 返回值 函数名 参数 函数签名 void * 约等于OC中的id任意类型 4,void * 给函数的参数 *&#x2F; NSThreadNSThread是pthread面向对象的封装。在面向对象的编程环境中，使用也更加习惯方便。一个NSThread实例对应一个线程。 一 如何使用： 【类方法/自动开启】优点：使用简单，线程创建好之后处于就绪(runnable)状态，CPU可直接调度。缺点：无法拿到线程对象本身做更详细的设置。 12+ (void)detachNewThreadWithBlock:(void (^)(void))block;+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 【实例方法/手动开启】优点：可以获取到线程对象，做更详细的设置。（设置线程优先级、线程名称等）缺点：线程创建好以后处于新建（new）状态，需要手动调用start/main方法进入就绪(runnable)状态，没有类方法使用简单。 12345- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;- (instancetype)initWithBlock:(void (^)(void))block;- (void)start; // start方法在子线程执行，不能重复开启（不能调用两遍以上start方法）- (void)main; // main方法在主线程执行，可以重复调用 注意：- (instancetype)init;方法得到的是主线程。 【隐式创建】优缺点和类方法相同 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; 注意：隐式创建方法不属于NSThread，而是属于NSObject的NSThreadPerformAdditions分类。 【自定义】 123第一步：自定义一个线程类。例如XXThread，继承自NSThread类。第二步：在XXThread类中，重写main方法，把需要在后台子线程中执行的代码放进去。第三步：通过alloc+init方法创建XXThread对象，然后调用start方法即可。 二 常见属性： 1234567891011121314151617181920212223// 线程优先级，double类型，取值范围是：0.0~1.0，默认是0.5，1.0表示优先级最高，优先级越高，表示被CPU调度的概率越高。逐渐被废弃，用qualityOfService替代thread.threadPriority// 线程服务质量约等于线程优先级，枚举值，默认是NSQualityOfServiceDefault=-1,优先级最低。iOS8之后比threadPriority好用thread.qualityOfService;// 线程的名称,主线程默认名称是main，子线程默认名称为null,thread.name;// 判断当前线程是否是主线程，只读属性mainThread// 判断当前线程是否正在执行任务，只读属性executing// 判断当前线程是否执行结束，只读属性finished// 判断当前线程是否被取消，只读属性cancelled// 线程在stack栈上占用的存储空间，通常为512kb，线程释放后，空间收回。thread.stackSize; 三 常用方法： 123456789101112131415// 休眠到指定时间点+ (void)sleepUntilDate:(NSDate *)date// 休眠一段时间+ (void)sleepForTimeInterval:(NSTimeInterval)time// 获取当前线程对象[NSThread currentThread];// 获取主线程对象[NSThread mainThread];// 退出线程[NSThread exit];// 如果自定义线程类，把要执行的任务，放在重写的main方法中。- (void)main // thread body method 直接操作线程对象可能引发一个问题，如果你的代码和项目中使用到的框架代码都创建了自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型项目中是一个常见问题。例如：在8核CPU中，你创建了8个线程来发挥CPU性能。然而在这些线程中调用到的框架代码也做了同样的事情（因为框架不知道你也创建了线程），这样就会很快产生成百上千的线程，代码每个部分自身都没有问题，但是最终还是产生了问题。每个线程都会消耗一些内存和内核资源。接下来，我将介绍并发编程API：GCD，它们是通过管理一个可以协同使用的线程池，来解决上面的问题的。 GCDGCD(Grand Central Dispatch)是多核优化的解决方案，是一套纯C的API，核心思想是在系统底层维护了一个线程池，自动管理线程对象，开发者不用直接和线程打交道，只需要关注队列和任务即可。 在学习GCD编程之前，首先我们要理解队列和任务的概念，这是基础，也是GCD的核心概念。 队列用来存放任务的，先进先出的（FIFO，First in first out)容器就是队列。 12// 队列dispatch_queue_t 队列分为两类：串型队列（Serial Queue）和并发队列（Concurrent Queue）。 【串行队列】内部的任务一个接着一个执行，等待上一个任务执行完毕，才会接着执行下一个任务。 12345678// 获取串行队列的方式 1.系统提供 2.手动创建// 1.获取系统提供的串行队列dispatch_queue_t queue = dispatch_get_main_queue();// 2.创建一个串行队列// 队列的名称com.app.serial// 队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); 【并发队列】队列内部的多个任务同一时刻执行。 12345678910// 获取并发队列的方式 1.系统提供 2.手动创建// 1.获取系统提供的并发队列// 队列优先级 DISPATCH_QUEUE_PRIORITY_DEFAULT// 第二个参数flags作为保留字段备用，一般都直接填0dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 2.创建一个并发队列// 队列的名称。 作用：可以协助开发调试和崩溃报告分析// 队列的类型，是枚举值。DISPATCH_QUEUE_CONCURRENT表示并发。dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); 【主队列】也叫【全局串行队列】主队列是特殊的串行队列，由系统提供，使用的时候只要去获取即可，无需开发者手动创建，特殊点在于主队列中的任务只能由主线程去执行。 特点：1，主线程正在执行代码暂时不调度任务，等主线程执行结束后再调度任务。这是主队列中同步执行导致死锁的原因。2，UI更新的操作都要放在主线程中处理。 12// 获取系统提供的主队列dispatch_queue_t queue = dispatch_get_main_queue(); 【全局并发队列】全局并发队列，使用的时候去获取即可，无需开发者手动创建。 123456789&#x2F;&#x2F; 获取系统提供的全局并发队列dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);&#x2F;&#x2F; 参数解释1，指定队列的优先级。DISPATCH_QUEUE_PRIORITY_HIGH (2)DISPATCH_QUEUE_PRIORITY_DEFAULT (0)&#x2F;&#x2F; 自定义队列的优先级都是默认优先级DISPATCH_QUEUE_PRIORITY_LOW (-2)DISPATCH_QUEUE_PRIORITY_BACKGROUND (INT16_MIN)2，作为保留字段备用（一般为0) 任务添加到队列中的可执行代码块就是任务。 12&#x2F;&#x2F; 类型dispatch_block_t 注意：dispatch_block_t的定义是typedef void (^dispatch_block_t)(void)，由定义可以看出它本质就是一个无参数无返回值的block。 任务添加到队列的方式任务添加到队列的方式有两个：同步执行（dispatch_sync）和异步执行（dispatch_async），两者区别在于是否开启新线程，同步执行不开启新线程，任务在当前线程执行，异步开启新线程，任务在新线程执行。 【同步执行】 12345678// 队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);// 任务dispatch_block_t block = ^ &#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;;dispatch_sync(queue, block); 【异步执行】 123456789// 队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);// 任务dispatch_block_t block = ^ &#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;; dispatch_async(queue, block); 上面这么写的目的，是帮助理解，在开发中代码要简写。 12345678// 1，创建串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);//// 2,异步执行dispatch_async(queue, ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 在了解完GCD的核心基本概念之后，我们学习GCD的使用方法 串型队列的执行【串行队列➕同步执行】 12345678910111213141516171819202122232425262728293031323334- (void)syncAndSerial &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); // 第一个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); // 第二个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); // 第三个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__ 执行过程：当前线程执行到第一个任务时，会把任务添加到串行队列中，由于是同步的，必须再把任务执行完成，才可以继续向下执行第二个任务。结论：同步执行 ➕ 串行队列，不开启新线程，在当前线程中依次执行。 【串行队列➕异步执行】 开启一个子线程，任务在子线程执行，为什么只开启一个，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndSerial &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); // 第一个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125; 结论：异步执行 ➕ 串行队列，开启一个新线程，任务依次执行。 并发队列的执行【并发队列➕同步执行】 123456789101112131415161718192021222324252627282930313233- (void)syncAndConcurrent &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__ 结论：执行情况与同步执行 ➕ 串行队列一模一样，不开启新线程，在当前线程中依次执行。 【并发队列➕异步执行】 开启多个子线程，任务在子线程执行，具体开启多少个线程是不固定的(线程数，不由我们控制是由gcd来决定的)。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndConcurrent &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); // 第一个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第二个任务---当前线程&lt;NSThread: 0x60000328cb40&gt;&#123;number = 11, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032bb2c0&gt;&#123;number = 12, name = (null)&#125;----执行第一个任务---当前线程&lt;NSThread: 0x6000032b2380&gt;&#123;number = 8, name = (null)&#125; 结论：开启若干新线程，任务并发执行。 主队列的执行系统已经为我们提供了2个常用队列，主队列（全局串行队列）和全局并发队列，开发中很多时候都是使用系统提供的队列，不用自己手动创建 【主队列➕同步执行】 前提：当前在主线程。 12345678910111213141516171819202122232425262728293031323334- (void)syncAndMain &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue &#x3D; dispatch_get_main_queue(); &#x2F;&#x2F; 第一个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第二个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第三个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; 结论：在主线程会死锁导致应用crash。注意：当程序执行到这段代码的时候，向主队列中添加一个任务，此时如果主线程要继续往下执行的话，必须要执行刚添加到主队列中的任务，只有把这个任务执行完毕之后，才可以继续，所以现在要等待调度该任务。而主队列有个特点就是只有主线程不忙的时候，才会去调度主线程执行任务，现在的情况是主线程很忙，所以不会去调度任务，一个等待调度任务执行，一个不让去调度任务，最终导致了死锁。 前提：当前在子线程。 12345678910111213141516171819202122232425262728293031323334353637- (void)othersyncAndMain &#123; dispatch_queue_t concurrentQueue = dispatch_get_global_queue(0, 0); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); // 第一个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]); &#125;);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x600002bcd1c0&gt;&#123;number = 7, name = (null)&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x600002bcd1c0&gt;&#123;number = 7, name = (null)&#125;__ 结论：当前在子线程中可以正常执行。 【主队列➕异步执行】 不开线程，因为主队列的任务只有主线程可以执行。同步执行任务。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndMain &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue &#x3D; dispatch_get_main_queue(); &#x2F;&#x2F; 第一个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第二个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第三个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125; 队列的区别比较表格 并发队列 串行队列 主队列 同步(sync) 在当前线程，依次执行任务 在当前线程，依次执行任务 死锁 异步(async) 开启新线程，并行执行任务 开启新线程，依次执行任务 在当前线程，依次执行任务 NSOperationNSOperation是GCD面向对象的封装，在面向对象的编程环境中使用更加习惯方便，是苹果官方推荐的安全可靠的并发编程方式。 首先介绍两个核心类NSOperationQueue和NSOperation。 NSOperationQueue 通过NSOperationQueue可以获取到主队列，也可以创建新队列。 1234567891011121314151617181920212223242526272829- (void)queueKinds &#123; // 获取主队列 NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; [mainQueue addOperationWithBlock:^&#123; NSLog(@&quot;mainQueue1::%@&quot;, [NSThread currentThread]); &#125;]; [mainQueue addOperationWithBlock:^&#123; NSLog(@&quot;mainQueue2::%@&quot;, [NSThread currentThread]); &#125;]; // 创建新队列 NSOperationQueue *customQueue = [[NSOperationQueue alloc] init]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue::%@&quot;, [NSThread currentThread]); &#125;]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue1::%@&quot;, [NSThread currentThread]); &#125;]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue2::%@&quot;, [NSThread currentThread]); &#125;];&#125; log信息显示如下： 12345customQueue2::&lt;NSThread: 0x600003df4000&gt;&#123;number = 5, name = (null)&#125;customQueue1::&lt;NSThread: 0x600003df4080&gt;&#123;number = 4, name = (null)&#125;customQueue::&lt;NSThread: 0x600003df9b40&gt;&#123;number = 7, name = (null)&#125;mainQueue1::&lt;NSThread: 0x600003db00c0&gt;&#123;number = 1, name = main&#125;mainQueue2::&lt;NSThread: 0x600003db00c0&gt;&#123;number = 1, name = main&#125; 结论：通过alloc+init创建的队列是并发队列。 通过控制最大并发数属性maxConcurrentOperationCount，可以实现串行和并发的切换。默认情况下为-1，表示不进行限制，队列是并发队列。为1时，队列为串行队列。大于1时，队列为并发队列。当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为min{自己设定的值，系统设定的默认最大值}。 NSOperationNSOperation是个抽象类，不能够直接使用，系统提供了两个子类NSInvocationOperation和NSBlockOperation供使用，也可以自定义子类。 【NSInvocationOperation】 操作直接执行 1234567891011121314- (void)operation &#123; &#x2F;&#x2F; 1，创建 NSInvocationOperation 对象 NSInvocationOperation *op1 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(taskMethod:) object:@2]; &#x2F;&#x2F; 2，不开新线程，在当前线程开始执行操作 [op1 start]; &#x2F;&#x2F; [op1 main]; main方法和start作用相同&#125;- (void)taskMethod:(NSNumber *)count &#123; for (int i &#x3D; 0; i &lt; count.intValue; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125;&#125; 操作添加到队列 1234567891011- (void)demo &#123; &#x2F;&#x2F; 默认最大并发数是-1，队列属于并发队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; for (int i &#x3D; 0; i &lt; 6; ++i) &#123; &#x2F;&#x2F; 创建操作 NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector: @selector(taskMethod:) object:@1]; &#x2F;&#x2F; 操作添加到队列 [queue addOperation: operation]; &#125;&#125; log信息显示如下： 123456---&lt;NSThread: 0x6000030a0500&gt;&#123;number = 5, name = (null)&#125;---&lt;NSThread: 0x6000030a18c0&gt;&#123;number = 4, name = (null)&#125;---&lt;NSThread: 0x6000030dbd80&gt;&#123;number = 3, name = (null)&#125;---&lt;NSThread: 0x600003082200&gt;&#123;number = 6, name = (null)&#125;---&lt;NSThread: 0x6000030a9640&gt;&#123;number = 8, name = (null)&#125;---&lt;NSThread: 0x6000030a9f40&gt;&#123;number = 7, name = (null)&#125; 【NSBlockOperation】 相比NSInvocationOperation使用起来更加简便，所以开发中经常使用。 操作直接执行 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; &#x2F;&#x2F; 1.创建 NSBlockOperation 对象 NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 2.添加额外的操作 [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 3.调用 start 方法开始执行操作 [op start]; &#125; 1234567894---&lt;NSThread: 0x6000037aacc0&gt;&#123;number = 7, name = (null)&#125;1---&lt;NSThread: 0x6000037f0840&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x6000037b8700&gt;&#123;number = 5, name = (null)&#125;2---&lt;NSThread: 0x6000037bc000&gt;&#123;number = 6, name = (null)&#125;2---&lt;NSThread: 0x6000037bc000&gt;&#123;number = 6, name = (null)&#125;4---&lt;NSThread: 0x6000037aacc0&gt;&#123;number = 7, name = (null)&#125;3---&lt;NSThread: 0x6000037b8700&gt;&#123;number = 5, name = (null)&#125;1---&lt;NSThread: 0x6000037f0840&gt;&#123;number = 1, name = main&#125; 操作添加到队列 1234567// 默认最大并发数是-1，队列属于并发队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 1.创建 NSBlockOperation 对象NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;];[queue addOperation:op]; 简便写法 123456&#x2F;&#x2F; 队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 添加操作[queue addOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;]; 在NSOperation单独使用情况下，调用start/main方法，是否开启新线程，取决于操作的个数。如果操作的个数是一个的话，任务在当前线程执行。如果操作个数大于等于两个，就会自动开启新线程。 【NSInvocationOperation与NSBlockOperation异同】共同点： NSInvocationOperation类只能封装一个操作，所以当调用start方法时，任务在当前线程执行。NSBlockOperation是否开启新线程，取决于操作的个数。如果添加的操作的个数是一个的话，调用start方法时，任务在当前线程执行。如果添加的操作个数大于等于两个，就会自动开启新线程。NSCustomOperation调用start方法时，任务在当前线程执行。 区别： NSBlockOperation可以添加多个操作。而NSInvocationOperation和NSCustomOperation只能添加一个操作。 接下来再介绍NSOperationQueue的一些其它的特性和用法。 【最大并发数】 队列通过控制最大并发数属性，可以实现串行与并发的切换功能。 maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，是并发队列。为1时，队列为串行队列。大于1时，队列为并发队列。当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为min{自己设定的值，系统设定的默认最大值}。 【优先级】 队列的优先级iOS8.0之后队列优先级使用qualityOfService属性 123NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F; 优先级高代表被执行的概率高，而不是一定会先执行。queue.qualityOfService &#x3D; NSQualityOfServiceUserInteractive; 任务的优先级iOS8.0之后任务优先级使用qualityOfService属性替代queuePriority属性 12345NSBlockOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; &#125;];&#x2F;&#x2F;优先级高代表被执行的概率高，而不是一定会先执行。&#x2F;&#x2F;qualityOfService的值是枚举类型，可到文档中具体查看，这里不一一介绍了。operation.qualityOfService &#x3D; NSOperationQueuePriorityNormal; 【队列挂起和任务取消】 挂起：暂停队列中还没有被调度的任务，正在调度的任务，不能被暂停取消队列中的所有操作，同样不会影响到正在执行中的操作 12345678NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F; 挂起 暂停队列中还没有被调度的任务，正在调度的任务，不能被暂停[operationQueue setSuspended:YES];&#x2F;&#x2F; 取消挂起 线程继续调度任务执行[operationQueue setSuspended:NO];&#x2F;&#x2F; 取消队列中的所有操作，同样不会影响到正在执行中的操作[operationQueue cancelAllOperations]; 【队列的操作数】 队列的操作数属性可以获取队列中操作的数量 123NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F; operationCount属性可以获取当前队列中的任务数量NSLog(@&quot;%@&quot;,operationQueue.operationCount);","categories":[],"tags":[]},{"title":"在MacOS上使用Hexo+GitHub搭建个人博客","slug":"hexo-github-1","date":"2017-02-20T10:21:56.000Z","updated":"2020-10-05T13:24:43.052Z","comments":true,"path":"2017/02/20/hexo-github-1/","link":"","permalink":"http://onzxgway.github.io/2017/02/20/hexo-github-1/","excerpt":"","text":"IT行业的知识体系更新迭代非常频繁，开发者需要不停的去学习新的知识新的技术，那么往往老的知识技术会遗忘的非常快，通过记录总结可以在需要的时候快速回忆起来，其次，互联网IT的精神核心是分享、共享，总结记录下来就可以分享给需要的人。所以，我需要一个可以满足我的需求的方式，个人博客就是一个非常好的方式。 通过Hexo + Github搭建的个人博客，就是一个非常好的选择。首先介绍一下Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 建站具体的建站过程，在这篇博文中不是重点，因为在网络上可以搜索到非常多的教程，任意选择一个即可，我推荐官方的中文建站文档，里面的说明非常全面详细。 重点来了，我在建站过程中踩过的坑，犯过的错误，浪费的时间精力，是我非常想和大家分享的。 执行安装语句出错1sudo npm install -g hexo-cli 报错信息提示需要在语句末尾加上–force 1sudo npm install -g hexo-cli --force 安装成功。 执行hexo d语句出错1hexo d 报错信息 1234You should configure deployment settings in _config.yml first!Available deployer plugins: gitFor more help, you can check the online docs: http://hexo.io/ 纳尼，我就拷贝了deploy的配置语句，追加在_config.yml文件末尾，其他啥也没干啊，怎么就不对了呢，奇怪。 12345deploy:type: gitrepo: git@github.com:onzxgway/onzxgway.github.io.gitbranch: master 在网上查了一番资料才发现，是没有缩进导致的，😭，正确的格式应该是这样的 1234deploy: type: git repo: git@github.com:onzxgway/onzxgway.github.io.git branch: master 更换主题不生效系统默认的主题landscape被我更换为archer之后，重新生成静态文件，部署上线，但是实际不生效。解决方法：在重新生成静态文件前，执行 1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况下（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 配置文件_config.yml您可以在 _config.yml 文件中修改大部分的配置。 在文章中插入图片Hexo配置文件的设置在博客根目录下，配置_config.yml文件，把post_asset_folder字段值由false改为true。设置post_asset_folder参数后，运行hexo n “xxxx”来生成md博文时，hexo会自动创建一个与文章同名的文件夹，您可以把相关的资源都放到此文件夹内，这样就可以更方便的管理和使用资源。 安装hexo-asset-image插件由于hexo默认不支持文章插入本地图片，那么就需要安装hexo-asset-image图片路径转换插件来支持。切换到博客根目录下，运行如下指令安装插件。 1npm install hexo-asset-image --save 插件安装完以后，实际上是存放在…/node_modules/hexo-asset-image目录文件夹下的，如果想要卸载这个插件的话，直接删掉这个文件夹即可。 插入图片运行hexo n “firstblog”指令，创建一篇名为firstblog.md文章，然后查看博客的 …/source/_posts目录，会看到存在一个firstblog文件夹和firstblog.md文件，将博文所需要的资源放到firstblog文件夹下，写博客时使用![图片描述](xxx/xxx.png)直接插入该文件夹内的图片即可。 在文章中插入图片遇到的坑1，在md文件中使用![图片描述](xxx/xxx.png)语法引用图片，图片无法成功加载。 开始查找错误，通过浏览器调试，发现是图片的路径不对，显示为http://example.com/......，奥，瞬间明白了，是由于_config.yml文件中的url没有设置正确值，解决方式很简单就是把url的值修改为http://onzxgway.github.io。修改好了之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 接着查找问题，通过浏览器调试，发现还是图片的路径不对，显示为http://onzxgway.github.io/io//ReferenceCount.png，这就奇怪了，怎么会生成这种路径呢，通过查找资料发现是由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径不对。解决方法就是卸载hexo-asset-image插件，重新安装已经修改过得新插件npm install https://github.com/7ym0n/hexo-asset-image --save 安装成功之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 这就有点不爽了，哪里出问题了呢，还是用浏览器调试，发现图片的路径依然不对，而且第二步更新hexo-asset-image插件一点作用也没起，路径纹丝没动，还是http://onzxgway.github.io/io//ReferenceCount.png，漫长的调试中…，最后发现是我自己犯了一个低级错误，我在博客根目录下安装了hexo-asset-image插件，又在博客的同级目录下也安装了hexo-asset-image插件，我卸载更新的是博客的同级目录下的插件，而真正起作用的根目录下的插件并没有卸载更新，所以最终生成的页面没有任何改变，吐血，因为这个疏忽，多耗费了我两个小时的时间，下次一点要头脑清晰，思路明捷去作业。","categories":[],"tags":[]}],"categories":[],"tags":[]}