{"meta":{"title":"朱献国的博客","subtitle":"","description":"","author":"朱献国","url":"http://onzxgway.github.io","root":"/"},"pages":[],"posts":[{"title":"iOS并发编程进阶","slug":"Multi-threading-2","date":"2018-10-16T13:00:50.000Z","updated":"2020-10-18T09:00:15.191Z","comments":true,"path":"2018/10/16/Multi-threading-2/","link":"","permalink":"http://onzxgway.github.io/2018/10/16/Multi-threading-2/","excerpt":"","text":"NSThread需求一：用NSThread实现三个线程任务A、B、C，它们结束之后，再执行D、E任务。思路：用KVO监听NSThread实例的isFinished属性。 1demo 需求二：把有三个参数的函数放在子线程执行。 1NSThread暂时实现不了。 NSOperation需求一：用NSOperation实现三个线程任务A、B、C，它们结束之后，再执行D、E任务。 方式一：先执行封装了A + B + C操作的NSBlockOperation，KVO监听属性finished=YES时，再执行封装了D + E操作的NSBlockOperation对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// NSBlockOperation- (void)demo &#123; // 任务 NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work A done.&quot;, [NSThread currentThread]); &#125;]; void(^task)(void) = ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work B done.&quot;, [NSThread currentThread]); &#125;; [blockOperation addExecutionBlock:task]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work C done.&quot;, [NSThread currentThread]); &#125;]; // 监听NSOperation状态 [blockOperation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil]; // 队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:blockOperation];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;finished&quot;] &amp;&amp; [change valueForKey:NSKeyValueChangeNewKey]) &#123; [self performMehtod]; &#125;&#125;- (void)performMehtod &#123; NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work D done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work E done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation start];&#125; log信息显示如下： 12345&lt;NSThread: 0x600001944240&gt;&#123;number = 3, name = (null)&#125; work A done.&lt;NSThread: 0x600001960100&gt;&#123;number = 8, name = (null)&#125; work B done.&lt;NSThread: 0x600001966180&gt;&#123;number = 9, name = (null)&#125; work C done.&lt;NSThread: 0x600001944240&gt;&#123;number = 3, name = (null)&#125; work D done.&lt;NSThread: 0x600001960100&gt;&#123;number = 8, name = (null)&#125; work E done. 方式二：使用操作依赖功能，依赖的底层实现就是基于KVO的。 1234567891011121314151617181920212223242526272829303132333435363738// NSBlockOperation- (void)demo &#123; // 任务 NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work A done.&quot;, [NSThread currentThread]); &#125;]; void(^task)(void) = ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work B done.&quot;, [NSThread currentThread]); &#125;; [blockOperation addExecutionBlock:task]; [blockOperation addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work C done.&quot;, [NSThread currentThread]); &#125;]; NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work D done.&quot;, [NSThread currentThread]); &#125;]; [blockOperation1 addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;%@ work E done.&quot;, [NSThread currentThread]); &#125;]; // 通过操作依赖可以实现先后顺序 [blockOperation1 addDependency:blockOperation]; // 队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:blockOperation]; [queue addOperation:blockOperation1];&#125; log信息显示如下： 12345&lt;NSThread: 0x600000717640&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; work C done.&lt;NSThread: 0x600000760700&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125; work A done.&lt;NSThread: 0x600000776e80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125; work B done.&lt;NSThread: 0x600000776e80&gt;&#123;number &#x3D; 8, name &#x3D; (null)&#125; work D done.&lt;NSThread: 0x600000717640&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125; work E done. 需求二：把有三个参数的函数放在子线程执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// NSInvocationOperation@interface DemoViewController ()@property (nonatomic, strong) NSInvocation *invocation;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self demo];&#125;- (void)demo &#123; // 方法签名 （方法的对象化，包括相关的结构信息：返回值，调用者，方法名，参数） NSMethodSignature *signature = [self methodSignatureForSelector:@selector(name:age:sex:)]; // NSInvocation作用是把方法对象化 self.invocation = [NSInvocation invocationWithMethodSignature:signature]; /** &lt;NSInvocation: 0x604000471ac0&gt; return value: &#123;@&#125; 0x0 target: &#123;@&#125; 0x0 selector: &#123;:&#125; null argument 2: &#123;@&#125; 0x0 argument 3: &#123;@&#125; 0x0 argument 4: &#123;@&#125; 0x0 */ self.invocation.target = self; self.invocation.selector = @selector(name:age:sex:); // 和签名的seletor要对应起来 // 配置参数 NSString *name = @&quot;kobe&quot;; NSString *age = @&quot;40&quot;; NSString *sex = @&quot;man&quot;; [self.invocation setArgument:&amp;name atIndex:2]; [self.invocation setArgument:&amp;age atIndex:3]; [self.invocation setArgument:&amp;sex atIndex:4]; // [self.invocation invoke]; // 调用方法 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithInvocation:self.invocation]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operation]; [operation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil];&#125;- (NSString *)name:(NSString *)name age:(NSString *)age sex:(NSString *)sex &#123; NSLog(@&quot;name: age: sex:%@&quot;, [NSThread currentThread]); return [NSString stringWithFormat:@&quot;%@-%@-%@&quot;, name, age, sex];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;finished&quot;] &amp;&amp; [change valueForKey:NSKeyValueChangeNewKey]) &#123; __unsafe_unretained NSString *returnValue; [self.invocation getReturnValue:&amp;returnValue]; NSLog(@&quot;returnValue:%@&quot;, returnValue); &#125;&#125;@end log信息显示如下： 12name: age: sex:&lt;NSThread: 0x600001b8cd00&gt;&#123;number = 6, name = (null)&#125;returnValue:kobe-40-man 自定义NSOperation12345#import &lt;Foundation/Foundation.h&gt;@interface NSCustomOperation : NSOperation@end 12345678910111213141516171819202122232425262728293031323334353637#import &quot;NSCustomOperation.h&quot;@implementation NSCustomOperation@synthesize finished = _finished;// 主要的业务逻辑放到main处理- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;---%@---&quot;, [NSThread currentThread]); &#125; &#125; _finished = YES;&#125;- (void)start &#123; // 异常处理 if (self.isFinished) &#123; return; &#125; if (self.isExecuting) &#123; return; &#125; [self main];&#125;// NSOperation对象销毁前，finished属性必须为YES，否则不销毁。// 如果 dealloc 没被执行，是因为 _finished = NO- (void)dealloc &#123; NSLog(@&quot;%s&quot;, __func__);&#125;@end 操作依赖可以使任务有序执行。操作依赖更强大的是可以跨队列设置。 123456789101112131415161718192021222324252627- (void)method3 &#123; // 实例化4个操作 NSBlockOperation *operationOne = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationTwo = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationThree = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;3- %@&quot;,[NSThread currentThread]); &#125;]; NSBlockOperation *operationFour = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;4- %@&quot;,[NSThread currentThread]); &#125;]; // 给操作添加依赖 [operationTwo addDependency:operationOne]; [operationThree addDependency:operationTwo]; [operationFour addDependency:operationThree]; // [operationOne addDependency: operationFour]; // 一定不能出现循环依赖 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operationOne]; [[NSOperationQueue mainQueue] addOperation:operationTwo]; [queue addOperation:operationThree]; [queue addOperation:operationFour];&#125; log信息显示如下： 12341- &lt;NSThread: 0x600000931700&gt;&#123;number = 7, name = (null)&#125;2- &lt;NSThread: 0x600000900240&gt;&#123;number = 1, name = main&#125;3- &lt;NSThread: 0x600000948380&gt;&#123;number = 5, name = (null)&#125;4- &lt;NSThread: 0x600000948380&gt;&#123;number = 5, name = (null)&#125; 1-2-3-4，任务是有序执行的，而且操作依赖更强大的是可以跨队列设置，就算第2步的操作是添加在主队列中的，结果依然有效。 线程取消正在运行的线程不能被真正的取消，只是标识状态节点的作用。 GCDdispatch_group_t (队列组)在组内的任务都执行完毕后，再去执行其他操作。简言之，就是可以获取到多个线程操作执行结束的统一时间点。队列组内任务只支持异步执行。 方式一： 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.test&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.abc&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.abcd&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block1 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_block_t block2 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_block_t block3 = ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;; dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue1, block1); dispatch_group_async(group, queue2, block2); dispatch_group_async(group, queue3, block3); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600003fc40c0&gt;&#123;number = 7, name = (null)&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600003fe8040&gt;&#123;number = 9, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600003fccc40&gt;&#123;number = 10, name = (null)&#125;----执行最后的汇总任务---当前线程&lt;NSThread: 0x600003fa8280&gt;&#123;number = 1, name = main&#125; 方式二： 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); // 组内任务数加一 dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); // 组内任务数减一 &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]); dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125;__----执行第二个任务---当前线程&lt;NSThread: 0x600002f7cc00&gt;&#123;number = 8, name = (null)&#125;----执行第一个任务---当前线程&lt;NSThread: 0x600002f55540&gt;&#123;number = 3, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002f78800&gt;&#123;number = 9, name = (null)&#125;----执行最后的汇总任务---当前线程&lt;NSThread: 0x600002f14400&gt;&#123;number = 1, name = main&#125; dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1。dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。当group中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。 和内存管理的引用计数类似，我们可以假设group也持有一个整形变量，当调用enter时计数加1，调用leave时计数减1，当计数为0时会调用dispatch_group_notify 以上两种基本使用方式注意事项：添加到队列中的任务，必须是同步的，如果再开启新线程，group会失效。如果一定要开启新线程，就搭配信号量使用，如下方式： 方式三： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); // 组内任务数加一 dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); // 组内任务数减一 &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [self network]; dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;----执行最后的汇总任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125;- (void) network &#123; NSString *urlstr = @&quot;https://www.xxx.com&quot;; NSURL *url = [NSURL URLWithString:urlstr]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; // 信号量：异步变同步。 dispatch_semaphore_t sema = dispatch_semaphore_create(0); NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSDictionary *infoDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;%@_%@&quot;,[NSThread currentThread], infoDict.class); dispatch_semaphore_signal(sema); &#125;]; [task resume]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125;__&lt;NSThread: 0x600003687b00&gt;&#123;number = 9, name = (null)&#125;___NSDictionaryI&lt;NSThread: 0x600003687b00&gt;&#123;number = 9, name = (null)&#125;___NSDictionaryI&lt;NSThread: 0x600003687a40&gt;&#123;number = 10, name = (null)&#125;___NSDictionaryI----执行最后的汇总任务---当前线程&lt;NSThread: 0x6000036d8500&gt;&#123;number = 1, name = main&#125; dispatch_semaphore_t(信号量)信号量，相当于NSOperationQueue中最大并发数的功能，用来控制线程的数量。示例一： 123456789101112131415161718192021222324252627282930313233// 信号量可以理解为最大并发数 具备异步变同步的功能- (void)demo &#123; // create的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 任务1 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 1&quot;); sleep(1); NSLog(@&quot;complete task 1&quot;); dispatch_semaphore_signal(semaphore); &#125;); // 任务2 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 2&quot;); sleep(1); NSLog(@&quot;complete task 2&quot;); dispatch_semaphore_signal(semaphore); &#125;); // 任务3 dispatch_async(quene, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 3&quot;); sleep(1); NSLog(@&quot;complete task 3&quot;); dispatch_semaphore_signal(semaphore); &#125;);&#125; log信息显示如下： 123456run task 1run task 2complete task 2complete task 1run task 3complete task 3 示例二： 1234567891011121314151617181920212223242526272829303132333435363738- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); // 创建信号量，参数：信号量的初值，如果小于0则会返回NULL dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----结束执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----结束执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;----开始执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----结束执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345678__BEGIN:&lt;NSThread: 0x600002d5c140&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002d5c140&gt;&#123;number = 1, name = main&#125;__----开始执行第二个任务---当前线程&lt;NSThread: 0x600002d18980&gt;&#123;number = 4, name = (null)&#125;----结束执行第二个任务---当前线程&lt;NSThread: 0x600002d18980&gt;&#123;number = 4, name = (null)&#125;----开始执行第一个任务---当前线程&lt;NSThread: 0x600002d01580&gt;&#123;number = 7, name = (null)&#125;----结束执行第一个任务---当前线程&lt;NSThread: 0x600002d01580&gt;&#123;number = 7, name = (null)&#125;----开始执行第三个任务---当前线程&lt;NSThread: 0x600002d62300&gt;&#123;number = 6, name = (null)&#125;----结束执行第三个任务---当前线程&lt;NSThread: 0x600002d62300&gt;&#123;number = 6, name = (null)&#125; dispatch_barrier_async(栅栏)dispatch_barrier_async 相当于一个分界线，分界线前面任务先执行，分界线里面的任务再执行，分界线后面的任务最后执行。（栅栏内部队列，可以看成串行的，依序执行） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)demo &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.test.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;----执行第一个写入任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----执行第二个写入任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----等待前面的任务完成 一阶段---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_barrier_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----等待前面的任务完成 二阶段---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; // 第一个读取任务 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;----执行第一个读取任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; // 第二个读取任务 [NSThread sleepForTimeInterval:3]; NSLog(@&quot;----执行第二个读取任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]); &#125; log信息显示如下： 12345678__BEGIN:&lt;NSThread: 0x600001ac0400&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600001ac0400&gt;&#123;number = 1, name = main&#125;__----执行第二个写入任务---当前线程&lt;NSThread: 0x600001aa6c40&gt;&#123;number = 7, name = (null)&#125;----执行第一个写入任务---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----等待前面的任务完成 一阶段---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----等待前面的任务完成 二阶段---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----执行第一个读取任务---当前线程&lt;NSThread: 0x600001aa6ec0&gt;&#123;number = 8, name = (null)&#125;----执行第二个读取任务---当前线程&lt;NSThread: 0x600001aa6c40&gt;&#123;number = 7, name = (null)&#125; 【dispatch_barrier_async 与 dispatch_barrier_sync异同】 共同点： 等待在它前面插入队列的任务先执行完，等待他们自己的任务执行完再执行后面的任务不同点： 1、dispatch_barrier_sync将自己内部的任务插入到队列的之后，需要把该任务执行结束之后才会继续插入后面的任务。 2、dispatch_barrier_async将自己内部的任务插入到队列之后，不会去执行任务，它会继续把后面的任务插入到队列。 用途：在多个异步操作完成之后，统一的对非线程安全的对象进行更新操作 1demo dispatch_apply(重复)dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API，将任务按照指定的次数追加到队列中，并等待全部队列任务执行结束。 123456789101112131415- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); /** 同步队列组 @param 5 指定次数 @param queue 追加对象的Dispatch Queue @param count 带有参数的Block, count的作用是为了按执行的顺序区分各个Block */ dispatch_apply(5, queue, ^(size_t count) &#123; NSLog(@&quot;%zu&quot;, count); &#125;); NSLog(@&quot;Done!&quot;);&#125; log信息显示如下： 12345601234Done! 如果在for循环中使用 dispatch_async 需要管理好线程的数量，否则会发生线程爆炸或死锁。而dispatch_apply是由GCD管理并发的，可以避免上述情况发生。 123456789101112131415161718- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); // // 有问题的情况，可能会死锁// for (int i = 0; i &lt; 999 ; i++) &#123;// dispatch_async(queue, ^(size_t i)&#123;// NSLog(@&quot;wrong %zu&quot;, i);// &#125;);// &#125; // 正确方式 dispatch_apply(999, queue, ^(size_t i)&#123; NSLog(@&quot;correct %zu&quot;, i); &#125;); // 等待上述任务执行结束之后，当前线程才会继续往下执行。 NSLog(@&quot;Done!&quot;);&#125; dispatch_after(延后)123456789101112- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.timer.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@&quot;start:%@&quot;, [NSThread currentThread]); dispatch_after(1, queue, ^&#123; NSLog(@&quot;dispatch_after:%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;end&quot;); &#125;);&#125; log信息显示如下： 123start:&lt;NSThread: 0x6000020a1d80&gt;&#123;number = 7, name = (null)&#125;enddispatch_after:&lt;NSThread: 0x600002081380&gt;&#123;number = 8, name = (null)&#125; 注意：如果任务在子线程中执行，那么一定要开启该子线程的消息循环Runloop，此定时任务才会有效执行。 dispatch_once代码从程序启动就执行一次 12345static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; //要执行的代码块 //只会被执行一次&#125;); 实现机制：在静态区分配内存给onceToken变量，并且初始化为0(静态区变量为全局变量，且直到程序退出才会释放onceToken)，线程执行到这里时，判断onceToken的值为0，就去执行block，并且onceToken的值更改为-1，第二次再有线程来执行时，判断onceToken的值为-1，就不执行block。 苹果推荐单例的创建方式为： 12345678+ (instancetype)sharedSingleton &#123; static id instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; dispatch_queue_t激活使用DISPATCH_QUEUE_CONCURRENT_INACTIVE创建的队列，是未激活队列，在使用的时候，需要手动激活。 1234567- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.active.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT_INACTIVE); dispatch_async(queue, ^&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;); dispatch_activate(queue);&#125; log信息显示如下： 1&lt;NSThread: 0x600000178080&gt;&#123;number = 3, name = (null)&#125; dispatch_source用dispatch_source实现定时器。 123456789101112131415dispatch_source_t source;- (void)timeSource &#123; // 1 创建一个队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.source.serial&quot;, DISPATCH_QUEUE_SERIAL); // io source关联到队列 source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 配置soure的时间 dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 1, 1); // 配置source的处理事件 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;soure_event:==%@&quot;, [NSThread currentThread]); &#125;); // 开启定时器 dispatch_resume(source);&#125; dispatch_async_f12345678void testMethod()&#123; NSLog(@&quot;testMethod::--&gt;%@&quot;, [NSThread currentThread]);&#125;- (void)demo &#123; dispatch_queue_t queue = dispatch_queue_create(&quot;com.f.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async_f(queue, nil, testMethod);&#125; log信息显示如下： 1testMethod::--&gt;&lt;NSThread: 0x600003c8fa00&gt;&#123;number = 3, name = (null)&#125; 僵死线程先执行如下代码 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; NSLog(@&quot;%s&quot;, __func__);&#125; log信息显示如下： 12startend 根据log信息可知，method_one函数没有被执行。原因：子线程执行完ThreadOne函数之后，任务就完成了，被回收了。不会再等待2秒钟之后去执行method_one函数了。解决方式：开启runloop，保活线程。如下所示 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; NSPort *port = [[NSPort alloc] init]; [[NSRunLoop currentRunLoop] addPort:port forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; NSLog(@&quot;%s&quot;, __func__);&#125; log信息显示如下： 12start-[ViewController method_one] 根据log信息可知，method_one函数被执行了。但是有个新问题产生了，程序始终没有执行到NSLog(@”end”)代码，造成了内存泄露。解决方式：在method_one函数中，关闭runloop。如下所示 1234567891011121314151617181920212223242526272829303132@interface ViewController () &#123; NSPort *_port;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadOne) toTarget:self withObject:nil];&#125;- (void)ThreadOne &#123; NSLog(@&quot;start&quot;); [self performSelector:@selector(method_one) withObject:nil afterDelay:2]; _port = [[NSPort alloc] init]; [[NSRunLoop currentRunLoop] addPort:_port forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)method_one &#123; [[NSRunLoop currentRunLoop] removePort:_port forMode:NSDefaultRunLoopMode]; NSLog(@&quot;%s&quot;, __func__);&#125;@end log信息显示如下： 123start-[ViewController method_one]end 在A线程中开启定时器，必须在A线程中关闭，否则会造成内存泄露。 123456789101112131415161718192021222324252627282930313233343536@interface ViewController () &#123; NSTimer *_timer;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [NSThread detachNewThreadSelector:@selector(ThreadTwo) toTarget:self withObject:nil];&#125;- (void)ThreadTwo &#123; NSLog(@&quot;start&quot;); _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(stopTimer) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;end&quot;);&#125;- (void)stopTimer &#123; NSLog(@&quot;stopTimer&quot;); static int count = 0; count++; if (count &gt; 5) &#123; [_timer invalidate]; &#125; &#125;@end log信息显示如下： 12345678startstopTimerstopTimerstopTimerstopTimerstopTimerstopTimerend","categories":[],"tags":[]},{"title":"Block基础","slug":"Block基础","date":"2017-11-08T12:53:40.000Z","updated":"2020-10-13T10:29:30.974Z","comments":true,"path":"2017/11/08/Block基础/","link":"","permalink":"http://onzxgway.github.io/2017/11/08/Block%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是blockblock就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。 block内存分布三种类型block在Objective-C语言中，有三种类型的block。1，__NSGlobalBlock__ 保存在全局区，不会访问任何外部变量。2，__NSStackBlock__ 保存在栈中，当函数返回时会被销毁。3，__NSMallocBlock__ 保存在堆中，当引用计数为0时会被销毁。 在MRC模式下，运行如下代码，从log中可以证明存在三种类型的block。 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; // 一 void(^globalBlock)(void) = ^&#123; NSLog(@&quot;hello world!&quot;); &#125;; NSLog(@&quot;%s&quot;, object_getClassName(globalBlock)); // 二 NSInteger i = 10; void(^stackBlock)(void) = ^&#123; NSLog(@&quot;stackBlock %zd&quot;, i); &#125;; NSLog(@&quot;%s&quot;, object_getClassName(stackBlock)); // 三 void(^mallocBlock)(void) = [stackBlock copy]; NSLog(@&quot;%s&quot;, object_getClassName(mallocBlock)); &#125; log信息： 123__NSGlobalBlock____NSStackBlock____NSMallocBlock__ 对三种类型的block实例发送消息 如何判断block类型我们知道有三种类型block，那么如何判断一个block是属于哪种的呢？依据如下规则即可。 没有使用外部变量的（外部变量不包括全局变量和静态变量）block，在全局区，属于__NSGlobalBlock__。 12345678910111213141516171819202122232425262728293031323334// 在MRC模式下运行typedef void(^TestBlock)(void);int globalVal = 666;static int staticVal = 888;@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _strongBlock = ^&#123; NSLog(@&quot;hello world!&quot;); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, globalVal); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, staticVal); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); NSLog(@&quot;_weakBlock %s&quot;, object_getClassName(_weakBlock));&#125;@end log信息显示如下： 123_strongBlock __NSGlobalBlock___copyBlock __NSGlobalBlock___weakBlock __NSGlobalBlock__ 使用外部变量的（外部变量不包括全局变量和静态变量）block，在栈区，属于__ NSStackBlock__。 123456789101112131415161718192021222324252627282930313233// 在MRC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int tempV = 100; _strongBlock = ^&#123; NSLog(@&quot;_strongBlock %d&quot;, tempV); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, tempV); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, tempV); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); NSLog(@&quot;_weakBlock %s&quot;, object_getClassName(_weakBlock));&#125;@end log信息显示如下： 123_strongBlock __NSStackBlock___copyBlock __NSStackBlock___weakBlock __NSStackBlock__ 对栈区block进行copy之后，得到新的block，在堆区，属于__ NSMallocBlock__。 123456789101112131415161718192021222324252627282930313233// 在MRC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@property(nonatomic, weak)TestBlock weakBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int tempV = 100; _strongBlock = ^&#123; NSLog(@&quot;_strongBlock %d&quot;, tempV); &#125;; _copyBlock = ^&#123; NSLog(@&quot;_copyBlock %d&quot;, tempV); &#125;; _weakBlock = ^&#123; NSLog(@&quot;_weakBlock %d&quot;, tempV); &#125;; NSLog(@&quot;_strongBlock copy %s&quot;, object_getClassName([_strongBlock copy])); NSLog(@&quot;_copyBlock copy %s&quot;, object_getClassName([_copyBlock copy])); NSLog(@&quot;_weakBlock copy %s&quot;, object_getClassName([_weakBlock copy]));&#125;@end log信息显示如下： 123_strongBlock copy __NSMallocBlock___copyBlock copy __NSMallocBlock___weakBlock copy __NSMallocBlock__ ARC对block的影响ARC会自动把strong类型且捕获外部变量的block从栈copy到堆中。 1234567891011121314151617181920212223242526272829303132333435// 在ARC模式下运行typedef void(^TestBlock)(void);@interface DemoViewController ()@property(nonatomic, strong)TestBlock strongBlock;@property(nonatomic, copy)TestBlock copyBlock;@end@implementation DemoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger i = 10; // _strongBlock = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_strongBlock %s&quot;, object_getClassName(_strongBlock)); // _copyBlock = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_copyBlock %s&quot;, object_getClassName(_copyBlock)); // void(^_localBlock)(void) = ^&#123; NSLog(@&quot;%zd&quot;, i); &#125;; NSLog(@&quot;_localBlock %s&quot;, object_getClassName(_localBlock)); &#125;@end log信息显示如下： 123_strongBlock __NSMallocBlock___copyBlock __NSMallocBlock___localBlock __NSMallocBlock__ 根据log信息可以判断strong、copy修饰的或者局部变量引用的block实例，都属于__NSMallocBlock__。 原因：_strongBlock、_copyBlock和_localBlock都使用了外部变量，属于栈区block，但是在ARC模式下，被strong或copy等非weak修饰符修饰的栈区block，会自动copy到堆区，变成__NSMallocBlock__。（block实例赋值给局部变量_localBlock，就相当于被变量强引用=strong，所以_localBlock是__NSMallocBlock__） 变量的复制对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的，如果对象是引用类型，则block会将其引用计数加一 ，如下图所示：对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的，如下图所示：","categories":[],"tags":[]},{"title":"内存管理（下）","slug":"memory-management-2","date":"2017-09-18T10:32:14.000Z","updated":"2020-10-18T09:00:11.614Z","comments":true,"path":"2017/09/18/memory-management-2/","link":"","permalink":"http://onzxgway.github.io/2017/09/18/memory-management-2/","excerpt":"","text":"在开始之前先思考一个问题，就是为什么需要内存管理？iOS系统会在程序退出以后，回收其所有内存，那么开发者还有必要在程序运行过程中去管理内存吗？答案是肯定的，1，程序运行的过程中，如果不去管理内存，可能会发生内存泄露，而内存泄露会导致程序运行出错甚至直接崩溃闪退。虽然有些情况下的内存泄露，并不会导致上述状况，2，严格的内存管理可以让应用更加合理、高效的使用有限的硬件条件，提高应用程序的性能。 内存泄露什么是内存泄露内存泄露指一个对象或者变量在使用完成后没有及时释放掉，一直占用着内存，直到应用停止。 哪些情况下会发生内存泄露iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。所以如果发生了内存泄露，肯定与引用计数有关。1，引用计数的天生缺陷是循环引用，以下是项目中常见的循环引用： delegate：xxxx block：xxxx controller+view：xxxx NSTimer：xxxx 2，错误使用手动引用计数 底层Core Foundation对象，需要手动去管理，如果创建使用完成后，没有调用CFRelease方法去释放的话，也会造成内存泄露。3，大次数循环内存暴涨 123 while (true) &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init];&#125; 该循环内产生大量的临时对象，直到循环结束才释放，可能导致内存泄露，解决方法是把循环体放到自动释放池中，及时释放占用内存大的临时变量。 123456 while (true) &#123; @autoreleasepool &#123; UIViewController *ctr &#x3D; [[UIViewController alloc] init]; &#125;&#125;4，项目中的第三方导致的内存泄露。 到github上查看三方的Issues，看是否有相关的问答。或者通过网络、书籍、前辈查询相关解决方案。 5，子线程中使用延时操作或者使用定时器不当，也会造成内存泄露。具体请看并发编程进阶中说明。 如何检测内存泄露Xcode集成功能Analyze静态分析在程序没运行的时候，通过工具对代码直接进行分析，根据代码的上下文的语法结构，让编译器分析内存情况, 检查是否有内存泄露。 主要分析以下四种问题：1，逻辑错误：访问空指针或未初始化的变量等；2，内存管理错误：如内存泄漏等；3，声明错误：从未使用过的变量；4，Api调用错误：未包含使用的库和框架。缺点：静态内存分析由于是编译器根据代码进行的判断，做出的判断不一定会准确，因此如果遇到提示, 应该去结合代码上文检查一下。 在Xcode的菜单栏选择Product -&gt; Analyze启动静态分析。逻辑错误：The ‘viewDidLoad’ instance method in UIViewController subclass ‘ViewController’ is missing a [super viewDidLoad] call解决办法：添加[super viewDidLoad];内存管理错误：内存泄漏（Object leaked: object allocated and stored into ‘cfStr’ is not referenced later in this execution path and has a retain count of +1）声明错误：从未使用过的变量(Value stored to ‘xxx’ during its initialization is never read)。如下图所示解决办法：把未使用的变量删除 Instruments中的Leaks动态分析Xcode自带Instruments工具集可以很方便的检测内存泄露，为了测试效果，在一个测试使用的ViewController中填写如下代码，该代码中first和second互相强引用了对方，构成了循环引用造成内存泄露。 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *first = [NSMutableArray array]; NSMutableArray *second = [NSMutableArray array]; [first addObject:second]; [second addObject:first];&#125; 在Xcode的菜单栏选择Product -&gt; Profile进入Instruments工具集，然后选择leaks，再单击右下角的Choose按钮开始检测。进入检测页面，如下图所示选择好了检测设备和检测项目，点击开始检测按钮，这时候iOS应用会运行起来，由于Leaks是动态监测，所以需要一边操作APP，一边观察Leaks的变化，稍等几秒钟，就可以看到Instruments检测到了我们这次内存泄露，点击暂停检测(也可继续检测)，Instruments会用一个红色的叉叉来表示一次内存泄露的产生，如下图所示。暂停检测之后，点击红色叉（内存泄漏点），Leaks-&gt;选择Call Tree，如下图所示。点击页面底部栏的Call Tree(此处指的是Xcode8以上, Xcode7在右下角)，选择Invert Call Tree和Hide System Libraries，如下图所示。此时界面显示是就是内存泄漏的代码部分，双击代码行，或者右键选择reveal in Xcode即可定位到内存泄漏的代码行。我们也可以切换到Leaks这栏，单击Cycles&amp;Roots，就可以以图的形式显示出来循环引用。这样就可以很方便的找到循环引用对象了。定位到具体错误代码处，剩下的工作就需要开发者自己去完成了。 第三方工具MLeaksFinder点击查看具体原理，这里我只讨论它的优点： 使用简单，不侵入业务逻辑代码，不用打开 Instruments 不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测 内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了） 精准，能准确地告诉你哪个对象没被释放 FBRetainCycleDetector能够检测指定对象的引用情况，并把所存在的引用循环中各对象和引用在终端进行打印。 Facebook开源的循环引用检测工具 FBRetainCycleDetector。当传入内存中的任意一个OC对象，FBRetainCycleDetector会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。我们知道，很多循环引用是 block 的使用不当造成的。而 FBRetainCycleDetector 最大的技术亮点，正在于如何找出一个 block 的所有强引用对象。 然而，FBRetainCycleDetector 的使用存在两个问题：1，需要找到候选的检测对象。2，检测循环引用比较耗时。 正是由于这两个问题，FBRetainCycleDetector 通常是结合其它工具一起使用，通过其它工具先找出候选的检测对象，然后进行有选择的检测。当 MLeaksFinder 与 FBRetainCycleDetector 结合使用时，正好能达到很好的效果。我们先通过 MLeaksFinder 找到内存泄漏的对象，然后再过FBRetainCycleDetector检测该对象有没有循环引用即可。 内存警告这篇文章对内存警告介绍比较详细，可以仔细阅读。","categories":[],"tags":[]},{"title":"内存管理（上）","slug":"memory-management-1","date":"2017-08-27T07:34:47.000Z","updated":"2020-10-06T16:05:40.380Z","comments":true,"path":"2017/08/27/memory-management-1/","link":"","permalink":"http://onzxgway.github.io/2017/08/27/memory-management-1/","excerpt":"","text":"关于iOS开发中内存管理的知识脉络，我依据自己的思路整理了一下，根据管理的是哪个区域的内存-&gt;管理的方式-&gt;内存泄露-&gt;内存警告线索来展开。具体的每个步骤里面会有更多的关联知识点，但是能力有限，写作匆忙，有瑕疵错误的地方，多多包涵。 内存分区内存区域划分程序如果想要执行，第一步就需要从磁盘加载到内存中。运行过程中内存的分区是怎样的呢，如下图所示。1，栈区（stack）由编译器自动分配并释放的变量存储区。存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。［先进后出］2，堆区（heap）由程序员申请和释放，如果程序员不释放，程序结束时，会由OS回收，比如在iOS中alloc都是存放在堆中。优点是灵活方便，数据适应面广泛，但是效率有一定降低。3，BSS区 全局变量和静态变量的存储是放在一起的，存放未初始化的全局变量和静态变量的区域，程序结束后有系统释放。4，数据区 存放初始化的全局变量和静态变量的区域，程序结束后由系统释放。5，代码区 存放函数的二进制代码，程序结束后由系统释放。 堆和栈的区别 管理方式：堆空间的申请释放工作由程序员控制，容易产生内存泄漏。而栈是由编译器自动管理，无需我们手工控制。 空间大小：堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址，堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间较灵活，也较大。栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。 内存碎片：对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出。 分配方式：堆都是动态分配的。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈由系统自动分配，速度较快，不会产生内存碎片。但程序员是无法控制的。堆是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便。 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 由以上的内存分区知识点可知，堆区内存是由程序员管理，其他区域全部是由编译器自动管理。所以iOS开发过程中管理的是堆区内存。 引用计数iOS开发，不管是Objective-C语言还是Swift语言，其内存管理的方式都是基于引用计数的。本段博文就是讲解引用计数的原理及特点。 Objective-C和Swift语言内存管理的方式是引用计数，Java和C#语言的内存管理方式是GC垃圾回收机制(Garbage Collection) 什么是引用计数、引用计数原理引用计数（Reference Count）是一种简单有效的管理对象生命周期的方式。它的原理是：当我们创建一个新对象的时候，它的引用计数为1，当有一个新的指针指向该对象时，我们把其引用计数加1，当某个指针不再指向该对象时，我们将其引用计数减1，当对象的引用计数为0的时候，说明不再被任何指针引用了，我们可以将对象销毁，回收内存。 引用计数的分类1，手动引用计数手动引用计数（Manual Reference Count，简称MRC），在此模式下，对象的生命周期需要开发者手动调用retain,release等方法去管理。运行以下代码，可以通过log看到引用计数的变化。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; &#x2F;&#x2F; Override point for customization after application launch. NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); NSObject *antherObj &#x3D; [obj retain]; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [antherObj release]; antherObj &#x3D; nil; NSLog(@&quot;Reference Count &#x3D; %lu&quot;, obj.retainCount); [obj release]; &#x2F;&#x2F; 到这里时，obj的内存被释放 return YES;&#125; 运行结果如下： Reference Count = 1 Reference Count = 2 Reference Count = 1 上述代码中NSObject实例的retainCount属性、retain和release方法只在MRC的模式下才能够调用。现在新建的工程默认都是ARC模式，允许以文件为单位关闭ARC模式，开启MRC模式。具体方法就是通过编译列表找到目标文件，在文件后面加上-fno-objc-arc的编译参数即可。 2，自动引用计数自动引用计数（Automatic Reference Count，简称ARC），是苹果在WWDC 2011大会上提出的用于管理内存的技术。在此模式下，编译器会自动添加内存管理的方法，让开发者从繁琐的内存管理中解放出来。 过度依赖ARC问题1.ARC技术能够解决iOS开发中90%的内存管理问题，但是另外10%是需要开发者自己处理的。这主要与底层Core Foundation对象交互的那部分，因为Core Foundation对象不在ARC的管理范畴，所以需要开发者去维护这些对象的引用计数。2.没有正确使用Block导致的循环引用的问题。如果过度依赖ARC，不了解引用计数原理，那面对以上两种情况，会显得一筹莫展。 3，Core Foundation对象内存管理底层Core Foundation对象，大多数以XxxCreateWithXxx形式创建。例如 1234&#x2F;&#x2F; 创建一个CFStringRef对象CFStringRef cfStr &#x3D; CFStringCreateWithCString(kCFAllocatorDefault, &quot;Hello World&quot;, kCFStringEncodingUTF8);&#x2F;&#x2F; 创建一个CFStringRef对象CTFontRef font &#x3D; CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, 16.0, NULL); 对于这些对象引用计数的修改，要相应的使用CFRetain和CFRelease方法。 12345&#x2F;&#x2F; 引用计数加1CFStringRef newStr &#x3D; CFRetain(cfStr); &#x2F;&#x2F; 引用计数减1CFRelease(newStr); CFRetain和CFRelease方法，我们直观的认为，它们与Objective-C中的retain和release方法等价。除此之外，还有另外一个问题需要解决。在ARC下，有时候需要将一个Core Foundation对象转换成一个Objective-C对象，这个时候我们需要告诉编译器，转换过程中引用计数需要如何调整。这就引入了与bridge相关的关键字，以下是这些关键字的说明： __bridge 只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_retained 类型转换后，将相关对象的引用计数加1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_transfer 类型转换后，将该对象的引用计数交给ARC管理，原来的Core Foundation对象在不用时，不需要调用CFRelease方法。 根据具体业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objective-C对象相对转换的问题了。 引用计数的优点简单有效。 为什么需要引用计数？在没有引用计数的情况下，一般内存管理的原则是“谁申请谁释放”，假如对象A生成了一个对象M，需要调用对象B，将对象M作为参数传递过去。那么对象A就需要在对象B不再需要对象M的时候，将对象M销毁。但是对象B可能只是临时用一下对象M，也可能觉得对象M很重要，将它设置成自己的一个成员变量，在这种情况下，什么时候销毁对象M就成了一个难题。 对于这种情况，有一个暴力的做法，就是对象A在调用完对象B之后，马上就销毁参数对象M，然后对象B需要将参数另外复制一份，生成另一个对象M2，然后自己管理对象M2的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。 还有另外一种方法，就是对象A在构造完对象M之后，始终不销毁对象M，由对象B来完成对象M的销毁工作。如果对象B需要长时间使用对象M，就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好的解决了对象复制的问题，但是它强烈依赖于A、B两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象M的申请是在对象A中，释放在对象B中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象B需要向对象C传递对象M，那么这个对象在对象C中又不能让对象C管理。所以这种方式带来的复杂性更大，更不可取。 所以引用计数很好地解决了这个问题，在参数M的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加1，使用完了之后再把引用计数减1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便的享受到共享对象带来的好处。 引用计数的缺点引用计数这种管理内存的方式虽然简单有效，但是有一个比较大的瑕疵，就是它不能很好的解决循环引用的问题。如下图所示对象A和对象B，相互引用对方作为自己的成员变量，只有自己销毁时，才会将成员变量的引用计数减1。因为对象A的销毁依赖于对象B的销毁，而对象B的销毁又依赖于对象A的销毁，这样就造成了循环应用（reference cycle）的问题。实际项目中不止两个对象存在循环引用问题，多个对象间依次持有，形成一个环状，也会造成循环引用，而且环状越大越难发现。 解决方式：1.明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用。2.弱应用的办法。弱引用虽然持有对象，但是并不增加引用计数。","categories":[],"tags":[]},{"title":"iOS并发编程基础","slug":"Multi-threading-1","date":"2017-03-22T10:21:56.000Z","updated":"2020-10-18T07:20:20.635Z","comments":true,"path":"2017/03/22/Multi-threading-1/","link":"","permalink":"http://onzxgway.github.io/2017/03/22/Multi-threading-1/","excerpt":"","text":"并发 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种**API(pthread,NSThread,GCD,NSOperation)**用于并发编程。本文以讲解四种API的使用方法为切入点，带你了解多线程的全貌。 在学习并发编程之前，首先我们要知道线程的概念，以及线程的一些相关基础知识，这是学习并发编程的基础。 什么是线程线程（thread）是进程的基本单位，一个进程包含一个或多个线程（至少包含一个），操作系统的调度器可以直接调度线程。所有的并发编程API都是构建在线程上的。 线程的状态 新建：线程对象在内存中被创建出来。 就绪：除了CPU以外的所有资源都已分配好了，等待CPU调度。（已经加入可调度线程池中） 运行：CPU正在运行该线程。（当CPU切换执行其它线程的时候，当前线程退回到就绪状态） 阻塞：除了CPU以外，还有其它资源没有分配，（阻塞状态的线程，被移出了可调度线程池） 死亡：线程被销毁，占用的内存空间被释放。 并发编程的四种API介绍pthreadpthread(posix线程) 是一套纯C的API，平时几乎不会使用，如果没有兴趣可以不用了解，当然如果想多掌握一些的话，可以继续往下阅读。 1234567891011121314如何使用：1，导入头文件 #import &lt;pthread.h&gt;2，调用函数 int pthread_create(pthread_t * __restrict,pthread_attr_t * __restrict,void * (*) (void *),void * __restrict);&#x2F;*参数解释 返回值是0 表示创建线程成功 非0表示创建线程失败 1,pthread_t * 线程的标示 2,pthread_attr_t 线程的属性 3,void* (*) (void *) 返回值 函数名 参数 函数签名 void * 约等于OC中的id任意类型 4,void * 给函数的参数 *&#x2F; NSThreadNSThread是pthread面向对象的封装。在面向对象的编程环境中，看起来更加亲切，使用也更加顺手。NSThread实例是线程对象，对应一个线程。 一 如何使用： 【类方法/自动开启】优点：使用简单，线程创建好之后处于就绪(runnable)状态，CPU可直接调度。缺点：无法拿到线程对象本身做更详细的设置。 12+ (void)detachNewThreadWithBlock:(void (^)(void))block;+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument; 【实例方法/手动开启】优点：可以获取到线程对象，做更详细的设置。（设置线程优先级、线程名称等）缺点：线程创建好以后处于新建（new）状态，需要手动调用start/main方法进入就绪(runnable)状态，没有类方法使用简单。 12345- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;- (instancetype)initWithBlock:(void (^)(void))block;- (void)start; // start方法在子线程执行，不能重复开启（不能调用两遍以上start方法）- (void)main; // main方法在主线程执行，可以重复调用 注意：- (instancetype)init;方法得到的是主线程。 【隐式创建】优缺点和类方法相同 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; 注意：隐式创建方法不属于NSThread，而是属于NSObject的NSThreadPerformAdditions分类。 【自定义】 123第一步：自定义一个线程类。例如XXThread，继承自NSThread类。第二步：在XXThread类中，重写main方法，把需要在后台子线程中执行的代码放进去。第三步：通过alloc+init方法创建XXThread对象，然后调用start方法即可。 二 常见属性： 1234567891011121314151617181920212223// 线程优先级，double类型，取值范围是：0.0~1.0，默认是0.5，1.0表示优先级最高，优先级越高，表示被CPU调度的概率越高。逐渐被废弃，用qualityOfService替代thread.threadPriority// 线程服务质量约等于线程优先级，枚举值，默认是NSQualityOfServiceDefault=-1,优先级最低。iOS8之后比threadPriority好用thread.qualityOfService;// 线程的名称,主线程默认名称是main，子线程默认名称为null,thread.name;// 判断当前线程是否是主线程，只读属性mainThread// 判断当前线程是否正在执行任务，只读属性executing// 判断当前线程是否执行结束，只读属性finished// 判断当前线程是否被取消，只读属性cancelled// 线程在stack栈上占用的存储空间，通常为512kb，线程释放后，空间收回。thread.stackSize; 三 常用方法： 123456789101112131415// 休眠到指定时间点+ (void)sleepUntilDate:(NSDate *)date// 休眠一段时间+ (void)sleepForTimeInterval:(NSTimeInterval)time// 获取当前线程对象[NSThread currentThread];// 获取主线程对象[NSThread mainThread];// 退出线程[NSThread exit];// 如果自定义线程类，把要执行的任务，放在重写的main方法中。- (void)main // thread body method 直接操作线程对象可能引发一个问题，如果你的代码和项目中使用到的框架代码都创建了自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型项目中是一个常见问题。例如：在8核CPU中，你创建了8个线程来发挥CPU性能。然而在这些线程中调用到的框架代码也做了同样的事情（因为框架不知道你也创建了线程），这样就会很快产生成百上千的线程，代码每个部分自身都没有问题，但是最终还是产生了问题。每个线程都会消耗一些内存和内核资源。接下来，我将介绍两个基于队列的并发编程API：GCD和NSOperationQueue，它们是通过管理一个可以协同使用的线程池，来解决上面的问题的。 GCDGCD(Grand Central Dispatch)是一套底层纯C的API，是并发多核的解决方案，其实就是为了让开发者更加容易的使用设备上的多核CPU。 GCD会自动管理线程的生命周期，开发者不用直接和线程打交道，只需要关注队列和任务即可，GCD在系统底层维护了一个线程池，通过统一的管理，来避免开启过多的线程。 在学习GCD编程之前，首先我们要理解队列和任务的概念，这是基础，也是GCD的核心概念。 队列用来存放任务的，先进先出的（FIFO，First in first out)容器就是队列。 12// 队列dispatch_queue_t 队列分为两类：串型队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue），系统提供了一个主队列（特殊的串行队列）和一个全局并发队列。 【串行队列】内部的任务一个接着一个执行，等待上一个任务执行完毕，才会接着执行下一个任务。 12345678// 获取串行队列的方式 1.系统提供 2.手动创建// 1.系统提供dispatch_queue_t queue = dispatch_get_main_queue();// 2.创建一个串行队列// 队列的名称com.app.serial// 队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); 【并发队列】队列内部的多个任务同一时刻执行（并发队列只有在异步执行dispatch_async的时候才有效，底层线程池会提供多个线程同时去执行队列中的任务）。 12345678910// 获取并发队列的方式 1.系统提供 2.手动创建// 1.系统提供// 队列优先级 DISPATCH_QUEUE_PRIORITY_DEFAULT// 第二个参数flags作为保留字段备用，一般都直接填0dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 2.创建一个并发队列// 队列的名称。 作用：可以协助开发调试和崩溃报告分析// 队列的类型，是枚举值。DISPATCH_QUEUE_CONCURRENT表示并发。dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); 【主队列】也叫【全局串行队列】主队列是特殊的串行队列，由系统提供，使用的时候只要去获取即可，无需开发者手动创建，特殊点在于主队列中的任务只能由主线程去执行。 特点：1，主线程正在执行代码暂时不调度任务，等主线程执行结束后再调度任务。这是主队列中同步执行导致死锁的原因。2，UI更新的操作都要放在主线程中处理。 12// 获取系统提供的主队列dispatch_queue_t queue = dispatch_get_main_queue(); 【全局并发队列】全局并发队列，使用的时候去获取即可，无需开发者手动创建。 123456789&#x2F;&#x2F; 获取系统提供的全局并发队列dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);&#x2F;&#x2F; 参数解释1，指定队列的优先级。DISPATCH_QUEUE_PRIORITY_HIGH (2)DISPATCH_QUEUE_PRIORITY_DEFAULT (0)&#x2F;&#x2F; 自定义队列的优先级都是默认优先级DISPATCH_QUEUE_PRIORITY_LOW (-2)DISPATCH_QUEUE_PRIORITY_BACKGROUND (INT16_MIN)2，作为保留字段备用（一般为0) 任务添加到队列中的可执行代码块就是任务。 12&#x2F;&#x2F; 类型dispatch_block_t 注意：dispatch_block_t的定义是typedef void (^dispatch_block_t)(void)，由定义可以看出它本质就是一个无参数无返回值的block。 任务添加到队列的方式方式有两个，同步执行（dispatch_sync）和异步执行（dispatch_async）区别在于是否开启子线程，同步执行不开启子线程在当前线程执行，异步开启子线程。 【同步执行】 12345678// 队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);// 任务dispatch_block_t block = ^ &#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;;dispatch_sync(queue, block); 【异步执行】 123456789// 队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);// 任务dispatch_block_t block = ^ &#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;%@&quot;, [NSThread currentThread]);&#125;; dispatch_async(queue, block); 上面这么写的目的，是帮助理解，在开发中代码要简写。 12345678// 1，创建串行队列dispatch_queue_t queue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);//// 2,异步执行dispatch_async(queue, ^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;); 在了解完GCD的核心基本概念之后，我们学习GCD的使用方法 串型队列的执行【串行队列➕同步执行】 同步执行：不开新线程(在当前线程)。串行队列：任务一次只能执行一个。 12345678910111213141516171819202122232425262728293031323334- (void)syncAndSerial &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); // 第一个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); // 第二个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); // 第三个任务 dispatch_sync(queue, ^&#123; // 这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__ 结论：同步执行 ➕ 串行队列，不开启新线程，在当前线程中依次执行。 【串行队列➕异步执行】 异步执行：开启一个子线程，任务在子线程执行，为什么只开启一个，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务。串行队列：任务一次只能执行一个。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndSerial &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.serial&quot;, DISPATCH_QUEUE_SERIAL); // 第一个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032a2300&gt;&#123;number = 3, name = (null)&#125; 结论：异步执行 ➕ 串行队列，开启一个新线程，任务依次执行。 并发队列的执行【并发队列➕同步执行】 同步执行：不开新线程(在当前线程)。并发队列：多个任务可以同时执行。 123456789101112131415161718192021222324252627282930313233- (void)syncAndConcurrent &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 123456__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__ 结论：执行情况与同步执行 ➕ 串行队列一模一样，不开启新线程，在当前线程中依次执行。 【并发队列➕异步执行】 异步执行：开启多个子线程，任务在子线程执行，具体开启多少个线程是不固定的(线程数，不由我们控制是由gcd来决定的)。并发队列：多个任务可以同时执行。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndConcurrent &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue = dispatch_queue_create(&quot;com.app.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); // 第一个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_async(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x6000032ec0c0&gt;&#123;number = 1, name = main&#125;__----执行第二个任务---当前线程&lt;NSThread: 0x60000328cb40&gt;&#123;number = 11, name = (null)&#125;----执行第三个任务---当前线程&lt;NSThread: 0x6000032bb2c0&gt;&#123;number = 12, name = (null)&#125;----执行第一个任务---当前线程&lt;NSThread: 0x6000032b2380&gt;&#123;number = 8, name = (null)&#125; 结论：开启若干新线程，任务并发执行。 主队列的执行系统已经为我们准备好了2个常用队列，主队列（全局串行队列）和全局并发队列，开发中很多都是使用系统提供的队列，不用自己手动创建 【主队列➕同步执行】 前提：当前在主线程。 12345678910111213141516171819202122232425262728293031323334- (void)syncAndMain &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue &#x3D; dispatch_get_main_queue(); &#x2F;&#x2F; 第一个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第二个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第三个任务 dispatch_sync(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; 结论：在主线程会死锁导致应用crash。注意：当程序执行到这段代码的时候，向主队列中添加一个任务，此时如果主线程要继续往下执行的话，必须要执行刚添加到主队列中的任务，只有把这个任务执行完毕之后，才可以继续，所以现在要等待调度该任务。而主队列有个特点就是只有主线程不忙的时候，才会去调度主线程执行任务，现在的情况是主线程很忙，所以不会去调度任务，一个等待调度任务执行，一个不让去调度任务，最终导致了死锁。 前提：当前在子线程。 12345678910111213141516171819202122232425262728293031323334353637- (void)othersyncAndMain &#123; dispatch_queue_t concurrentQueue = dispatch_get_global_queue(0, 0); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); // 第一个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第二个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); // 第三个任务 dispatch_sync(queue, ^&#123; //这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]); &#125;);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x600002bcd1c0&gt;&#123;number = 7, name = (null)&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;__END:&lt;NSThread: 0x600002bcd1c0&gt;&#123;number = 7, name = (null)&#125;__ 结论：当前在子线程中可以正常执行。 【主队列➕异步执行】 不开线程，因为主队列的任务只有主线程可以执行。同步执行任务。 12345678910111213141516171819202122232425262728293031323334- (void)asyncAndMain &#123; NSLog(@&quot;__BEGIN:%@__&quot;, [NSThread currentThread]); dispatch_queue_t queue &#x3D; dispatch_get_main_queue(); &#x2F;&#x2F; 第一个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第一个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第二个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第二个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); &#x2F;&#x2F; 第三个任务 dispatch_async(queue, ^&#123; &#x2F;&#x2F;这里线程暂停2秒,模拟一般的任务的耗时操作 [NSThread sleepForTimeInterval:2]; NSLog(@&quot;----执行第三个任务---当前线程%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;__END:%@__&quot;, [NSThread currentThread]);&#125; log信息显示如下： 12345__BEGIN:&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;____END:&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;__----执行第一个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第二个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125;----执行第三个任务---当前线程&lt;NSThread: 0x600002ba4900&gt;&#123;number = 1, name = main&#125; 队列的区别比较表格 并发队列 串行队列 主队列 同步(sync) 在当前线程，依次执行任务 在当前线程，依次执行任务 死锁 异步(async) 开启新线程，并行执行任务 开启新线程，依次执行任务 在当前线程，依次执行任务 NSOperationNSOperation是GCD面向对象的封装，使用更加简单，苹果推荐的安全可靠的并发编程的方式。 首先介绍两个核心类NSOperation和NSOperationQueue。 NSOperationQueue NSOperationQueue有两种：1，主队列。 2，自定义队列。 1234567891011121314151617181920212223242526272829- (void)queueKinds &#123; // 主队列 NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; [mainQueue addOperationWithBlock:^&#123; NSLog(@&quot;mainQueue1::%@&quot;, [NSThread currentThread]); &#125;]; [mainQueue addOperationWithBlock:^&#123; NSLog(@&quot;mainQueue2::%@&quot;, [NSThread currentThread]); &#125;]; // 自定义队列 NSOperationQueue *customQueue = [[NSOperationQueue alloc] init]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue::%@&quot;, [NSThread currentThread]); &#125;]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue1::%@&quot;, [NSThread currentThread]); &#125;]; [customQueue addOperationWithBlock:^&#123; NSLog(@&quot;customQueue2::%@&quot;, [NSThread currentThread]); &#125;];&#125; log信息显示如下： 12345customQueue2::&lt;NSThread: 0x600003df4000&gt;&#123;number = 5, name = (null)&#125;customQueue1::&lt;NSThread: 0x600003df4080&gt;&#123;number = 4, name = (null)&#125;customQueue::&lt;NSThread: 0x600003df9b40&gt;&#123;number = 7, name = (null)&#125;mainQueue1::&lt;NSThread: 0x600003db00c0&gt;&#123;number = 1, name = main&#125;mainQueue2::&lt;NSThread: 0x600003db00c0&gt;&#123;number = 1, name = main&#125; 结论：通过alloc+init创建的队列默认是并发队列。 通过控制最大并发数属性maxConcurrentOperationCount，来实现串行和并发的切换。默认情况下为-1，表示不进行限制，队列为并发队列。为1时，队列为串行队列。大于1时，队列为并发队列。当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为min{自己设定的值，系统设定的默认最大值}。 NSOperationNSOperation是个抽象类，不能够直接使用，系统提供了两个子类NSInvocationOperation和NSBlockOperation供使用。也可以自定义子类。 【NSInvocationOperation】 操作直接执行 1234567891011121314- (void)operation &#123; &#x2F;&#x2F; 1，创建 NSInvocationOperation 对象 NSInvocationOperation *op1 &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(taskMethod:) object:@2]; &#x2F;&#x2F; 2，不开新线程，在当前线程开始执行操作 [op1 start]; &#x2F;&#x2F; [op1 main]; main方法和start作用相同&#125;- (void)taskMethod:(NSNumber *)count &#123; for (int i &#x3D; 0; i &lt; count.intValue; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125;&#125; 操作添加到队列 1234567891011- (void)demo &#123; &#x2F;&#x2F; 默认最大并发数是-1，队列属于并发队列 NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; for (int i &#x3D; 0; i &lt; 6; ++i) &#123; &#x2F;&#x2F; 创建操作 NSInvocationOperation *operation &#x3D; [[NSInvocationOperation alloc] initWithTarget:self selector: @selector(taskMethod:) object:@1]; &#x2F;&#x2F; 操作添加到队列 [queue addOperation: operation]; &#125;&#125; log信息显示如下： 123456---&lt;NSThread: 0x6000030a0500&gt;&#123;number = 5, name = (null)&#125;---&lt;NSThread: 0x6000030a18c0&gt;&#123;number = 4, name = (null)&#125;---&lt;NSThread: 0x6000030dbd80&gt;&#123;number = 3, name = (null)&#125;---&lt;NSThread: 0x600003082200&gt;&#123;number = 6, name = (null)&#125;---&lt;NSThread: 0x6000030a9640&gt;&#123;number = 8, name = (null)&#125;---&lt;NSThread: 0x6000030a9f40&gt;&#123;number = 7, name = (null)&#125; 【NSBlockOperation】 相比NSInvocationOperation使用起来更加简便，所以开发中经常使用。 操作直接执行 12345678910111213141516171819202122232425262728293031323334- (void)demo &#123; &#x2F;&#x2F; 1.创建 NSBlockOperation 对象 NSBlockOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 2.添加额外的操作 [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i &#x3D; 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); &#x2F;&#x2F; 打印当前线程 &#125; &#125;]; &#x2F;&#x2F; 3.调用 start 方法开始执行操作 [op start]; &#125; 1234567894---&lt;NSThread: 0x6000037aacc0&gt;&#123;number = 7, name = (null)&#125;1---&lt;NSThread: 0x6000037f0840&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x6000037b8700&gt;&#123;number = 5, name = (null)&#125;2---&lt;NSThread: 0x6000037bc000&gt;&#123;number = 6, name = (null)&#125;2---&lt;NSThread: 0x6000037bc000&gt;&#123;number = 6, name = (null)&#125;4---&lt;NSThread: 0x6000037aacc0&gt;&#123;number = 7, name = (null)&#125;3---&lt;NSThread: 0x6000037b8700&gt;&#123;number = 5, name = (null)&#125;1---&lt;NSThread: 0x6000037f0840&gt;&#123;number = 1, name = main&#125; 操作添加到队列 1234567// 默认最大并发数是-1，队列属于并发队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 1.创建 NSBlockOperation 对象NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;];[queue addOperation:op]; 简便写法 123456&#x2F;&#x2F; 队列NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F; 添加操作[queue addOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;]; 在NSOperation单独使用情况下，调用start/main方法，是否开启新线程，取决于操作的个数。如果操作的个数是一个的话，任务在当前线程执行。如果操作个数大于等于两个，就会自动开启新线程。 【NSInvocationOperation与NSBlockOperation异同】共同点： NSInvocationOperation类只能封装一个操作，所以当调用start方法时，任务在当前线程执行。NSBlockOperation是否开启新线程，取决于操作的个数。如果添加的操作的个数是一个的话，调用start方法时，任务在当前线程执行。如果添加的操作个数大于等于两个，就会自动开启新线程。NSCustomOperation调用start方法时，任务在当前线程执行。 区别： NSBlockOperation可以添加多个操作。NSInvocationOperation 和NSCustomOperation只能添加一个操作。 接下来再介绍NSOperationQueue的一些其它的特性和用法。 【最大并发数】 自定义队列 通过控制最大并发数属性,来实现同时具有串行、并发功能。 maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。为1时，队列为串行队列。只能串行执行。大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为min{自己设定的值，系统设定的默认最大值}。 【优先级】 队列的优先级iOS8.0之后队列优先级使用qualityOfService属性 123NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F; 并发队列&#x2F;&#x2F; 优先级高代表被执行的概率高，而不是一定会先执行。queue.qualityOfService &#x3D; NSQualityOfServiceUserInteractive; 任务的优先级iOS8.0之后任务优先级使用qualityOfService属性替代queuePriority属性 12345NSBlockOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123; &#125;];&#x2F;&#x2F;优先级高代表被执行的概率高，而不是一定会先执行。&#x2F;&#x2F;qualityOfService的值是枚举类型，可到文档中具体查看，这里不一一介绍了。operation.qualityOfService &#x3D; NSOperationQueuePriorityNormal; 【队列挂起和任务取消】 12345678NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;挂起 暂停队列中还没有被调度的任务，正在调度的任务，不能被暂停[operationQueue setSuspended:YES];&#x2F;&#x2F;取消挂起 线程继续调度任务执行[operationQueue setSuspended:NO];&#x2F;&#x2F; 取消队列中的所有操作，同样不会影响到正在执行中的操作[operationQueue cancelAllOperations]; 【队列中的操作数】 123NSOperationQueue *operationQueue &#x3D; [[NSOperationQueue alloc] init];&#x2F;&#x2F;并发队列&#x2F;&#x2F;NSOperationQueue的operationCount属性可以获取当前队列中的任务数量NSLog(@&quot;%@&quot;,operationQueue.operationCount);","categories":[],"tags":[]},{"title":"在MacOS上使用Hexo+GitHub搭建个人博客","slug":"hexo-github-1","date":"2017-02-20T10:21:56.000Z","updated":"2020-10-05T13:24:43.052Z","comments":true,"path":"2017/02/20/hexo-github-1/","link":"","permalink":"http://onzxgway.github.io/2017/02/20/hexo-github-1/","excerpt":"","text":"IT行业的知识体系更新迭代非常频繁，开发者需要不停的去学习新的知识新的技术，那么往往老的知识技术会遗忘的非常快，通过记录总结可以在需要的时候快速回忆起来，其次，互联网IT的精神核心是分享、共享，总结记录下来就可以分享给需要的人。所以，我需要一个可以满足我的需求的方式，个人博客就是一个非常好的方式。 通过Hexo + Github搭建的个人博客，就是一个非常好的选择。首先介绍一下Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 建站具体的建站过程，在这篇博文中不是重点，因为在网络上可以搜索到非常多的教程，任意选择一个即可，我推荐官方的中文建站文档，里面的说明非常全面详细。 重点来了，我在建站过程中踩过的坑，犯过的错误，浪费的时间精力，是我非常想和大家分享的。 执行安装语句出错1sudo npm install -g hexo-cli 报错信息提示需要在语句末尾加上–force 1sudo npm install -g hexo-cli --force 安装成功。 执行hexo d语句出错1hexo d 报错信息 1234You should configure deployment settings in _config.yml first!Available deployer plugins: gitFor more help, you can check the online docs: http://hexo.io/ 纳尼，我就拷贝了deploy的配置语句，追加在_config.yml文件末尾，其他啥也没干啊，怎么就不对了呢，奇怪。 12345deploy:type: gitrepo: git@github.com:onzxgway/onzxgway.github.io.gitbranch: master 在网上查了一番资料才发现，是没有缩进导致的，😭，正确的格式应该是这样的 1234deploy: type: git repo: git@github.com:onzxgway/onzxgway.github.io.git branch: master 更换主题不生效系统默认的主题landscape被我更换为archer之后，重新生成静态文件，部署上线，但是实际不生效。解决方法：在重新生成静态文件前，执行 1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况下（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 配置文件_config.yml您可以在 _config.yml 文件中修改大部分的配置。 在文章中插入图片Hexo配置文件的设置在博客根目录下，配置_config.yml文件，把post_asset_folder字段值由false改为true。设置post_asset_folder参数后，运行hexo n “xxxx”来生成md博文时，hexo会自动创建一个与文章同名的文件夹，您可以把相关的资源都放到此文件夹内，这样就可以更方便的管理和使用资源。 安装hexo-asset-image插件由于hexo默认不支持文章插入本地图片，那么就需要安装hexo-asset-image图片路径转换插件来支持。切换到博客根目录下，运行如下指令安装插件。 1npm install hexo-asset-image --save 插件安装完以后，实际上是存放在…/node_modules/hexo-asset-image目录文件夹下的，如果想要卸载这个插件的话，直接删掉这个文件夹即可。 插入图片运行hexo n “firstblog”指令，创建一篇名为firstblog.md文章，然后查看博客的 …/source/_posts目录，会看到存在一个firstblog文件夹和firstblog.md文件，将博文所需要的资源放到firstblog文件夹下，写博客时使用![图片描述](xxx/xxx.png)直接插入该文件夹内的图片即可。 在文章中插入图片遇到的坑1，在md文件中使用![图片描述](xxx/xxx.png)语法引用图片，图片无法成功加载。 开始查找错误，通过浏览器调试，发现是图片的路径不对，显示为http://example.com/......，奥，瞬间明白了，是由于_config.yml文件中的url没有设置正确值，解决方式很简单就是把url的值修改为http://onzxgway.github.io。修改好了之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 接着查找问题，通过浏览器调试，发现还是图片的路径不对，显示为http://onzxgway.github.io/io//ReferenceCount.png，这就奇怪了，怎么会生成这种路径呢，通过查找资料发现是由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，把年月去掉了，导致最后生成的路径不对。解决方法就是卸载hexo-asset-image插件，重新安装已经修改过得新插件npm install https://github.com/7ym0n/hexo-asset-image --save 安装成功之后，运行指令hexo clean &amp; hexo g &amp; hexo d，结果还是不显示图片。 这就有点不爽了，哪里出问题了呢，还是用浏览器调试，发现图片的路径依然不对，而且第二步更新hexo-asset-image插件一点作用也没起，路径纹丝没动，还是http://onzxgway.github.io/io//ReferenceCount.png，漫长的调试中…，最后发现是我自己犯了一个低级错误，我在博客根目录下安装了hexo-asset-image插件，又在博客的同级目录下也安装了hexo-asset-image插件，我卸载更新的是博客的同级目录下的插件，而真正起作用的根目录下的插件并没有卸载更新，所以最终生成的页面没有任何改变，吐血，因为这个疏忽，多耗费了我两个小时的时间，下次一点要头脑清晰，思路明捷去作业。","categories":[],"tags":[]}],"categories":[],"tags":[]}