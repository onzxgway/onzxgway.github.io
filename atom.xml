<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OnZXGWay</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-26T14:08:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>朱献国</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS并发编程</title>
    <link href="http://yoursite.com/2017/02/22/iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/22/iOS并发编程/</id>
    <published>2017-02-22T10:21:56.000Z</published>
    <updated>2017-02-26T14:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发</strong> 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种API(pthread,NSThread,GCD,NSOperation)用于并发编程。本文主要讲解四种API的使用方法，优缺点和注意事项。</p>
<p>在学习并发编程之前，首先我们要知道线程的概念，以及线程的一些相关基础知识，这是学习并发编程的基础。</p>
<h4 id="一：什么是线程？"><a href="#一：什么是线程？" class="headerlink" title="一：什么是线程？"></a>一：什么是线程？</h4><p><strong>线程（thread）</strong>是进程的基本单位，一个进程包含一个或多个线程（至少包含一个），操作系统的调度器可以直接调度线程。所有的并发编程API都是构建在线程上的。</p>
<h4 id="二：线程的状态："><a href="#二：线程的状态：" class="headerlink" title="二：线程的状态："></a>二：线程的状态：</h4><p><img src="http://ols16w547.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%209.04.58%20PM.png" alt="Screen%20Shot%202017-02-22%20at%209.04.58%20PM"></p>
<ul>
<li><p><strong>新建</strong>：线程对象在内存中被创建出来。</p>
</li>
<li><p><strong>就绪</strong>：除了CPU以外的所有资源都已分配好了，等待CPU调度。（已经加入可调度线程池中）</p>
</li>
<li><p><strong>运行</strong>：CPU正在运行该线程。（当CPU切换执行其它线程的时候，当前线程退回到就绪状态）</p>
</li>
<li><p><strong>阻塞</strong>：除了CPU以外，还有其它资源没有分配，（阻塞状态的线程，被移出了可调度线程池）</p>
</li>
<li><p><strong>死亡</strong>：线程被销毁，占用的内存空间被释放。</p>
</li>
</ul>
<h4 id="三：并发编程的四种API介绍"><a href="#三：并发编程的四种API介绍" class="headerlink" title="三：并发编程的四种API介绍"></a>三：并发编程的四种API介绍</h4><p><mark><strong>1，pthread</strong></mark></p>
<p>pthread(posix线程) 是一套纯C的API，平时几乎不会使用，如果没有兴趣可以不用了解，当然如果想多掌握一些的话，可以继续往下阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">如何使用：</div><div class="line">1，导入头文件 #import &lt;pthread.h&gt;</div><div class="line">2，调用函数 </div><div class="line">int pthread_create(pthread_t * __restrict,pthread_attr_t * __restrict,void *  (*) (void *),void *  __restrict);</div><div class="line"></div><div class="line">/*参数解释</div><div class="line"> 返回值是0 表示创建线程成功 非0表示创建线程失败</div><div class="line"></div><div class="line"> 1,pthread_t * 线程的标示   </div><div class="line"> 2,pthread_attr_t 线程的属性   </div><div class="line"> 3,void* (*) (void *) </div><div class="line">   返回值 函数名 参数   函数签名 void * 约等于OC中的id任意类型</div><div class="line"> 4,void * 给函数的参数    </div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p><mark><strong>2，NSThread</strong></mark></p>
<p>NSThread是Objcetive-c基于pthread的封装,封装之后在面向对象的编程环境中，看起来更加的亲切,使用也更加的顺手。一个NSThread对象代表一个线程。</p>
<p><strong>一 如何使用：</strong></p>
<p>【类方法】<br>优点：使用简单，线程创建好之后就是就绪(runnable)状态，CPU可直接调度。<br>缺点：无法拿到线程对象本身，不能对线程对象做更详细的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block;</div><div class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</div></pre></td></tr></table></figure></p>
<p>【对象方法】<br>优点：可以拿到线程对象本身，对线程对象做更详细的设置。比如设置线程优先级，或者设置名称。<br>缺点：线程创建好之后处于新建（new）状态,需要手动调用start方法，进入就绪(runnable)状态，没有类方法简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</div><div class="line">- (instancetype)initWithBlock:(void (^)(void))block;</div><div class="line">注意：- (instancetype)init方法得到的线程是主线程。</div></pre></td></tr></table></figure></p>
<p>【隐式创建】<br>优缺点和类方法的优缺点相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg</div><div class="line">注意：该方法不是NSThread类的方法，而是NSObject的NSThreadPerformAdditions分类中的方法。</div></pre></td></tr></table></figure></p>
<p>【自定义线程类】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">第一步：自定义一个线程类，例如ZXGThread,继承自NSThread类</div><div class="line">第二步：在ZXGThread类中，重写继承自父类的main方法，把需要在后台子线程中执行的代码放到main方法中。</div><div class="line">第三步：通过alloc+init方法创建ZXGThread对象，然后调用start方法，即可。</div></pre></td></tr></table></figure></p>
<p><strong>二 常见属性：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	//线程优先级，double类型，取值范围是：0.0~1.0，默认是0.5，1.0表示优先级最高，</div><div class="line">	//优先级越高，表示被CPU调度的概率越高。  逐渐被废弃，用qualityOfService替代</div><div class="line">thread.threadPriority</div><div class="line"></div><div class="line">    //线程服务质量约等于线程优先级，枚举值，默认是NSQualityOfServiceDefault=-1,优先级最低。</div><div class="line">    //iOS8之后比threadPriority好用</div><div class="line">thread.qualityOfService;</div><div class="line"></div><div class="line">    //线程的名称,主线程默认名称是main，子线程默认名称为null,</div><div class="line">thread.name;</div><div class="line"></div><div class="line">    //判断当前线程是否是主线程，只读属性</div><div class="line">thread.isMainThread;</div><div class="line"></div><div class="line">    //判断当前线程是否正在执行任务，只读属性</div><div class="line">thread.isExecuting;</div><div class="line"></div><div class="line">    //判断当前线程是否执行结束，只读属性</div><div class="line">thread.isFinished;</div><div class="line"></div><div class="line">    //判断当前线程是否被取消，只读属性</div><div class="line">thread.isCancelled;</div><div class="line"></div><div class="line">    //线程在stack栈上占用的存储空间，通常为512kb，线程释放后，空间收回。</div><div class="line">thread.stackSize;</div></pre></td></tr></table></figure></p>
<p><strong>三 常用方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//阻塞方法</div><div class="line">//休眠到指定的时间</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;</div><div class="line">//休眠多久</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)time;</div><div class="line"></div><div class="line">//在调试中经常使用，用来获取当前所在的线程对象的。</div><div class="line">[NSThread currentThread]</div><div class="line">//获取主线程对象</div><div class="line">[NSThread mainThread]</div><div class="line"></div><div class="line">//退出线程</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">//如果自定义线程类，把要执行的任务，放在重写的main方法中。</div><div class="line">- (void)main	// thread body method</div></pre></td></tr></table></figure>
<p><strong><em>直接操作线程对象可能引发一个问题是，如果你的代码和项目中使用到的框架的代码都创建了自己的线程时，那么活动的线程的数量有可能以指数级增长。这在大型项目中是一个常见问题。例如：在8核CPU中，你创建了8个线程来发挥CPU性能。然而在这些线程中调用到的框架代码也做了同样的事情（以为他不知道你创建了这些线程），这样会很快产生成百上千的线程，代码每个部分自身都没有问题，但是最终还是导致了问题。每个线程都会消耗一些内存和内核资源。<br>接下来，我将介绍两个基于队列的并发编程API：GCD和NSOperationQueue,它们是通过管理一个可以协同使用的线程池，来解决上面的问题的。</em></strong></p>
<p><mark><strong>3，GCD</strong></mark><br><strong><em>GCD(Grand Central Dispatch)是一套底层纯C语言的API,是并发多核的解决方案，其实就是为了让开发者更加容易的使用设备上多核CPU的。</em></strong></p>
<p><strong><em>GCD会自动管理线程的生命周期，开发者不用直接和线程打交道，只需要向队列中添加任务即可，GCD在后端管理着一个线程池，通过统一的管理，来避免开启过多的线程。</em></strong></p>
<blockquote>
<p><strong>在学习GCD编程之前，首先我们要深刻理解队列和任务的概念，这是基础，也是GCD的核心概念。</strong></p>
</blockquote>
<h4 id="一：队列"><a href="#一：队列" class="headerlink" title="一：队列"></a>一：队列</h4><p><strong>队列定义：</strong>用来存放任务的，先进先出的（FIFO，First in first out)容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//队列的类型dispatch_queue_t</div><div class="line">dispatch_queue_t queue;</div></pre></td></tr></table></figure></p>
<p><strong>队列分类：</strong><br>队列分为两类：串型队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue），系统提供了一个主队列（特殊的串行队列）和一个全局并发队列（属于并发队列）。</p>
<p>【串行队列】<br>让内部的任务一个接着一个执行，等待上一个任务执行完毕，才会接着执行下一个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL); </div><div class="line">参数解释：</div><div class="line">1，队列的名称。 </div><div class="line">2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。</div></pre></td></tr></table></figure>
<p>【并发队列】<br>让队列内部的多个任务同时执行(并发队列只有在异步执行dispatch_async的时候才有效，底层线程池会提供多个线程同时去执行队列中的任务)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个并发队列</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); </div><div class="line">参数解释：</div><div class="line">1，队列的名称。 作用：可以协助开发调试和崩溃报告分析</div><div class="line">2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。</div></pre></td></tr></table></figure>
<p>【主队列】也叫【全局串行队列】<br>主队列是特殊的串行队列，由系统提供的，使用的时候只要去获取即可，无需开发者手动创建，主队列中的任务都是由主线程去执行的。</p>
<p>特点：<br>1，如果主线程正在执行代码暂时不调度任务，等主线程执行结束后在调度任务。这是主队列中同步执行导致死锁的原因。<br>2，UI更新的操作都要放在主线程中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取系统提供的主队列</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div></pre></td></tr></table></figure></p>
<p>【全局并发队列】<br>全局并发队列就是并发队列，和并发队列行为相同，使用的时候只要去获取即可，无需开发者手动创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//获取系统提供的全局并发队列</div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</div><div class="line">//参数解释</div><div class="line">1，指定队列的优先级。</div><div class="line">DISPATCH_QUEUE_PRIORITY_HIGH (2)</div><div class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT (0)//自定义队列的优先级都是默认优先级</div><div class="line">DISPATCH_QUEUE_PRIORITY_LOW (-2)</div><div class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND (INT16_MIN)</div><div class="line">2，作为保留字段备用（一般为0)</div></pre></td></tr></table></figure></p>
<h4 id="二：任务"><a href="#二：任务" class="headerlink" title="二：任务"></a>二：任务</h4><p><strong>任务定义：</strong>放到线程中去执行的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//任务的类型dispatch_block_t</div><div class="line">dispatch_block_t task;//声明一个任务变量。</div><div class="line">注意：dispatch_block_t类型是这么定义的typedef void (^dispatch_block_t)(void); </div><div class="line">由定义可以看出它本质就是一个无参数无返回值的block.</div></pre></td></tr></table></figure></p>
<h4 id="三：执行任务的函数"><a href="#三：执行任务的函数" class="headerlink" title="三：执行任务的函数"></a>三：执行任务的函数</h4><p>执行任务的函数有两个，同步执行（dispatch_sync）和异步执行（dispatch_async）<br><strong><em>核心区别：是否开启子线程，同步不开启子线程在当前线程执行，异步开启子线程。</em></strong><br><strong><em>使用方法：把任务放到队列里dispatch_sync(queue, block) 和dispatch_async(queue, block) </em></strong></p>
<p>【同步】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</div><div class="line">queue：队列</div><div class="line">block：任务</div></pre></td></tr></table></figure></p>
<p>【异步】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div><div class="line">queue：队列</div><div class="line">block：任务</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>在了解完了GCD的一些核心基本概念之后，我们研究GCD的真正使用方法</strong></p>
</blockquote>
<h2 id="串型队列的执行"><a href="#串型队列的执行" class="headerlink" title="串型队列的执行"></a>串型队列的执行</h2><p>【串行队列的同步执行】</p>
<ul>
<li>同步执行:不开线程(在当前线程)。串行队列:任务一次只能执行一个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define DISPATCH_QUEUE_SERIAL NULL</div><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//2,创建一个任务</div><div class="line">dispatch_block_t task = ^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;;</div><div class="line">//3,将任务添加到队列中</div><div class="line">//同步执行</div><div class="line">dispatch_sync(serialQueue,task);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【串行队列的异步执行】</p>
<ul>
<li>异步执行:开启一个子线程，任务在子线程执行，为什么只开启一个，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务。串行队列:任务一次只能执行一个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//2,创建一个任务</div><div class="line">dispatch_block_t task = ^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;;</div><div class="line">//3,将任务添加到队列中</div><div class="line">//异步执行</div><div class="line">dispatch_async(serialQueue,task);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一般在开发中代码要简写，我上面这么写的目的，是帮助理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//</div><div class="line">//2,异步执行</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="并发队列的执行"><a href="#并发队列的执行" class="headerlink" title="并发队列的执行"></a>并发队列的执行</h2><p>【并发队列的同步执行】</p>
<ul>
<li>同步执行:不开线程(在当前线程)。并发队列:多个任务可以同时执行。<br>执行情况与串行队列的同步执行一模一样。</li>
</ul>
<p>【并发队列的异步执行】</p>
<ul>
<li>异步执行:开启多个子线程，任务在子线程执行，具体开启多少个线程是不固定的(线程数，不由我们控制)，线程数是由gcd来决定的。<br>并发队列:多个任务可以同时执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//1，创建并发队列</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//将任务添加到队列中</div><div class="line">//2,异步执行</div><div class="line">dispatch_async(concurrentQueue,^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统提供队列的执行"><a href="#系统提供队列的执行" class="headerlink" title="系统提供队列的执行"></a>系统提供队列的执行</h2><p>系统已经为我们准备好了2个常用队列主队列（全局串行队列）和全局并发队列，<strong><em>开发中很多都是使用系统提供的队列，不用自己手动创建</em></strong></p>
<p>【主队列的同步执行】</p>
<ul>
<li>不开线程(在当前主线程执行)，会导致死锁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">dispatch_sync(dispatch_get_main_queue(),^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">注意:当程序执行到这段代码的时候,向主队列中添加了一个任务，此时如果主线程要继续往下执行的话，</div><div class="line">必须要执行刚添加到主队列中的任务，只有把这个任务执行完毕之后，才可以继续，所以现在要等待调</div><div class="line">度该任务。而主队列有个特点就是只有主线程不忙的时候，才会去调度主线程执行任务，现在的情况是</div><div class="line">主线程很忙，所以不会去调度任务，一个等待调度任务执行，一个不让去调度任务，最终导致了死锁。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【主队列的异步执行】</p>
<ul>
<li>不开线程，因为主队列的任务只有主线程可以执行。同步执行任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//异步执行</div><div class="line">dispatch_async(dispatch_get_main_queue(),^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【全局并发队列的同步执行】</p>
<ul>
<li>不开启子线程，在当前线程中顺序执行任务，与执行情况与串行队列的同步执行一模一样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//同步执行</div><div class="line">dispatch_sync(dispatch_get_global_queue(0, 0),^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【全局并发队列的异步执行】</p>
<ul>
<li>执行情况与并发队列的异步执行一模一样。<br>不同的是队列直接获取即可，不用开发者创建。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(0, 0),^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="队列的区别比较表格"><a href="#队列的区别比较表格" class="headerlink" title="队列的区别比较表格"></a>队列的区别比较表格</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">全局并发队列</th>
<th style="text-align:center">手动创建串行队列</th>
<th style="text-align:center">主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同步(sync)</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
<td style="text-align:center">死锁</td>
</tr>
<tr>
<td style="text-align:center">异步(async)</td>
<td style="text-align:center">有开启新线程，并行执行任务</td>
<td style="text-align:center">开启新线程，串行执行任务</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt; 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种API(pthread,NSThread,GCD,N
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2013/07/26/README/"/>
    <id>http://yoursite.com/2013/07/26/README/</id>
    <published>2013-07-26T08:39:11.000Z</published>
    <updated>2013-07-26T08:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-js"><a href="#markdown-js" class="headerlink" title="markdown-js"></a>markdown-js</h1><p>Yet another markdown parser, this time for JavaScript. There’s a few<br>options that precede this project but they all treat markdown to HTML<br>conversion as a single step process. You pass markdown in and get HTML<br>out, end of story. We had some pretty particular views on how the<br>process should actually look, which include:</p>
<ul>
<li><p>producing well-formed HTML. This means that <code>em</code> and <code>strong</code> nesting<br>is important, as is the ability to output as both HTML and XHTML</p>
</li>
<li><p>having an intermediate representation to allow processing of parsed<br>data (we in fact have two, both <a href="http://jsonml.org/" title="JSON Markup Language" target="_blank" rel="external">JsonML</a>: a markdown tree and an HTML tree)</p>
</li>
<li><p>being easily extensible to add new dialects without having to<br>rewrite the entire parsing mechanics</p>
</li>
<li><p>having a good test suite. The only test suites we could find tested<br>massive blocks of input, and passing depended on outputting the HTML<br>with exactly the same whitespace as the original implementation</p>
</li>
</ul>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Just the <code>markdown</code> library:</p>
<pre><code>npm install markdown
</code></pre><p>Optionally, install <code>md2html</code> into your path</p>
<pre><code>npm install -g markdown
</code></pre><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>The simple way to use it with node is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> markdown = <span class="built_in">require</span>( <span class="string">"markdown"</span> ).markdown;</div><div class="line"><span class="built_in">console</span>.log( markdown.toHTML( <span class="string">"Hello *World*!"</span> ) );</div></pre></td></tr></table></figure>
<h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><p>It also works in a browser; here is a complete example:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"text-input"</span> <span class="attr">oninput</span>=<span class="string">"this.editor.update()"</span></span></div><div class="line">              <span class="attr">rows</span>=<span class="string">"6"</span> <span class="attr">cols</span>=<span class="string">"60"</span>&gt;Type **Markdown** here.<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"preview"</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/markdown.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Editor</span>(<span class="params">input, preview</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          preview.innerHTML = markdown.toHTML(input.value);</div><div class="line">        &#125;;</div><div class="line">        input.editor = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">this</span>.update();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id); &#125;;</div><div class="line">      <span class="keyword">new</span> Editor($(<span class="string">"text-input"</span>), $(<span class="string">"preview"</span>));</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Command-line"><a href="#Command-line" class="headerlink" title="Command line"></a>Command line</h3><p>Assuming you’ve installed the <code>md2html</code> script (see Installation,<br>above), you can convert markdown to html:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># read from a file</span></div><div class="line">md2html /path/to/doc.md &gt; /path/to/doc.html</div><div class="line"></div><div class="line"><span class="comment"># or from stdin</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'Hello *World*!'</span> | md2html</div></pre></td></tr></table></figure>
<h3 id="More-options"><a href="#More-options" class="headerlink" title="More options"></a>More options</h3><p>If you want more control check out the documentation in<br><a href="http://github.com/evilstreak/markdown-js/blob/master/lib/markdown.js" target="_blank" rel="external">lib/markdown.js</a> which details all the methods and parameters<br>available (including examples!). One day we’ll get the docs generated<br>and hosted somewhere for nicer browsing.</p>
<p>Meanwhile, here’s an example of using the multi-step processing to<br>make wiki-style linking work by filling in missing link references:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> md = <span class="built_in">require</span>( <span class="string">"markdown"</span> ).markdown,</div><div class="line">    text = <span class="string">"[Markdown] is a simple text-based [markup language]\n"</span> +</div><div class="line">           <span class="string">"created by [John Gruber]\n\n"</span> +</div><div class="line">           <span class="string">"[John Gruber]: http://daringfireball.net"</span>;</div><div class="line"></div><div class="line"><span class="comment">// parse the markdown into a tree and grab the link references</span></div><div class="line"><span class="keyword">var</span> tree = md.parse( text ),</div><div class="line">    refs = tree[ <span class="number">1</span> ].references;</div><div class="line"></div><div class="line"><span class="comment">// iterate through the tree finding link references</span></div><div class="line">( <span class="function"><span class="keyword">function</span> <span class="title">find_link_refs</span>(<span class="params"> jsonml </span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> ( jsonml[ <span class="number">0</span> ] === <span class="string">"link_ref"</span> ) &#123;</div><div class="line">    <span class="keyword">var</span> ref = jsonml[ <span class="number">1</span> ].ref;</div><div class="line"></div><div class="line">    <span class="comment">// if there's no reference, define a wiki link</span></div><div class="line">    <span class="keyword">if</span> ( !refs[ ref ] ) &#123;</div><div class="line">      refs[ ref ] = &#123;</div><div class="line">        <span class="attr">href</span>: <span class="string">"http://en.wikipedia.org/wiki/"</span> + ref.replace(<span class="regexp">/\s+/</span>, <span class="string">"_"</span> )</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">Array</span>.isArray( jsonml[ <span class="number">1</span> ] ) ) &#123;</div><div class="line">    jsonml[ <span class="number">1</span> ].forEach( find_link_refs );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">Array</span>.isArray( jsonml[ <span class="number">2</span> ] ) ) &#123;</div><div class="line">    jsonml[ <span class="number">2</span> ].forEach( find_link_refs );</div><div class="line">  &#125;</div><div class="line">&#125; )( tree );</div><div class="line"></div><div class="line"><span class="comment">// convert the tree into html</span></div><div class="line"><span class="keyword">var</span> html = md.renderJsonML( md.toHTMLTree( tree ) );</div><div class="line"><span class="built_in">console</span>.log( html );</div></pre></td></tr></table></figure>
<h2 id="Intermediate-Representation"><a href="#Intermediate-Representation" class="headerlink" title="Intermediate Representation"></a>Intermediate Representation</h2><p>Internally the process to convert a chunk of markdown into a chunk of<br>HTML has three steps:</p>
<ol>
<li><p>Parse the markdown into a JsonML tree. Any references found in the<br>parsing are stored in the attribute hash of the root node under the<br>key <code>references</code>.</p>
</li>
<li><p>Convert the markdown tree into an HTML tree. Rename any nodes that<br>need it (<code>bulletlist</code> to <code>ul</code> for example) and lookup any references<br>used by links or images. Remove the references attribute once done.</p>
</li>
<li><p>Stringify the HTML tree being careful not to wreck whitespace where<br>whitespace is important (surrounding inline elements for example).</p>
</li>
</ol>
<p>Each step of this process can be called individually if you need to do<br>some processing or modification of the data at an intermediate stage.<br>For example, you may want to grab a list of all URLs linked to in the<br>document before rendering it to HTML which you could do by recursing<br>through the HTML tree looking for <code>a</code> nodes.</p>
<h2 id="Running-tests"><a href="#Running-tests" class="headerlink" title="Running tests"></a>Running tests</h2><p>To run the tests under node you will need tap installed (it’s listed as a<br><code>devDependencies</code> so <code>npm install</code> from the checkout should be enough), then do</p>
<pre><code>$ npm test
</code></pre><h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><p>Do the usual github fork and pull request dance. Add yourself to the<br>contributors section of <a href="/package.json">package.json</a> too if you want to.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Released under the MIT license.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of<br>this software and associated documentation files (the “Software”), to deal in<br>the Software without restriction, including without limitation the rights to<br>use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of<br>the Software, and to permit persons to whom the Software is furnished to do so,<br>subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS<br>FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR<br>COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER<br>IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN<br>CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown-js&quot;&gt;&lt;a href=&quot;#markdown-js&quot; class=&quot;headerlink&quot; title=&quot;markdown-js&quot;&gt;&lt;/a&gt;markdown-js&lt;/h1&gt;&lt;p&gt;Yet another markdown parser, this 
    
    </summary>
    
    
  </entry>
  
</feed>
