<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS并发编程(上) · OnZXGWay</title><meta name="description" content="iOS并发编程(上) - 朱献国"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="OnZXGWay"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/onzxgway" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS并发编程(上)</h1><div class="post-info">Feb 22, 2017</div><div class="post-content"><p><strong>并发</strong> 描述的概念是同时有多个任务在执行，这些任务在单核CPU上以分时的形式在运行（宏观上可以看成多个任务同时执行），而在多核CPU上才是真正的同时执行。在iOS开发中，Apple提供了四种API(pthread,NSThread,GCD,NSOperation)用于并发编程。本文以讲解四种API的使用方法为切入点，带你了解多线程的全貌。</p>
<a id="more"></a>
<p>在学习并发编程之前，首先我们要知道线程的概念，以及线程的一些相关基础知识，这是学习并发编程的基础。</p>
<h4 id="一：什么是线程？"><a href="#一：什么是线程？" class="headerlink" title="一：什么是线程？"></a>一：什么是线程？</h4><p><strong>线程（thread）</strong>是进程的基本单位，一个进程包含一个或多个线程（至少包含一个），操作系统的调度器可以直接调度线程。所有的并发编程API都是构建在线程上的。</p>
<h4 id="二：线程的状态："><a href="#二：线程的状态：" class="headerlink" title="二：线程的状态："></a>二：线程的状态：</h4><p><img src="http://ols16w547.bkt.clouddn.com/Screen%20Shot%202017-02-22%20at%209.04.58%20PM.png" alt="Screen%20Shot%202017-02-22%20at%209.04.58%20PM"></p>
<ul>
<li><p><strong>新建</strong>：线程对象在内存中被创建出来。</p>
</li>
<li><p><strong>就绪</strong>：除了CPU以外的所有资源都已分配好了，等待CPU调度。（已经加入可调度线程池中）</p>
</li>
<li><p><strong>运行</strong>：CPU正在运行该线程。（当CPU切换执行其它线程的时候，当前线程退回到就绪状态）</p>
</li>
<li><p><strong>阻塞</strong>：除了CPU以外，还有其它资源没有分配，（阻塞状态的线程，被移出了可调度线程池）</p>
</li>
<li><p><strong>死亡</strong>：线程被销毁，占用的内存空间被释放。</p>
</li>
</ul>
<h4 id="三：并发编程的四种API介绍"><a href="#三：并发编程的四种API介绍" class="headerlink" title="三：并发编程的四种API介绍"></a>三：并发编程的四种API介绍</h4><p><mark><strong>1，pthread</strong></mark></p>
<p>pthread(posix线程) 是一套纯C的API，平时几乎不会使用，如果没有兴趣可以不用了解，当然如果想多掌握一些的话，可以继续往下阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">如何使用：</div><div class="line">1，导入头文件 #import &lt;pthread.h&gt;</div><div class="line">2，调用函数 </div><div class="line">int pthread_create(pthread_t * __restrict,pthread_attr_t * __restrict,void *  (*) (void *),void *  __restrict);</div><div class="line"></div><div class="line">/*参数解释</div><div class="line"> 返回值是0 表示创建线程成功 非0表示创建线程失败</div><div class="line"></div><div class="line"> 1,pthread_t * 线程的标示   </div><div class="line"> 2,pthread_attr_t 线程的属性   </div><div class="line"> 3,void* (*) (void *) </div><div class="line">   返回值 函数名 参数   函数签名 void * 约等于OC中的id任意类型</div><div class="line"> 4,void * 给函数的参数    </div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p><mark><strong>2，NSThread</strong></mark></p>
<p>NSThread是Objcetive-c基于pthread的封装,封装之后在面向对象的编程环境中，看起来更加的亲切,使用也更加的顺手。一个NSThread对象代表一个线程。</p>
<p><strong>一 如何使用：</strong></p>
<p>【类方法】<br>优点：使用简单，线程创建好之后就是就绪(runnable)状态，CPU可直接调度。<br>缺点：无法拿到线程对象本身，不能对线程对象做更详细的设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block;</div><div class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</div></pre></td></tr></table></figure></p>
<p>【对象方法】<br>优点：可以拿到线程对象本身，对线程对象做更详细的设置。比如设置线程优先级，或者设置名称。<br>缺点：线程创建好之后处于新建（new）状态,需要手动调用start方法，进入就绪(runnable)状态，没有类方法简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</div><div class="line">- (instancetype)initWithBlock:(void (^)(void))block;</div><div class="line">注意：- (instancetype)init方法得到的线程是主线程。</div></pre></td></tr></table></figure></p>
<p>【隐式创建】<br>优缺点和类方法的优缺点相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg</div><div class="line">注意：该方法不是NSThread类的方法，而是NSObject的NSThreadPerformAdditions分类中的方法。</div></pre></td></tr></table></figure></p>
<p>【自定义线程类】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">第一步：自定义一个线程类，例如ZXGThread,继承自NSThread类</div><div class="line">第二步：在ZXGThread类中，重写继承自父类的main方法，把需要在后台子线程中执行的代码放到main方法中。</div><div class="line">第三步：通过alloc+init方法创建ZXGThread对象，然后调用start方法，即可。</div></pre></td></tr></table></figure></p>
<p><strong>二 常见属性：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	//线程优先级，double类型，取值范围是：0.0~1.0，默认是0.5，1.0表示优先级最高，</div><div class="line">	//优先级越高，表示被CPU调度的概率越高。  逐渐被废弃，用qualityOfService替代</div><div class="line">thread.threadPriority</div><div class="line"></div><div class="line">    //线程服务质量约等于线程优先级，枚举值，默认是NSQualityOfServiceDefault=-1,优先级最低。</div><div class="line">    //iOS8之后比threadPriority好用</div><div class="line">thread.qualityOfService;</div><div class="line"></div><div class="line">    //线程的名称,主线程默认名称是main，子线程默认名称为null,</div><div class="line">thread.name;</div><div class="line"></div><div class="line">    //判断当前线程是否是主线程，只读属性</div><div class="line">thread.isMainThread;</div><div class="line"></div><div class="line">    //判断当前线程是否正在执行任务，只读属性</div><div class="line">thread.isExecuting;</div><div class="line"></div><div class="line">    //判断当前线程是否执行结束，只读属性</div><div class="line">thread.isFinished;</div><div class="line"></div><div class="line">    //判断当前线程是否被取消，只读属性</div><div class="line">thread.isCancelled;</div><div class="line"></div><div class="line">    //线程在stack栈上占用的存储空间，通常为512kb，线程释放后，空间收回。</div><div class="line">thread.stackSize;</div></pre></td></tr></table></figure></p>
<p><strong>三 常用方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//阻塞方法</div><div class="line">//休眠到指定的时间</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;</div><div class="line">//休眠多久</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)time;</div><div class="line"></div><div class="line">//在调试中经常使用，用来获取当前所在的线程对象的。</div><div class="line">[NSThread currentThread]</div><div class="line">//获取主线程对象</div><div class="line">[NSThread mainThread]</div><div class="line"></div><div class="line">//退出线程</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">//如果自定义线程类，把要执行的任务，放在重写的main方法中。</div><div class="line">- (void)main	// thread body method</div></pre></td></tr></table></figure>
<p><strong><em>直接操作线程对象可能引发一个问题是，如果你的代码和项目中使用到的框架的代码都创建了自己的线程时，那么活动的线程的数量有可能以指数级增长。这在大型项目中是一个常见问题。例如：在8核CPU中，你创建了8个线程来发挥CPU性能。然而在这些线程中调用到的框架代码也做了同样的事情（以为他不知道你创建了这些线程），这样会很快产生成百上千的线程，代码每个部分自身都没有问题，但是最终还是导致了问题。每个线程都会消耗一些内存和内核资源。<br>接下来，我将介绍两个基于队列的并发编程API：GCD和NSOperationQueue,它们是通过管理一个可以协同使用的线程池，来解决上面的问题的。</em></strong></p>
<p><mark><strong>3，GCD</strong></mark><br><strong><em>GCD(Grand Central Dispatch)是一套底层纯C语言的API,是并发多核的解决方案，其实就是为了让开发者更加容易的使用设备上多核CPU的。</em></strong></p>
<p><strong><em>GCD会自动管理线程的生命周期，开发者不用直接和线程打交道，只需要向队列中添加任务即可，GCD在后端管理着一个线程池，通过统一的管理，来避免开启过多的线程。</em></strong></p>
<blockquote>
<p><strong>在学习GCD编程之前，首先我们要深刻理解队列和任务的概念，这是基础，也是GCD的核心概念。</strong></p>
</blockquote>
<h4 id="一：队列"><a href="#一：队列" class="headerlink" title="一：队列"></a>一：队列</h4><p><strong>队列定义：</strong>用来存放任务的，先进先出的（FIFO，First in first out)容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//队列的类型dispatch_queue_t</div><div class="line">dispatch_queue_t queue;</div></pre></td></tr></table></figure></p>
<p><strong>队列分类：</strong><br>队列分为两类：串型队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue），系统提供了一个主队列（特殊的串行队列）和一个全局并发队列（属于并发队列）。</p>
<p>【串行队列】<br>让内部的任务一个接着一个执行，等待上一个任务执行完毕，才会接着执行下一个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL); </div><div class="line">参数解释：</div><div class="line">1，队列的名称。 </div><div class="line">2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。</div></pre></td></tr></table></figure>
<p>【并发队列】<br>让队列内部的多个任务同时执行(并发队列只有在异步执行dispatch_async的时候才有效，底层线程池会提供多个线程同时去执行队列中的任务)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建一个并发队列</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT); </div><div class="line">参数解释：</div><div class="line">1，队列的名称。 作用：可以协助开发调试和崩溃报告分析</div><div class="line">2，队列的类型，是枚举值。DISPATCH_QUEUE_SERIAL表示串行，DISPATCH_QUEUE_CONCURRENT表示并发。</div></pre></td></tr></table></figure>
<p>【主队列】也叫【全局串行队列】<br>主队列是特殊的串行队列，由系统提供的，使用的时候只要去获取即可，无需开发者手动创建，主队列中的任务都是由主线程去执行的。</p>
<p>特点：<br>1，如果主线程正在执行代码暂时不调度任务，等主线程执行结束后在调度任务。这是主队列中同步执行导致死锁的原因。<br>2，UI更新的操作都要放在主线程中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取系统提供的主队列</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div></pre></td></tr></table></figure></p>
<p>【全局并发队列】<br>全局并发队列就是并发队列，和并发队列行为相同，使用的时候只要去获取即可，无需开发者手动创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//获取系统提供的全局并发队列</div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</div><div class="line">//参数解释</div><div class="line">1，指定队列的优先级。</div><div class="line">DISPATCH_QUEUE_PRIORITY_HIGH (2)</div><div class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT (0)//自定义队列的优先级都是默认优先级</div><div class="line">DISPATCH_QUEUE_PRIORITY_LOW (-2)</div><div class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND (INT16_MIN)</div><div class="line">2，作为保留字段备用（一般为0)</div></pre></td></tr></table></figure></p>
<h4 id="二：任务"><a href="#二：任务" class="headerlink" title="二：任务"></a>二：任务</h4><p><strong>任务定义：</strong>放到线程中去执行的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//任务的类型dispatch_block_t</div><div class="line">dispatch_block_t task;//声明一个任务变量。</div><div class="line">注意：dispatch_block_t类型是这么定义的typedef void (^dispatch_block_t)(void); </div><div class="line">由定义可以看出它本质就是一个无参数无返回值的block.</div></pre></td></tr></table></figure></p>
<h4 id="三：执行任务的函数"><a href="#三：执行任务的函数" class="headerlink" title="三：执行任务的函数"></a>三：执行任务的函数</h4><p>执行任务的函数有两个，同步执行（dispatch_sync）和异步执行（dispatch_async）<br><strong><em>核心区别：是否开启子线程，同步不开启子线程在当前线程执行，异步开启子线程。</em></strong><br><strong><em>使用方法：把任务放到队列里dispatch_sync(queue, block) 和dispatch_async(queue, block) </em></strong></p>
<p>【同步】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</div><div class="line">queue：队列</div><div class="line">block：任务</div></pre></td></tr></table></figure></p>
<p>【异步】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</div><div class="line">queue：队列</div><div class="line">block：任务</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>在了解完了GCD的一些核心基本概念之后，我们研究GCD的真正使用方法</strong></p>
</blockquote>
<h2 id="串型队列的执行"><a href="#串型队列的执行" class="headerlink" title="串型队列的执行"></a>串型队列的执行</h2><p>【串行队列的同步执行】</p>
<ul>
<li>同步执行:不开线程(在当前线程)。串行队列:任务一次只能执行一个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define DISPATCH_QUEUE_SERIAL NULL</div><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//2,创建一个任务</div><div class="line">dispatch_block_t task = ^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;;</div><div class="line">//3,将任务添加到队列中</div><div class="line">//同步执行</div><div class="line">dispatch_sync(serialQueue,task);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【串行队列的异步执行】</p>
<ul>
<li>异步执行:开启一个子线程，任务在子线程执行，为什么只开启一个，因为是串行队列，只有一个线程就可以按顺序执行队列中的所有任务。串行队列:任务一次只能执行一个。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//2,创建一个任务</div><div class="line">dispatch_block_t task = ^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;;</div><div class="line">//3,将任务添加到队列中</div><div class="line">//异步执行</div><div class="line">dispatch_async(serialQueue,task);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一般在开发中代码要简写，我上面这么写的目的，是帮助理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//1，创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">//</div><div class="line">//2,异步执行</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="并发队列的执行"><a href="#并发队列的执行" class="headerlink" title="并发队列的执行"></a>并发队列的执行</h2><p>【并发队列的同步执行】</p>
<ul>
<li>同步执行:不开线程(在当前线程)。并发队列:多个任务可以同时执行。<br>执行情况与串行队列的同步执行一模一样。</li>
</ul>
<p>【并发队列的异步执行】</p>
<ul>
<li>异步执行:开启多个子线程，任务在子线程执行，具体开启多少个线程是不固定的(线程数，不由我们控制)，线程数是由gcd来决定的。<br>并发队列:多个任务可以同时执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//1，创建并发队列</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//将任务添加到队列中</div><div class="line">//2,异步执行</div><div class="line">dispatch_async(concurrentQueue,^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="系统提供队列的执行"><a href="#系统提供队列的执行" class="headerlink" title="系统提供队列的执行"></a>系统提供队列的执行</h2><p>系统已经为我们准备好了2个常用队列主队列（全局串行队列）和全局并发队列，<strong><em>开发中很多都是使用系统提供的队列，不用自己手动创建</em></strong></p>
<p>【主队列的同步执行】</p>
<ul>
<li>不开线程(在当前主线程执行)，会导致死锁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">dispatch_sync(dispatch_get_main_queue(),^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">注意:当程序执行到这段代码的时候,向主队列中添加了一个任务，此时如果主线程要继续往下执行的话，</div><div class="line">必须要执行刚添加到主队列中的任务，只有把这个任务执行完毕之后，才可以继续，所以现在要等待调</div><div class="line">度该任务。而主队列有个特点就是只有主线程不忙的时候，才会去调度主线程执行任务，现在的情况是</div><div class="line">主线程很忙，所以不会去调度任务，一个等待调度任务执行，一个不让去调度任务，最终导致了死锁。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【主队列的异步执行】</p>
<ul>
<li>不开线程，因为主队列的任务只有主线程可以执行。同步执行任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//异步执行</div><div class="line">dispatch_async(dispatch_get_main_queue(),^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【全局并发队列的同步执行】</p>
<ul>
<li>不开启子线程，在当前线程中顺序执行任务，与执行情况与串行队列的同步执行一模一样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//同步执行</div><div class="line">dispatch_sync(dispatch_get_global_queue(0, 0),^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【全局并发队列的异步执行】</p>
<ul>
<li>执行情况与并发队列的异步执行一模一样。<br>不同的是队列直接获取即可，不用开发者创建。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(0, 0),^&#123;</div><div class="line">     NSLog(@&quot;%@&quot;,[NSThread currentThread]);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="队列的区别比较表格"><a href="#队列的区别比较表格" class="headerlink" title="队列的区别比较表格"></a>队列的区别比较表格</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">全局并发队列</th>
<th style="text-align:center">手动创建串行队列</th>
<th style="text-align:center">主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同步(sync)</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
<td style="text-align:center">死锁</td>
</tr>
<tr>
<td style="text-align:center">异步(async)</td>
<td style="text-align:center">有开启新线程，并行执行任务</td>
<td style="text-align:center">开启新线程，串行执行任务</td>
<td style="text-align:center">没有开启新线程，串行执行任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>GCD的其他用法</strong></p>
</blockquote>
<p>【GCD延时操作】</p>
<p>dispatch_after</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);</div><div class="line">//参数解释</div><div class="line">1，dispatch_time_t when</div><div class="line">多少纳秒之后执行</div><div class="line">2，dispatch_queue_t queue</div><div class="line">任务添加到哪个队列</div><div class="line">3，dispatch_block_t block</div><div class="line">要执行的任务</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//延时操作</div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">&#125;);</div><div class="line">注意：如果任务在子线程中执行，那么一定要开启该子线程的消息循环Runloop,此定时任务才会有效执行。</div></pre></td></tr></table></figure>
<p>【GCD一次执行】</p>
<p>dispatch_once 代码从程序启动就执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    //要执行的代码块</div><div class="line">    //只会被执行一次</div><div class="line">&#125;);</div><div class="line"></div><div class="line">实现机制：在静态区分配内存给onceToken变量，并且初始化为0(静态区变量为全局变量，且直到程序退出才会释放onceToken),线程执行到这里时，判断onceToken的值为0，就去执行block,并且onceToken的值更改为-1，第二次再有线程来执行时，判断onceToken的值为-1，就不执行block。</div></pre></td></tr></table></figure>
<p>苹果推荐单例的创建方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedSingleton &#123;</div><div class="line">    static id instance;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        instance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>【GCD的队列组】</p>
<p>使用场景：在组里的异步任务都执行完毕后，再去执行其他操作。简言之，就是可以获取到多个线程执行结束的统一时间点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 队列</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">// 调度组</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">// 添加异步</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">&#125;);</div><div class="line">// 调度组通知 - 监听群组中，所有异步执行的代码完成后，得到通知 // 异步监听</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    //UI操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作</div><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    // 执行1个耗时的异步操作</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">    // 执行1个耗时的异步操作</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2013/07/26/README/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">朱献国</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>