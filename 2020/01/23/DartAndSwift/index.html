<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="朱献国">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="朱献国">
    
    <meta name="keywords" content="iOS,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="在学习Dart语言的过程中，发现很多语法点和Swift有异曲同工之妙，所以就顺便记录下，已便更好的理解掌握。 打印、注释、分号打印Dart和Swift都用print函数，输出内容到console面板上。 注释相同点：单行注释: 以&#x2F;&#x2F;开始，所有在&#x2F;&#x2F;和改行结尾之间的内容被编译器忽略。多行注释: 以&#x2F;*开始，以*&#x2F;结尾，所有在&#x2F;*和*&#x2F;之间的内容被编译器忽略，注意多行注释可以嵌套。文档注释: 以&#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart、Swift">
<meta property="og:url" content="http://onzxgway.github.io/2020/01/23/DartAndSwift/index.html">
<meta property="og:site_name" content="朱献国的博客">
<meta property="og:description" content="在学习Dart语言的过程中，发现很多语法点和Swift有异曲同工之妙，所以就顺便记录下，已便更好的理解掌握。 打印、注释、分号打印Dart和Swift都用print函数，输出内容到console面板上。 注释相同点：单行注释: 以&#x2F;&#x2F;开始，所有在&#x2F;&#x2F;和改行结尾之间的内容被编译器忽略。多行注释: 以&#x2F;*开始，以*&#x2F;结尾，所有在&#x2F;*和*&#x2F;之间的内容被编译器忽略，注意多行注释可以嵌套。文档注释: 以&#x2F;&#x2F;">
<meta property="og:locale">
<meta property="article:published_time" content="2020-01-23T14:44:22.000Z">
<meta property="article:modified_time" content="2021-01-16T03:20:25.326Z">
<meta property="article:author" content="朱献国">
<meta property="article:tag" content="iOS,Objective-C,Swift,OC,朱献国">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Dart、Swift · 朱献国的博客</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Hello, World!</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Dart、Swift</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Hello, World!</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Dart、Swift
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">4.8k</span>阅读时长: <span class="post-count reading-time">20 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/01/23</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>在学习Dart语言的过程中，发现很多语法点和Swift有异曲同工之妙，所以就顺便记录下，已便更好的理解掌握。</p>
<h2 id="打印、注释、分号"><a href="#打印、注释、分号" class="headerlink" title="打印、注释、分号"></a>打印、注释、分号</h2><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>Dart和Swift都用print函数，输出内容到<code>console</code>面板上。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>相同点</strong>：<br>单行注释: 以<code>//</code>开始，所有在<code>//</code>和<code>改行结尾</code>之间的内容被编译器忽略。<br>多行注释: 以<code>/*</code>开始，以<code>*/</code>结尾，所有在<code>/*</code>和<code>*/</code>之间的内容被编译器忽略，<strong>注意多行注释可以嵌套</strong>。<br>文档注释: 以<code>///</code>或者<code>/**</code>开始。在调用时候，有提示信息。</p>
<p><strong>不同点</strong>：<br>Dart中的文档注释，除非用中括号括起来，否则Dart编译器会忽略所有文本。使用中括号可以引用类、方法、字段、顶级变量、函数、和参数。括号中的符号会在已记录的程序元素的词法域中进行解析。</p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Dart强制要求在每条语句的结尾处使用分号<code>;</code>，而Swift则可加可不加，但是如果你在同一行内写多条独立的语句，就必须要用分号。</p>
<h2 id="声明常量和变量"><a href="#声明常量和变量" class="headerlink" title="声明常量和变量"></a>声明常量和变量</h2><p><strong>相同点</strong>：<br>1，都使用var来声明变量，都具备类型推断功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var dartStr = <span class="string">&quot;hello world&quot;</span> // 类型推断为String</span><br><span class="line"></span><br><span class="line">var swiftStr = <span class="string">&quot;hello world&quot;</span> // 类型推断为String</span><br></pre></td></tr></table></figure>
<p>也都可以通过添加<code>类型注解</code>来显示指定类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dartStr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">var swiftStr: String = <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>不同点</strong>：</p>
<p>1，常量声明方式。</p>
<p>如果不打算更改变量值，dart中可以使用final或者const。一个final变量只能被赋值一次，而const变量是编译时常量，定义时必须赋值。而Swift中使用let，一个let变量只能被赋值一次，最迟在构造器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const maximumNumber = 10 // 定义时必须赋值</span><br><span class="line"></span><br><span class="line">final maximumNumber = 10 // 只能被赋值一次，最迟在构造器赋值</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> maximumNumber = 10  // 只能被赋值一次，最迟在构造器赋值</span><br></pre></td></tr></table></figure>

<p>final和const有什么区别呢?<br>const在赋值时，赋值的内容必须是在编译期间就确定下来的。<br>final在赋值时，可以动态获取， 比如赋值一个函数。</p>
<blockquote>
<p>Dart中使用dynamic或Object来定义的变量，其类型相当于Swift中的Any。</p>
</blockquote>
<h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>Swift 包含了 <code>Int</code>表示整型值； <code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。 还提供了三个基本的集合类型，<code>Array</code>、<code>Set</code> 和 <code>Dictionary</code>。</p>
<p>Dart包含了 <code>int</code>表示整型值； <code>double</code>表示浮点型值；<code>bool</code>是布尔型值；<code>String</code>是文本型数据。 还提供了三个基本的集合类型，<code>List</code>、<code>Set</code> 和 <code>Map</code>。</p>
<blockquote>
<p><code>Swift</code> 和 <code>Dart</code> 中不能判断非0即真，或者非空即真。</p>
</blockquote>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>未初始化的变量默认值是<code>null</code>。即使变量是数字类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型也不例外。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><strong>你可以通过下面任意一种方式来控制 Dart 程序流程：</strong></p>
<p>1.条件语句</p>
<ul>
<li><code>if and else</code></li>
<li><code>switch and case</code></li>
</ul>
<p>2.循环</p>
<ul>
<li><code>for loops</code></li>
<li><code>while and do-while loops</code></li>
</ul>
<p>3.控制转移语句</p>
<ul>
<li><code>break and continue</code></li>
<li><code>return and throw</code></li>
<li><code>assert</code>：该语句只在开发环境中有效，在生产环境是无效的；</li>
</ul>
<p><strong>而Swift也提供了多种流程控制结构：</strong></p>
<p>1.条件语句</p>
<ul>
<li><code>if and else</code></li>
<li><code>switch and case</code></li>
</ul>
<p>2.循环</p>
<ul>
<li><code>for loops</code></li>
<li><code>while and repeat-while loops</code></li>
</ul>
<p>3.控制转移语句</p>
<ul>
<li><code>break and continue</code></li>
<li><code>return and throw</code></li>
<li><code>fallthrough</code></li>
</ul>
<p><strong>总结：</strong> 1，在循环语句中，<code>Dart</code>是<code>do-while</code>而<code>Swift</code>是<code>repeat-while</code>。2，在Swift里，switch语句不会从上一个case分支跳转到下一个case分支中，<code>fallthrough</code>可以实现C风格的贯穿的特性。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>前提：只介绍相对其他语言比较特殊的运算符。<br>1.除法、整除、取模运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 7;</span><br><span class="line">print(num &#x2F; 3); &#x2F;&#x2F; 除法操作， 结果2.3333..</span><br><span class="line">print(num ~&#x2F; 3); &#x2F;&#x2F; 整除操作， 结果2。</span><br><span class="line">print(num % 3); &#x2F;&#x2F; 取模操作， 结果1。</span><br></pre></td></tr></table></figure>

<p>2.赋值运算符</p>
<p>在<code>dart</code>中，有一个很多语言都不具备的赋值运算符<code>??=</code></p>
<ul>
<li>当变量有值时，使用自己的值，当变量为null时，使用后面的内容进行赋值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  &#x2F;&#x2F; var name &#x3D; &#39;kobe&#39;;</span><br><span class="line">  var name &#x3D; null;</span><br><span class="line">  name ??&#x3D; &#39;james&#39;; </span><br><span class="line">  print(name); &#x2F;&#x2F; 当name初始化为kobe时，结果为kobe，当初始化为null时，赋值了james。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>swift</code>中，如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let (x， y) &#x3D; (1， 2)</span><br><span class="line">&#x2F;&#x2F; 现在 x 等于 1，y 等于 2</span><br></pre></td></tr></table></figure>

<p>3.条件运算符</p>
<p>在<code>dart</code>中，有一个比较特殊的条件运算符：expr1 ?? expr2</p>
<ul>
<li>如果expr1是null，则返回expr2的结果，如果expr1不是null，直接使用expr1的结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; var temp &#x3D; &#39;why&#39;;</span><br><span class="line">var temp &#x3D; null;</span><br><span class="line">var name &#x3D; temp ?? &#39;kobe&#39;;</span><br><span class="line">print(name);</span><br></pre></td></tr></table></figure>

<p>在<code>swift</code>中，没有条件运算符，只能通过三目运算符实现。</p>
<p>4.级联语法</p>
<p>在<code>dart</code>中，通过级联语法，可以对一个对象进行连续的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&quot;$&#123;name&#125; is running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void eat() &#123;</span><br><span class="line">    print(&quot;$&#123;name&#125; is eating&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swim() &#123;</span><br><span class="line">    print(&quot;$&#123;name&#125; is swimming&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p1 &#x3D; Person();</span><br><span class="line">  p1.name &#x3D; &#39;why&#39;;</span><br><span class="line">  p1.run();</span><br><span class="line">  p1.eat();</span><br><span class="line">  p1.swim();</span><br><span class="line"></span><br><span class="line">  final p2 &#x3D; Person()</span><br><span class="line">              ..name &#x3D; &quot;why&quot;</span><br><span class="line">              ..run()</span><br><span class="line">              ..eat()</span><br><span class="line">              ..swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>Dart</code>是一门真正面向对象的语言，甚至其中的函数也是对象，并且有它的类型<code>Function</code>。且函数是一等对象可以被赋值给变量、作为参数传递或者作为函数的返回值。</p>
<p>函数的定义方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum(num num1， num num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Effective Dart</code>建议对公共的API使用类型注解，但是如果我们省略掉了类型，依然是可以正常工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(num1， num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头语法与隐式返回"><a href="#箭头语法与隐式返回" class="headerlink" title="箭头语法与隐式返回"></a>箭头语法与隐式返回</h3><p>如果函数中只有一句表达式，可以使用简写语法：<br>Dart中箭头语法：<code>=&gt; expr</code> 是<code>&#123; return expr; &#125;</code>的简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String greeting(String person) &#x3D;&gt; &quot;Hello， &quot; + person + &quot;!&quot;;</span><br></pre></td></tr></table></figure>
<p>在箭头(=&gt;)和分号(;)之间只能使用一个表达式，不能是语句。</p>
<p>Swift中隐式返回：如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func greeting(person: String) -&gt; String &#123;</span><br><span class="line">    &quot;Hello， &quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在<code>Dart</code>中，定义函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String magicBox(int kind， String name) &#123;</span><br><span class="line">    String partFront &#x3D; (kind &#x3D;&#x3D; 1) ? &quot;I&#39;m a Dog!&quot; : &quot;I&#39;m a Panda!&quot;;</span><br><span class="line">    String partBhand &#x3D; (name &#x3D;&#x3D; null) ? &#39;&#39; : &quot;My name is $name&quot;;</span><br><span class="line">    return partFront + partBhand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用时必须传入实参，称为必选参数。</p>
<p>也存在可选参数的方式定义函数。</p>
<ul>
<li>命名可选参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String magicBox(int kind， &#123;String name&#125;) &#123;</span><br><span class="line">    String partFront &#x3D; (kind &#x3D;&#x3D; 1) ? &quot;I&#39;m a Dog!&quot; : &quot;I&#39;m a Panda!&quot;;</span><br><span class="line">    String partBhand &#x3D; (name &#x3D;&#x3D; null) ? &#39;&#39; : &quot;My name is $name&quot;;</span><br><span class="line">    return partFront + partBhand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>被设置为可选参数，所以在调用该方法时，实参可传可不传。<br>可以使用<code>=</code>来定义可选参数的默认值。默认值只能是编译时常量。如果没有提供默认值，则默认值为<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String magicBox(&#123;@required int kind， String name&#125;) &#123;</span><br><span class="line">    String partFront &#x3D; (kind &#x3D;&#x3D; 1) ? &quot;I&#39;m a Dog!&quot; : &quot;I&#39;m a Panda!&quot;;</span><br><span class="line">    String partBhand &#x3D; (name &#x3D;&#x3D; null) ? &#39;&#39; : &quot;My name is $name&quot;;</span><br><span class="line">    return partFront + partBhand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种可选参数的写法与上面写法的效果是一模一样的。推荐这种写法。</p>
<ul>
<li>位置可选参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String magicBox(int kind， [String name]) &#123;</span><br><span class="line">    String partFront &#x3D; (kind &#x3D;&#x3D; 1) ? &quot;I&#39;m a Dog!&quot; : &quot;I&#39;m a Panda!&quot;;</span><br><span class="line">    String partBhand &#x3D; (name &#x3D;&#x3D; null) ? &#39;&#39; : &quot;My name is $name&quot;;</span><br><span class="line">    return partFront + partBhand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在<code>Swift</code>中，没有可选参数的概念，但是可以通过<code>默认参数值</code>的方式来达到可选参数的效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func magicBox(kind: Int， name: String=<span class="string">&quot;&quot;</span>) -&gt; String &#123;</span><br><span class="line">        <span class="built_in">let</span> partFront = (kind == 1) ? <span class="string">&quot;I&#x27;m a Dog!&quot;</span> : <span class="string">&quot;I&#x27;m a Panda!&quot;</span>;</span><br><span class="line">        <span class="built_in">let</span> partBhand = (name == <span class="string">&quot;&quot;</span>) ? name : <span class="string">&quot;My name is \(name)&quot;</span>;</span><br><span class="line">        <span class="built_in">return</span> partFront + partBhand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</p>
<p>顺便介绍下，<code>Swift</code>中每个函数参数都有一个参数标签（argument label）以及一个参数名称（parameter name）。默认情况下，函数参数使用参数名称来作为它们的参数标签。如果你不希望为某个参数添加一个标签，可以使用一个下划线（_）来代替一个明确的参数标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func someFunction(argumentLabel parameterName: Int) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>someFunction</code>函数的参数标签是<code>argumentLabel</code>在函数外部调用的时候使用，参数名称是<code>parameterName </code>在函数体内使用。</p>
<blockquote>
<p>1.二者都可以给参数设置默认值。2.在<code>Dart</code>中，支持可选参数，而<code>Swift</code>中不支持，但是可以通过设置默认值方式实现可选参数功能。</p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在<code>Dart</code>中，每个对象都是一个类的实例，所有的类都继承于<code>Object</code>。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>1.<code>Dart</code>和<code>Swift</code>中，类没有明确指定构造方法时，将默认拥有一个无参的构造方法。我们也可以根据自己的需求，定义构造方法，当有了自己的构造方法时，默认的构造方法将会失效，不能使用。</p>
<p>2.<code>Dart</code>不支持函数的重载（名称相同， 参数不同），而<code>Swift</code>支持。</p>
<p>3.在实现构造方法时，通常做的事情就是通过参数给属性赋值，为了简化这一过程，Dart提供了一种更加简洁的语法糖形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person(String name， int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 等同于</span><br><span class="line">  Person(this.name， this.age);</span><br></pre></td></tr></table></figure>

<p>4.命名构造方法</p>
<p>在开发中，我们确实希望实现更多的构造方法，怎么办呢？<br>因为不支持方法的重载，所以我们使用命名构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  Person() &#123;</span><br><span class="line">    name &#x3D; &#39;&#39;;</span><br><span class="line">    age &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 命名构造方法</span><br><span class="line">  Person.withArgments(String name, int age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F; 命名构造方法</span><br><span class="line">	Person.fromMap(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">    this.name &#x3D; map[&#39;name&#39;];</span><br><span class="line">    this.age &#x3D; map[&#39;age&#39;];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  String toString() &#123;</span><br><span class="line">    return &#39;name&#x3D;$name age&#x3D;$age&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建对象</span><br><span class="line">var p1 &#x3D; new Person();</span><br><span class="line">print(p1);</span><br><span class="line">var p2 &#x3D; new Person.withArgments(&#39;why&#39;, 18);</span><br><span class="line">print(p2);</span><br><span class="line">var p3 &#x3D; new Person.fromMap(&#123;&#39;name&#39;: &#39;kobe&#39;, &#39;age&#39;: 30&#125;);</span><br><span class="line">print(p3);</span><br></pre></td></tr></table></figure>

<p>5.初始化列表</p>
<p>我们来重新定义一个类Point， 传入x/y，可以得到它们的距离distance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  final num x;</span><br><span class="line">  final num y;</span><br><span class="line">  final num distance;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 错误写法</span><br><span class="line">  &#x2F;&#x2F; Point(this.x, this.y) &#123;</span><br><span class="line">  &#x2F;&#x2F;   distance &#x3D; sqrt(x * x + y * y);</span><br><span class="line">  &#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 正确的写法</span><br><span class="line">  Point(this.x, this.y) : distance &#x3D; sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.重定向构造方法</p>
<p>在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line">  Person.fromName(String name) : this(name, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.常量构造方法</p>
<p>在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法.<br>将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var p1 &#x3D; const Person(&#39;why&#39;);</span><br><span class="line">  var p2 &#x3D; const Person(&#39;why&#39;);</span><br><span class="line">  print(identical(p1, p2)); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  final String name;</span><br><span class="line"></span><br><span class="line">  const Person(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点:<br>一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的。<br>二: 为了可以通过常量构造方法，创建出相同的对象，不再使用new关键字，而是使用const关键字。如果是将结果赋值给const修饰的标识符时，const可以省略。</p>
<p>8.工厂构造方法</p>
<p>Dart提供了factory关键字， 用于通过工厂去获取对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  var p1 &#x3D; Person(&#39;why&#39;);</span><br><span class="line">  var p2 &#x3D; Person(&#39;why&#39;);</span><br><span class="line">  print(identical(p1, p2)); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line"></span><br><span class="line">  static final Map&lt;String, Person&gt; _cache &#x3D; &lt;String, Person&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  factory Person(String name) &#123;</span><br><span class="line">    if (_cache.containsKey(name)) &#123;</span><br><span class="line">      return _cache[name];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      final p &#x3D; Person._internal(name);</span><br><span class="line">      _cache[name] &#x3D; p;</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person._internal(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问器与设置器"><a href="#访问器与设置器" class="headerlink" title="访问器与设置器"></a>访问器与设置器</h3><p>在<code>Dart</code>中使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p &#x3D; Person();</span><br><span class="line">  p.setName &#x3D; &quot;kobe&quot;; &#x2F;&#x2F; 设置器赋值</span><br><span class="line">  print(p.getName); &#x2F;&#x2F; 访问器获取值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有的类都继承自Object，即使没有显示声明。</span><br><span class="line">class Person &#123;</span><br><span class="line">  var name;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置器</span><br><span class="line">  set setName(String name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 访问器</span><br><span class="line">  get getName &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的三大特性之一就是继承，不仅提高了代码的复用性，也是多态的前提。</p>
<p>Dart中，父类的所有成员变量和方法都会被继承，但是构造方法除外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p &#x3D; Person();</span><br><span class="line">  p.name &#x3D; &quot;kobe&quot;;</span><br><span class="line">  p.run(); &#x2F;&#x2F; 打印kobe is runing...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  var name;</span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&quot;$name is runing...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有的类都继承自Object，即使没有显示声明。</span><br><span class="line">class Person extends Animal &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>子类可以拥有自己的成员，并且可以对父类的方法进行重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 所有的类都继承自Object，即使没有显示声明。</span><br><span class="line">class Person extends Animal &#123;</span><br><span class="line">  var gender;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&quot;$name is $gender, he is runing...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类的构造方法在执行前，将隐式调用父类的无参默认构造方法，如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final p &#x3D; Person(&quot;man&quot;, &quot;kobe&quot;);</span><br><span class="line">  p.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  var name;</span><br><span class="line"></span><br><span class="line">  Animal(this.name);</span><br><span class="line"></span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&quot;$name is runing...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有的类都继承自Object，即使没有显示声明。</span><br><span class="line">class Person extends Animal &#123;</span><br><span class="line">  var gender;</span><br><span class="line"></span><br><span class="line">  Person(this.gender, String name) : super(name);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&quot;$name is $gender, he is runing...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>约束子类共同的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 抽象类Shape</span><br><span class="line">abstract class Shape &#123;</span><br><span class="line">  double getArea();</span><br><span class="line">  void shapeName() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Shape &#123;</span><br><span class="line">  double r;</span><br><span class="line"></span><br><span class="line">  Circle(this.r);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double getArea() &#123;</span><br><span class="line">    return pi * r * r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Reactangle extends Shape &#123;</span><br><span class="line">  double w;</span><br><span class="line">  double h;</span><br><span class="line"></span><br><span class="line">  Reactangle(this.w, this.h);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  double getArea() &#123;</span><br><span class="line">    return w * h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.抽象类中有声明没有实现的方法是抽象方法。<br>2.抽象类中的抽象方法必须被子类实现，抽象类中已经被实现方法，可以不被子类重写。<br>3.抽象类只能通过工厂构造器实例化。</p>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>Dart中，接口比较特殊，没有一个专门的关键字来声明接口。<br>默认情况下，定义的每个类都相当于也声明了一个接口，可以由其他的类来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract class Run &#123;</span><br><span class="line">  void run() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Fly &#123;</span><br><span class="line">  void fly() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird implements Run, Fly &#123;</span><br><span class="line">  @override</span><br><span class="line">  void fly() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: implement fly</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void run() &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: implement run</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类做接口使用时, 那么实现这个接口的类, 必须实现这个接口中所有方法。</p>
<h3 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h3><p>Dart中，通过implements实现某个类时，类中所有的方法都必须被重新实现，无论这个类原来是否已经实现过该方法。</p>
<p>但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，Dart提供了Mixin混入的方案。</p>
<ul>
<li>除了可以通过class定义类之外，mixin关键字也可以定义一个类。</li>
<li>mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  final b &#x3D; Bird();</span><br><span class="line">  b.fly();</span><br><span class="line">  b.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin Run &#123;</span><br><span class="line">  void run() &#123;</span><br><span class="line">    print(&#39;run&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixin Fly &#123;</span><br><span class="line">  void fly() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird with Run, Fly &#123;</span><br><span class="line">  @override</span><br><span class="line">  void fly() &#123;</span><br><span class="line">    print(&#39;fly&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型中有两个比较常见的属性：<br>index: 用于表示每个枚举常量的索引，从0开始。<br>values: 包含所有枚举值的List。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main(List&lt;String&gt; args) &#123;</span><br><span class="line">  print(Colors.red.index);</span><br><span class="line">  print(Colors.green.index);</span><br><span class="line">  print(Colors.blue.index);</span><br><span class="line"></span><br><span class="line">  print(Colors.values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Colors &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h2><blockquote>
<p>在Dart中任何一个dart文件都是一个库，即使你没有用关键字library声明。</p>
</blockquote>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>import语句用来导入一个库，后面跟一个字符串形式的Uri来指定要引用的库，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;库所在的uri&#39;;</span><br></pre></td></tr></table></figure>

<p>1，常见的库URI有三种不同的形式</p>
<ul>
<li>dart标准库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#96;dart:&#96;前缀表示Dart的标准库。</span><br><span class="line">import &#39;dart:io&#39;;</span><br><span class="line">import &#39;dart:core&#39;; (但是这个可以省略)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义库<br>  使用相对路径导入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以用相对路径或绝对路径的dart文件来引用</span><br><span class="line">import &#39;lib&#x2F;student&#x2F;student.dart&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三方库<br>   Pub包管理工具管理的一些库，包括自己的配置以及一些第三方的库，通常使用前缀package。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Pub包管理系统中有很多功能强大、实用的库 </span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br></pre></td></tr></table></figure>

<p>2，库文件中内容的显示和隐藏</p>
<p>如果希望只导入库中某些内容，或者刻意隐藏库里面某些内容，可以使用<code>show</code>和<code>hide</code>关键字。</p>
<p><strong>show关键字：</strong>可以显示某个成员（屏蔽其他）<br><strong>hide关键字：</strong>可以隐藏某个成员（显示其他）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#39;lib&#x2F;student&#x2F;student.dart&#39; show Student, Person;</span><br><span class="line"></span><br><span class="line">import &#39;lib&#x2F;student&#x2F;student.dart&#39; hide Person;</span><br></pre></td></tr></table></figure>

<p>3，库中内容和当前文件中的名字冲突</p>
<p>当各个库有命名冲突的时候，可以使用as关键字来使用命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#39;lib&#x2F;student&#x2F;student.dart&#39; as Stu;</span><br><span class="line"></span><br><span class="line">Stu.Student s &#x3D; new Stu.Student();</span><br></pre></td></tr></table></figure>

<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1，在定义库时，可以使用<code>library</code>关键字给库起一个名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library math;</span><br></pre></td></tr></table></figure>

<p>2，part关键字</p>
<p>在开发中，如果一个库文件太大，将所有内容保存到一个文件是不太合理的，我们有可能希望将这个库进行拆分，这个时候就可以使用part关键字了。不过官方已经不建议使用这种方式了。</p>
<p>mathUtils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">part of &quot;utils.dart&quot;;</span><br><span class="line"></span><br><span class="line">int sum(int num1, int num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dateUtils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">part of &quot;utils.dart&quot;;</span><br><span class="line"></span><br><span class="line">String dateFormat(DateTime date) &#123;</span><br><span class="line">  return &quot;2020-12-12&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>utils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">part &quot;mathUtils.dart&quot;;</span><br><span class="line">part &quot;dateUtils.dart&quot;;</span><br></pre></td></tr></table></figure>

<p>3，export关键字</p>
<p>官方不推荐使用part关键字，那如果库非常大，如何进行管理呢？</p>
<p>将每一个dart文件作为库文件，使用export关键字在某个库文件中单独导入。</p>
<p>mathUtils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum(int num1, int num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dateUtils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateFormat(DateTime date) &#123;</span><br><span class="line">  return &quot;2020-12-12&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>utils.dart文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library utils;</span><br><span class="line"></span><br><span class="line">export &quot;mathUtils.dart&quot;;</span><br><span class="line">export &quot;dateUtils.dart&quot;;</span><br></pre></td></tr></table></figure>
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://onzxgway.github.io">朱献国</a>
            <p>原文链接：<a href="http://onzxgway.github.io/2020/01/23/DartAndSwift/">http://onzxgway.github.io/2020/01/23/DartAndSwift/</a>
            <p>发表日期：<a href="http://onzxgway.github.io/2020/01/23/DartAndSwift/">January 23rd 2020, 10:44:22 pm</a>
            <!-- <p>更新日期：<a href="http://onzxgway.github.io/2020/01/23/DartAndSwift/">January 16th 2021, 11:20:25 am</a> -->
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/11/02/runtime3/" title= "runtime(2)">
                    <div class="prevTitle">runtime(2)</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:onzxgway@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/onzxgway" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E5%88%86%E5%8F%B7"><span class="toc-number">1.</span> <span class="toc-text">打印、注释、分号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0"><span class="toc-number">1.1.</span> <span class="toc-text">打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%B7"><span class="toc-number">1.3.</span> <span class="toc-text">分号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">声明常量和变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">内建类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E8%AF%AD%E6%B3%95%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">7.1.</span> <span class="toc-text">箭头语法与隐式返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">可选参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">访问器与设置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.5.</span> <span class="toc-text">隐式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixin%E6%B7%B7%E5%85%A5"><span class="toc-number">8.6.</span> <span class="toc-text">Mixin混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.7.</span> <span class="toc-text">枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">库的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-number">10.1.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">10.2.</span> <span class="toc-text">自定义</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 28
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/23</span><a class="archive-post-title" href= "/2020/01/23/DartAndSwift/" >Dart、Swift</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href= "/2019/11/02/runtime3/" >runtime(2)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2019/10/28/runtime2/" >runtime(1)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2019/03/27/runtime1/" >Objective-C对象模型</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href= "/2019/03/04/RunLoop/" >RunLoop</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2019/01/18/DesignPatterns/" >设计模式</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span><a class="archive-post-title" href= "/2018/12/07/UIScrollView/" >UIScrollView、UITableView实现机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/24</span><a class="archive-post-title" href= "/2018/11/24/AFNetworking-Security/" >网络安全</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href= "/2018/10/22/AFNetworking%E8%A7%A3%E6%9E%90/" >AFNetworking解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2018/09/05/KvoAndKvc/" >KVO、KVC</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span><a class="archive-post-title" href= "/2018/07/05/loadAndinitialize/" >load、initialize</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href= "/2018/06/23/Cateory/" >Category</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2018/05/19/AppStatus/" >App的不同状态</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2018/04/16/arithmetic/" >算法基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/16</span><a class="archive-post-title" href= "/2018/03/16/UIWebView/" >基于UIWebView的混合编程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/08</span><a class="archive-post-title" href= "/2018/02/08/object-copy/" >对象拷贝</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2018/01/16/Multi-threading-2/" >iOS并发编程进阶</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2017/12/09/CocoaPods/" >使用CocoaPods做依赖管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/08</span><a class="archive-post-title" href= "/2017/11/08/Block%E5%9F%BA%E7%A1%80/" >Block基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2017/10/11/UIWindow/" >UIWindow</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2017/09/18/memory-management-2/" >内存管理（下）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2017/08/27/memory-management-1/" >内存管理（上）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2017/06/20/network-1/" >断点下载与文件上传</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span><a class="archive-post-title" href= "/2017/05/14/Sandbox/" >Sandbox机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2017/04/08/Time-And-Date2/" >时间与日期（下）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/24</span><a class="archive-post-title" href= "/2017/03/24/TimeANdDate/" >时间与日期（上）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/22</span><a class="archive-post-title" href= "/2017/03/22/Multi-threading-1/" >iOS并发编程基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2017/02/20/hexo-github-1/" >在MacOS上使用Hexo+GitHub搭建个人博客</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "朱献国"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


